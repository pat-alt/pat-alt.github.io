{
  "hash": "81a171ed9e66a3a5b8ad2007fa1b29d0",
  "result": {
    "markdown": "---\ntitle: \"A new tool for explainable AI\"\nsubtitle: \"Explaining models through counterfactuals\"\ndate: '2022-04-20'\ndescription: |\n    This post introduces a new Julia package for generating counterfactual explanations. The package can be used to explain machine learning algorithms developed and trained in Julia as well as other popular programming languages like Python and R.\ncategories:\n  - counterfactuals\n  - explainable AI\n  - Julia\nimage: www/intro.gif\nexecute:\n  eval: false\n  echo: true\ndraft: false\n---\n\n\n\n<div class=\"intro-gif\">\n  <figure>\n    <img src=\"www/intro.gif\">\n    <figcaption>Turning a 9 (nine) into a 4 (four).</figcaption>\n  </figure>\n</div>\n\n<!-- Intro -->\n\nCounterfactual explanations, which I introduced in one of my previous posts^[See: [[TDS](https://towardsdatascience.com/individual-recourse-for-black-box-models-5e9ed1e4b4cc)], [[blog](https://www.paltmeyer.com/blog/posts/individual-recourse-for-black-box-models/)]], offer a simple and intuitive way to explain black-box models without opening them. Still, as of today there exists only one open-source library that provides a unifying approach to generate and benchmark counterfactual explanations for models built and trained in Python [@pawelczyk2021carla]. This is great, but of limited use to users of other programming languages ðŸ¥². \n\nEnter [`CounterfactualExplanations.jl`](https://www.paltmeyer.com/CounterfactualExplanations.jl/stable/): a Julia package that can be used to explain machine learning algorithms developed and trained in Julia, Python and R. Counterfactual explanations fall into the broader category of explainable artificial intelligence (XAI). \n\nExplainable AI typically involves models that are not inherently interpretable but require additional tools to be explainable to humans. Examples of the latter include ensembles, support vector machines and deep neural networks. This is not to be confused with interpretable AI, which involves models that are inherently interpretable and transparent such as general additive models (GAM), decision trees and rule-based models. \n\nSome would argue that we best avoid explaining black-box models altogether [@rudin2019stop] and instead focus solely on interpretable AI. While I agree that initial efforts should always be geared towards interpretable models, stopping there would entail missed opportunities and anyway is probably not very realistic in times of [DALL$\\cdot$E](https://openai.com/blog/dall-e/) and Co.\n\n> Even though [...] interpretability is of great importance and should be pursued, explanations can, in principle, be offered without opening the â€œblack box.â€\n>\n> --- @wachter2017counterfactual\n\n<!-- Nut paragraph -->\n\nThis post introduces the main functionality of the new Julia package. Following a motivating example using a model trained in Julia, we will see how easy the package can be adapted to work with models trained in Python and R. Since the motivation for this post is also to hopefully attract contributors, the final section outlines some of the exciting developments we have planned. \n\n## Counterfactuals for image data ðŸ–¼\n\nTo introduce counterfactual explanations I used a simple binary classification problem in my previous [post](https://towardsdatascience.com/individual-recourse-for-black-box-models-5e9ed1e4b4cc). It involved a linear classifier and a linearly separable, synthetic data set with just two features. This time we are going to step it up a notch: we will generate counterfactual explanations MNIST data. The MNIST dataset contains 60,000 training samples of handwritten digits in the form of 28x28 pixel grey-scale images [@lecun1998mnist]. Each image is associated with a label indicating the digit (0-9) that the image represents. \n\nThe [`CounterfactualExplanations.jl`](https://www.paltmeyer.com/CounterfactualExplanations.jl/stable/) package ships with two black-box models that were trained to predict labels for this data: firstly, a simple multi-layer perceptron (MLP) and, secondly, a corresponding deep ensemble. Originally proposed by @lakshminarayanan2016simple, deep ensembles are really just ensembles of deep neural networks. They are still among the most popular approaches to Bayesian deep learning.^[For more information on Bayesian deep learning see my previous post: [[TDS](https://towardsdatascience.com/go-deep-but-also-go-bayesian-ab25efa6f7b)], [[blog](https://www.paltmeyer.com/blog/posts/effortsless-bayesian-dl/)].] \n\n### Black-box models\n\nThe code below loads relevant packages along with the MNIST data and pre-trained models. \n\n``` {.julia .cell-code}\n# Load package, models and data:\nusing CounterfactualExplanations, Flux\nusing CounterfactualExplanations.Data: mnist_data, mnist_model, mnist_ensemble\ndata, X, ys = mnist_data()\nmodel = mnist_model()\nensemble = mnist_ensemble()\ncounterfactual_data = CounterfactualData(X,ys;domain=(0,1))\n```\n\n\nWhile the package can currently handle a few simple classification models natively, it is designed to be easily extensible through users and contributors. Extending the package to deal with custom models typically involves only two simple steps:\n\n1. **Subtyping**: the custom model needs to be declared as a subtype of the package-internal type `AbstractFittedModel`.\n2. **Multiple dispatch**: the package-internal functions `logits` and `probs` need to be extended through custom methods for the new model type.\n\nThe following code implements these two steps first for the MLP and then for the deep ensemble.\n\n``` {.julia .cell-code}\nusing CounterfactualExplanations.Models\nimport CounterfactualExplanations.Models: logits, probs\n# MLP:\n# Step 1)\nstruct NeuralNetwork <: Models.AbstractFittedModel\n    model::Any\nend\n# Step 2)\nlogits(M::NeuralNetwork, X::AbstractArray) = M.model(X)\nprobs(M::NeuralNetwork, X::AbstractArray)= softmax(logits(M, X))\nM = NeuralNetwork(model)\n\n# Deep ensemble:\nusing Flux: stack\n# Step 1)\nstruct FittedEnsemble <: Models.AbstractFittedModel\n    ensemble::AbstractArray\nend\n# Step 2)\nusing Statistics\nlogits(M::FittedEnsemble, X::AbstractArray) = mean(stack([m(X) for m in M.ensemble],3),dims=3)\nprobs(M::FittedEnsemble, X::AbstractArray) = mean(stack([softmax(m(X)) for m in M.ensemble],3),dims=3)\nM_ensemble = FittedEnsemble(ensemble)\n```\n\n\n### Counterfactual generators\n\nNext, we need to specify the counterfactual generators we want to use. The package currently ships with two default generators that both need gradient access: firstly, the generic generator introduced by @wachter2017counterfactual and, secondly, a greedy generator introduced by @schut2021generating. \n\nThe greedy generator is designed to be used with models that incorporate uncertainty in their predictions such as the deep ensemble introduced above. It works for probabilistic (Bayesian) models, because they only produce high-confidence predictions in regions of the feature domain that are populated by training samples. As long as the model is expressive enough and well-specified, counterfactuals in these regions will always be realistic and unambiguous since by construction they should look very similar to training samples. Other popular approaches to counterfactual explanations like REVISE [@joshi2019towards] and CLUE [@antoran2020getting] also play with this simple idea. \n\nThe following code instantiates the two generators for the problem at hand. \n\n``` {.julia .cell-code}\ngeneric = GenericGenerator(;loss=:logitcrossentropy)\ngreedy = GreedyGenerator(;loss=:logitcrossentropy)\n```\n\n\n### Explanations\n\n\n\nOnce the model and counterfactual generator are specified, running counterfactual search is very easy using the package. For a given factual (`x`), target class (`target`) and data set (`counterfactual_data`), simply running \n\n``` {.julia .cell-code code-fold=\"false\"}\ngenerate_counterfactual(x, target, counterfactual_data, M, generic)\n```\n\n\nwill generate the results, in this case using the generic generator (`generic`) for the MLP (`M`). Since we have specified two different black-box models and two different counterfactual generators, we have four combinations of a model and a generator in total. For each of these combinations I have used the `generate_counterfactual` function to produce the results in @fig-mnist-9to4. \n\nIn every case the desired label switch is in fact achieved, but arguably from a human perspective only the counterfactuals for the deep ensemble look like a four. The generic generator produces mild perturbations in regions that seem irrelevant from a human perspective, but nonetheless yields a counterfactual that can pass as a four. The greedy approach clearly targets pixels at the top of the handwritten nine and yields the best result overall. For the non-Bayesian MLP, both the generic and the greedy approach generate counterfactuals that look much like adversarial examples: they perturb pixels in seemingly random regions on the image.\n\n\n\n\n\n![Counterfactual explanations for MNIST: turning a nine (9) into a four (4).](www/mnist_9_to_4.png){#fig-mnist-9to4}\n\n\n\n## Language interoperability ðŸ‘¥\n\nThe Julia language offers unique support for programming language interoperability. For example, calling R or Python is made remarkably easy through `RCall.jl` and `PyCall.jl`, respectively. This functionality can be leveraged to use `CounterfactualExplanations.jl` to generate explanations for models that were developed in other programming languages. At this time there is no native support for foreign programming languages, but the following example involving a `torch` neural network trained in `R` demonstrates how versatile the package is.^[The corresponding example involving `PyTorch` is analogous and therefore not included here. You may find it [here](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/tutorials/interop/).]\n\n### Explaining a `torch` model \n\n\n\n\n\nWe will consider a simple MLP trained for a binary classification task. As before we first need to adapt this custom model for use with our package. The code below the two necessary steps - sub-typing and method extension. Logits are returned by the `torch` model and copied from the R environment into the Julia scope. Probabilities are then computed inside the Julia scope by passing the logits through the sigmoid function.\n\n``` {.julia .cell-code}\nusing Flux\nusing CounterfactualExplanations, CounterfactualExplanations.Models\nimport CounterfactualExplanations.Models: logits, probs # import functions in order to extend\n\n# Step 1)\nstruct TorchNetwork <: Models.AbstractFittedModel\n    nn::Any\nend\n\n# Step 2)\nfunction logits(M::TorchNetwork, X::AbstractArray)\n  nn = M.nn\n  y = rcopy(R\"as_array($nn(torch_tensor(t($X))))\")\n  y = isa(y, AbstractArray) ? y : [y]\n  return y'\nend\nfunction probs(M::TorchNetwork, X::AbstractArray)\n  return Ïƒ.(logits(M, X))\nend\nM = TorchNetwork(R\"model\")\n```\n\n\nCompared to models trained in Julia, we need to do a little more work at this point. Since our counterfactual generators need gradient access, we essentially need to allow our package to communicate with the R `torch` library. While this may sound daunting, it turns out to be quite manageable: all we have to do is respecify the function that computes the gradient with respect to the counterfactual loss function so that it can deal with the `TorchNetwork` type we defined above. That is all the adjustment needed to use `CounterfactualExplanations.jl` for our custom R model. @fig-torch shows a counterfactual path for a randomly chosen sample with respect to the MLP trained in R.\n\n:::{.callout-caution}\n## Experimental functionality\n\nYou may have stumbled across the term *respecify* above: does it really seem like a good idea to just replace an existing function from our package? Surely not! There are certainly better ways to go about this, which we will consider when adding native support for Python and R models in future package releases. Which brings us to our final section ...\n:::\n\n``` {.julia .cell-code}\nimport CounterfactualExplanations.Generators: âˆ‚â„“\nusing LinearAlgebra\n\n# Countefactual loss:\nfunction âˆ‚â„“(\n    generator::AbstractGradientBasedGenerator, \n    counterfactual_state::CounterfactualState) \n  M = counterfactual_state.M\n  nn = M.nn\n  xâ€² = counterfactual_state.xâ€²\n  t = counterfactual_state.target_encoded\n  R\"\"\"\n  x <- torch_tensor($xâ€², requires_grad=TRUE)\n  output <- $nn(x)\n  loss_fun <- nnf_binary_cross_entropy_with_logits\n  obj_loss <- loss_fun(output,$t)\n  obj_loss$backward()\n  \"\"\"\n  grad = rcopy(R\"as_array(x$grad)\")\n  return grad\nend\n```\n\n\n\n\n\n\n![Counterfactual path using the generic counterfactual generator for a model trained in R.](www/interop_r.gif){#fig-torch}\n\n<!-- kicker -->\n\n## We need you! ðŸ«µ\n\nThe ambition for `CounterfactualExplanations.jl` is to provide a go-to place for counterfactual explanations to the Julia community and beyond. This is a grand ambition, especially for a package that has so far been built by a single developer who has little prior experience with Julia. We would therefore very much like to invite community contributions. If you have an interest in trustworthy AI, the open-source community and Julia, please do get involved! This package is still in its early stages of development, so any kind of contribution is welcome: advice on the core package architecture, pull requests, issues, discussions and even just comments below would be much appreciated. \n\nTo give you a flavor of what type of future developments we envision, here is a non-exhaustive list:\n\n1. Native support for additional counterfactual generators and predictive models including those built and trained in Python or R.\n2. Additional datasets for testing, evaluation and benchmarking.\n3. Improved preprocessing including native support for categorical features.\n4. Support for regression models.\n\nFinally, if you like this project but don't have much time, then simply sharing this article or starring the [repo](https://github.com/pat-alt/CounterfactualExplanations.jl) on GitHub would also go a long way.\n\n## Further reading ðŸ“š\n\nIf you're interested in learning more about this development, feel free to check out the following resources:\n\n- Package docs: [[stable]](https://pat-alt.github.io/CounterfactualExplanations.jl/stable), [[dev]](https://pat-alt.github.io/CounterfactualExplanations.jl/dev).\n- [Contributor's guide](https://www.paltmeyer.com/CounterfactualExplanations.jl/stable/contributing/).\n- [GitHub repo](https://github.com/pat-alt/CounterfactualExplanations.jl).\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}