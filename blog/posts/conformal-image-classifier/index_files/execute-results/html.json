{
  "hash": "4832fcff5b62ec5be8a208d288b23e87",
  "result": {
    "markdown": "---\ntitle: How to Conformalize a Deep Image Classifier\nsubtitle: Conformal Prediction in Julia --- Part 2\nauthor: Patrick Altmeyer\ndate: '2022-12-05'\ncategories:\n  - conformal prediction\n  - uncertainty\n  - Julia\ndescription: 'A guide demonstrating how to use [`ConformalPrediction.jl`](https://github.com/pat-alt/ConformalPrediction.jl) to conformalize a deep image classifier in a few lines of code.'\nimage: www/intro.gif\ndraft: false\n---\n\n\n\n<div class=\"intro-gif\">\n  <figure>\n    <img src=\"www/intro.gif\">\n    <figcaption>Conformalized prediction sets for a<br>simple Deep Image Classifier.</figcaption>\n  </figure>\n</div>\n\nDeep Learning is popular and --- for some tasks like image classification --- remarkably powerful. But it is also well-known that Deep Neural Networks (DNN) can be unstable [@goodfellow2014explaining] and poorly calibrated. Conformal Prediction can be used to mitigate these pitfalls. \n\nIn the [first part](../conformal-prediction/index.qmd) of this series of posts on Conformal Prediction, we looked at the basic underlying methodology and how CP can be implemented in Julia using [`ConformalPrediction.jl`](https://github.com/pat-alt/ConformalPrediction.jl). This second part of the series is a more goal-oriented how-to guide: it demonstrates how you can conformalize a deep learning image classifier built in `Flux.jl` in just a few lines of code. \n\nSince this is meant to be more of a hands-on article, we will avoid diving too deeply into methodological concepts. If you need more colour on this, be sure to check out the [first article](../conformal-prediction/index.qmd) on this topic and also @angelopoulos2021gentle. For a more formal treatment of Conformal Prediction see also @angelopoulos2022uncertainty.\n\n## 🎯 The Task at Hand \n\nThe task at hand is to predict the labels of handwritten images of digits using the famous MNIST dataset [@lecun1998mnist]. Importing this popular machine learning dataset in Julia is made remarkably easy through `MLDatasets.jl`:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing MLDatasets\nN = 1000\nXraw, yraw = MNIST(split=:train)[:]\nXraw = Xraw[:,:,1:N]\nyraw = yraw[1:N]\n```\n:::\n\n\n@fig-samples below shows a few random samples from the training data:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing MLJ\nusing Images\nX = map(x -> convert2image(MNIST, x), eachslice(Xraw, dims=3))\ny = coerce(yraw, Multiclass)\n\nn_samples = 10\nmosaic(rand(X, n_samples)..., ncol=n_samples)\n```\n\n::: {#fig-samples .cell-output .cell-output-display execution_count=4}\n```{=html}\n<img src=\"data:image/png;base64,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\">\n```\n\nRandom samples from the MNIST dataset.\n:::\n:::\n\n\n## 🚧 Building the Network\n\nTo model the mapping from image inputs to labels will rely on a simple Multi-Layer Perceptron (MLP). A great Julia library for Deep Learning is `Flux.jl`. But wait ... doesn't `ConformalPrediction.jl` work with models trained in `MLJ.jl`? That's right, but fortunately there exists a `Flux.jl` interface to `MLJ.jl`, namely `MLJFlux.jl`. The interface is still in its early stages, but already very powerful and easily accessible for anyone (like myself) who is used to building Neural Networks in `Flux.jl`. \n\nIn `Flux.jl`, you could build an MLP for this task as follows,\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nusing Flux\n\nmlp = Chain(\n    Flux.flatten,\n    Dense(prod((28,28)), 32, relu),\n    Dense(32, 10)\n)\n```\n:::\n\n\nwhere `(28,28)` is just the input dimension (28x28 pixel images). Since we have ten digits, our output dimension is ten.^[For a full tutorial on how to build an MNIST image classifier relying solely on `Flux.jl`, check out this [tutorial](https://fluxml.ai/Flux.jl/stable/tutorials/2021-01-26-mlp/).]\n\nWe can do the exact same thing in `MLJFlux.jl` as follows,\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nusing MLJFlux\n\nbuilder = MLJFlux.@builder Chain(\n    Flux.flatten,\n    Dense(prod(n_in), 32, relu),\n    Dense(32, n_out)\n)\n```\n:::\n\n\nwhere here we rely on the `@builder` macro to make the transition from `Flux.jl` to `MLJ.jl` as seamless as possible. Finally, `MLJFlux.jl` already comes with a number of helper functions to define plain-vanilla networks. In this case, we will use the `ImageClassifier` with our custom builder and cross-entropy loss:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nImageClassifier = @load ImageClassifier\nclf = ImageClassifier(\n    builder=builder,\n    epochs=10,\n    loss=Flux.crossentropy\n)\n```\n:::\n\n\nThe generated instance `clf` is a model (in the `MLJ.jl` sense) so from this point on we can rely on standard `MLJ.jl` workflows. For example, we can wrap our model in data to create a machine and then evaluate it on a holdout set as follows:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nmach = machine(clf, X, y)\n\nevaluate!(\n    mach,\n    resampling=Holdout(rng=123, fraction_train=0.8),\n    operation=predict_mode,\n    measure=[accuracy]\n)\n```\n:::\n\n\nThe accuracy of our very simple model is not amazing, but good enough for the purpose of this tutorial. For each image, our MLP returns a softmax output for each possible digit: 0,1,2,3,...,9. Since each individual softmax output is valued between zero and one, $y_k\\in(0,1)$, this is commonly interpreted as a probability: $y_k \\coloneqq p(y=k|X)$. Edge cases -- that is values close to either zero or one -- indicate high predictive certainty. But this is only a heuristic notion of predictive uncertainty [@angelopoulos2021gentle]. Next, we will turn this heuristic notion of uncertainty into a rigorous one using Conformal Prediction.\n\n## 🔥 Conformalizing the Network\n\nSince `clf` is a model, it is also compatible with our package: `ConformalPrediction.jl`. To conformalize our MLP, we therefore only need to call `conformal_model(clf)`. Since the generated instance `conf_model` is also just a model, we can still rely on standard `MLJ.jl` workflows. Below we first wrap it in data and then fit it. Aaaand ... we're done! Let's look at the results in the next section.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nusing ConformalPrediction\nconf_model = conformal_model(clf; method=:simple_inductive, coverage=.95)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n## 📊 Results\n\n\n\n@fig-plots below presents the results. @fig-plots-1 displays highly certain predictions, now defined in the rigorous sense of Conformal Prediction: in each case, the conformal set (just beneath the image) includes only one label. \n\n@fig-plots-2 and @fig-plots-3 display increasingly uncertain predictions of set size two and three, respectively. They demonstrate that CP is well equipped to deal with samples characterized by high aleatoric uncertainty: digits four (4), seven (7) and nine (9) share certain similarities. So do digits five (5) and six (6) as well as three (3) and eight (8). These may be hard to distinguish from each other even after seeing many examples (and even for a human). It is therefore unsurprising to see that these digits often end up together in conformal sets. \n\n::: {#fig-plots .cell layout-nrow='3' execution_count=10}\n\n::: {.cell-output .cell-output-display}\n![Randomly selected prediction sets of size $|C|=1$.](index_files/figure-html/fig-plots-output-1.svg){#fig-plots-1}\n:::\n\n::: {.cell-output .cell-output-display}\n![Randomly selected prediction sets of size $|C|=2$.](index_files/figure-html/fig-plots-output-2.svg){#fig-plots-2}\n:::\n\n::: {.cell-output .cell-output-display}\n![Randomly selected prediction sets of size $|C|=3$.](index_files/figure-html/fig-plots-output-3.svg){#fig-plots-3}\n:::\n\nConformalized predictions from an image classifier.\n:::\n\n\n\n\n## 🧐 Evaluation\n\nTo evaluate the performance of conformal models, specific performance measures can be used to assess if the model is correctly specified and well-calibrated [@angelopoulos2021gentle]. We will look at this in some more detail in another post in the future. For now, just be aware that these measures are already available in `ConformalPrediction.jl` and we will briefly showcase them here.\n\nAs for many other things, `ConformalPrediction.jl` taps into the existing functionality of `MLJ.jl` for model evaluation. In particular, we will see below how we can use the generic `evaluate!` method on our machine. To assess the correctness of our conformal predictor, we can compute the empirical coverage rate using the custom performance measure `emp_coverage`. With respect to model calibration we will look at the model's conditional coverage. For adaptive, well-calibrated conformal models, conditional coverage is high. One general go-to measure for assessing conditional coverage is size-stratified coverage. The custom measure for this purpose is just called `size_stratified_coverage`, aliased by `ssc`. \n\nThe code below implements the model evaluation using cross-validation. The Simple Inductive Classifier that we used above is not adaptive and hence the attained conditional coverage is low compared to the overall empirical coverage, which is close to $0.95$, so in line with the desired coverage rate specified above.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n_eval = evaluate!(\n    mach,\n    resampling=CV(),\n    operation=predict,\n    measure=[emp_coverage, ssc]\n)\ndisplay(_eval)\nprintln(\"Empirical coverage: $(round(_eval.measurement[1], digits=3))\")\nprintln(\"SSC: $(round(_eval.measurement[2], digits=3))\")\n```\n\n::: {.cell-output .cell-output-display}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>PerformanceEvaluation object with these fields:\n  measure, operation, measurement, per_fold,\n  per_observation, fitted_params_per_fold,\n  report_per_fold, train_test_rows\nExtract:\n┌───────────────────────────────────────────────────────────┬───────────┬───────\n│ measure                                                   │ operation │ meas ⋯\n├───────────────────────────────────────────────────────────┼───────────┼───────\n│ emp_coverage (generic function with 1 method)             │ predict   │ 0.95 ⋯\n│ size_stratified_coverage (generic function with 1 method) │ predict   │ 0.68 ⋯\n└───────────────────────────────────────────────────────────┴───────────┴───────\n<span class=\"ansi-cyan-fg\">                                                               3 columns omitted</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpirical coverage: 0.957\nSSC: 0.687\n```\n:::\n:::\n\n\n\n\nWe can attain higher adaptivity (SSC) when using adaptive prediction sets:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nconf_model = conformal_model(clf; method=:adaptive_inductive, coverage=.95)\nmach = machine(conf_model, X, y)\nfit!(mach)\n_eval = evaluate!(\n    mach,\n    resampling=CV(),\n    operation=predict,\n    measure=[emp_coverage, ssc]\n)\nresults[:adaptive_inductive] = mach\ndisplay(_eval)\nprintln(\"Empirical coverage: $(round(_eval.measurement[1], digits=3))\")\nprintln(\"SSC: $(round(_eval.measurement[2], digits=3))\")\n```\n\n::: {.cell-output .cell-output-display}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>PerformanceEvaluation object with these fields:\n  measure, operation, measurement, per_fold,\n  per_observation, fitted_params_per_fold,\n  report_per_fold, train_test_rows\nExtract:\n┌───────────────────────────────────────────────────────────┬───────────┬───────\n│ measure                                                   │ operation │ meas ⋯\n├───────────────────────────────────────────────────────────┼───────────┼───────\n│ emp_coverage (generic function with 1 method)             │ predict   │ 0.99 ⋯\n│ size_stratified_coverage (generic function with 1 method) │ predict   │ 0.95 ⋯\n└───────────────────────────────────────────────────────────┴───────────┴───────\n<span class=\"ansi-cyan-fg\">                                                               3 columns omitted</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpirical coverage: 0.99\nSSC: 0.955\n```\n:::\n:::\n\n\nWe can also have a look at the resulting set size for both approaches using a custom `Plots.jl` recipe (fig-setsize). In line with the above, the spread is wider for the adaptive approach, which reflects that \"the procedure is effectively distinguishing between easy and hard inputs\" [@angelopoulos2021gentle].\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nplt_list = []\nfor (_mod, mach) in results\n    push!(plt_list, bar(mach.model, mach.fitresult, X; title=String(_mod)))\nend\nplot(plt_list..., size=(800,300))\nplot(plt_list..., size=(800,300),bg_colour=:transparent)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![Distribution of set sizes for both approaches.](index_files/figure-html/fig-setsize-output-1.svg){#fig-setsize}\n:::\n:::\n\n\n## 🔁 Recap\n\nIn this short guide we have seen how easy it is to conformalize a deep learning image classifier in Julia using `ConformalPrediction.jl`. Almost any deep neural network trained in `Flux.jl` is compatible with `MLJ.jl` and can therefore be conformalized in just a few lines of code. This makes it remarkably easy to move uncertainty heuristics to rigorous predictive uncertainty estimates. We have also seen a sneak peek at performance evaluation of conformal predictors. Stay tuned for more!\n\n## 🎓 References\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}