<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Patrick Altmeyer">
<meta name="dcterms.date" content="2022-10-25">
<meta name="description" content="A (very) gentle introduction to Conformal Prediction in Julia using my new package ConformalPrediction.jl.">

<title>patalt - Conformal Prediction in Julia 🟣🔴🟢</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../..//www/favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BEEZ30787D"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BEEZ30787D', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="patalt - Conformal Prediction in Julia 🟣🔴🟢">
<meta property="og:description" content="A (very) gentle introduction to Conformal Prediction in Julia using my new package ConformalPrediction.jl.">
<meta property="og:image" content="https://www.patalt.org/blog/posts/conformal-prediction/www/intro.gif">
<meta property="og:site_name" content="patalt">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../www/icon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">patalt</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/publications/index.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/talks/index.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../../blog/index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pat-alt"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://julialang.social/@patalt" rel="me"> <i class="bi bi-mastodon" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-background" id="toc-sec-background" class="nav-link active" data-scroll-target="#sec-background">📖 Background</a></li>
  <li><a href="#sec-julia" id="toc-sec-julia" class="nav-link" data-scroll-target="#sec-julia">📦 Conformal Prediction in Julia</a>
  <ul class="collapse">
  <li><a href="#sec-scp" id="toc-sec-scp" class="nav-link" data-scroll-target="#sec-scp">Split Conformal Classification</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">🏁 Conclusion</a></li>
  <li><a href="#further-resources" id="toc-further-resources" class="nav-link" data-scroll-target="#further-resources">📚 Further Resources</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/pat-alt/pat-alt.github.io/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Conformal Prediction in Julia 🟣🔴🟢</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
<p class="subtitle lead">Conformal Prediction in Julia — Part 1</p>
  <div class="quarto-categories">
    <div class="quarto-category">conformal prediction</div>
    <div class="quarto-category">uncertainty</div>
    <div class="quarto-category">Julia</div>
  </div>
  </div>

<div>
  <div class="description">
    A (very) gentle introduction to Conformal Prediction in Julia using my new package <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a>.
  </div>
</div>

<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://www.paltmeyer.com/">Patrick Altmeyer</a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <a href="https://www.tudelft.nl/en/">
            Delft University of Technology
            </a>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 25, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="intro-gif">
<figure class="figure">
<img src="www/intro.gif" class="figure-img">
<figcaption>
Prediction sets for two different samples <br> and changing coverage rates. <br> As coverage grows, so does the size of the <br> prediction sets.
</figcaption>
</figure>
</div>
<p>A first crucial step towards building trustworthy AI systems is to be transparent about predictive uncertainty. Model parameters are random variables and their values are estimated from noisy data. That inherent stochasticity feeds through to model predictions and should to be addressed, at the very least in order to avoid overconfidence in models.</p>
<p>Beyond that obvious concern, it turns out that quantifying model uncertainty actually opens up a myriad of possibilities to improve up- and down-stream modeling tasks like active learning and robustness. In Bayesian Active Learning, for example, uncertainty estimates are used to guide the search for new input samples, which can make ground-truthing tasks more efficient <span class="citation" data-cites="houlsby2011bayesian">(<a href="#ref-houlsby2011bayesian" role="doc-biblioref">Houlsby et al. 2011</a>)</span>. With respect to model performance in downstream tasks, uncertainty quantification can be used to improve model calibration and robustness <span class="citation" data-cites="lakshminarayanan2016simple">(<a href="#ref-lakshminarayanan2016simple" role="doc-biblioref">Lakshminarayanan, Pritzel, and Blundell 2017</a>)</span>.</p>
<p>In previous posts we have looked at how uncertainty can be quantified in the Bayesian context (see <a href="https://www.patalt.org/blog/posts/bayesian-logit/">here</a> and <a href="https://www.patalt.org/blog/posts/effortsless-bayesian-dl/">here</a>). Since in Bayesian modeling we are generally concerned with estimating posterior distributions, we get uncertainty estimates almost as a byproduct. This is great for all intends and purposes, but it hinges on assumptions about prior distributions. Personally, I have no quarrel with the idea of making prior distributional assumptions. On the contrary, I think the Bayesian framework formalizes the idea of integrating prior information in models and therefore provides a powerful toolkit for conducting science. Still, in some cases this requirement may be seen as too restrictive or we may simply lack prior information.</p>
<p>Enter: Conformal Prediction (CP) — a scalable frequentist approach to uncertainty quantification and coverage control. In this post we will go through the basic concepts underlying CP. A number of hands-on usage examples in Julia should hopefully help to convey some intuition and ideally attract people interested in contributing to a new and exciting open-source development.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
🏃‍♀️ TL;DR
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li>Conformal Prediction is an interesting frequentist approach to uncertainty quantification that can even be combined with Bayes (<a href="#sec-background" class="quarto-xref">Section&nbsp;1</a>).</li>
<li>It is scalable and model-agnostic and therefore well applicable to machine learning (<a href="#sec-background" class="quarto-xref">Section&nbsp;1</a>).</li>
<li><a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a> implements CP in pure Julia and can be used with any supervised model available from <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> (<a href="#sec-julia" class="quarto-xref">Section&nbsp;2</a>).</li>
<li>Implementing CP directly on top of an existing, powerful machine learning toolkit demonstrates the potential usefulness of this framework to the ML community (<a href="#sec-julia" class="quarto-xref">Section&nbsp;2</a>).</li>
<li>Standard conformal classifiers produce set-valued predictions: for ambiguous samples these sets are typically large (for high coverage) or empty (for low coverage) (<a href="#sec-scp" class="quarto-xref">Section&nbsp;2.1</a>).</li>
</ol>
</div>
</div>
<section id="sec-background" class="level2">
<h2 class="anchored" data-anchor-id="sec-background">📖 Background</h2>
<p>Conformal Prediction promises to be an easy-to-understand, distribution-free and model-agnostic way to generate statistically rigorous uncertainty estimates. That’s quite a mouthful, so let’s break it down: firstly, as I will hopefully manage to illustrate in this post, the underlying concepts truly are fairly straight-forward to understand; secondly, CP indeed relies on only minimal distributional assumptions; thirdly, common procedures to generate conformal predictions really do apply almost universally to all supervised models, therefore making the framework very intriguing to the ML community; and, finally, CP does in fact come with a frequentist coverage guarantee that ensures that conformal prediction sets contain the true value with a user-chosen probability. For a formal proof of this <em>marginal coverage</em> property and a detailed introduction to the topic, I recommend <span class="citation" data-cites="angelopoulos2021gentle">Angelopoulos and Bates (<a href="#ref-angelopoulos2021gentle" role="doc-biblioref">2022</a>)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In what follows we will loosely treat the tutorial by <span class="citation" data-cites="angelopoulos2021gentle">Angelopoulos and Bates (<a href="#ref-angelopoulos2021gentle" role="doc-biblioref">2022</a>)</span> and the general framework it sets as a reference. You are not expected to have read the paper, but I also won’t reiterate any details here.</p>
</div>
</div>
<p>CP can be used to generate prediction intervals for regression models and prediction sets for classification models (more on this later). There is also some recent work on conformal predictive distributions and probabilistic predictions. Interestingly, it can even be used to complement Bayesian methods. <span class="citation" data-cites="angelopoulos2021gentle">Angelopoulos and Bates (<a href="#ref-angelopoulos2021gentle" role="doc-biblioref">2022</a>)</span>, for example, point out that prior information should be incorporated into prediction sets and demonstrate how Bayesian predictive distributions can be conformalized in order to comply with the frequentist notion of coverage. Relatedly, <span class="citation" data-cites="hoff2021bayesoptimal">Hoff (<a href="#ref-hoff2021bayesoptimal" role="doc-biblioref">2021</a>)</span> proposes a Bayes-optimal prediction procedure. And finally, <span class="citation" data-cites="stanton2022bayesian">Stanton, Maddox, and Wilson (<a href="#ref-stanton2022bayesian" role="doc-biblioref">2022</a>)</span> very recently proposed a way to introduce conformal prediction in Bayesian Optimization. I find this type of work that combines different schools of thought very promising, but I’m drifting off a little … So, without further ado, let us look at some code.</p>
</section>
<section id="sec-julia" class="level2">
<h2 class="anchored" data-anchor-id="sec-julia">📦 Conformal Prediction in Julia</h2>
<p>In this section of this first short post on CP we will look at how conformal prediction can be implemented in Julia. In particular, we will look at an approach that is compatible with any of the many supervised machine learning models available in <a href="https://alan-turing-institute.github.io/MLJ.jl/dev/">MLJ</a>: a beautiful, comprehensive machine learning framework funded by the <a href="https://www.turing.ac.uk/">Alan Turing Institute</a> and the <a href="https://www.mbie.govt.nz/science-and-technology/science-and-innovation/funding-information-and-opportunities/investment-funds/strategic-science-investment-fund/ssif-funded-programmes/university-of-auckland/">New Zealand Strategic Science Investment Fund</a> <span class="citation" data-cites="blaom2020mlj">Blaom et al. (<a href="#ref-blaom2020mlj" role="doc-biblioref">2020</a>)</span>. We will go through some basic usage examples employing a new Julia package that I have been working on: <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a>
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>ConformalPrediction.jl</code> is a package for uncertainty quantification through conformal prediction for machine learning models trained in <a href="https://alan-turing-institute.github.io/MLJ.jl/dev/">MLJ</a>. At the time of writing it is still in its early stages of development, but already implements a range of different approaches to CP. Contributions are very much welcome:</p>
<ul>
<li><a href="https://www.patalt.org/ConformalPrediction.jl/stable/">Documentation</a></li>
<li><a href="https://www.patalt.org/ConformalPrediction.jl/stable/#Contribute">Contributor’s Guide</a></li>
</ul>
</div>
</div>
<section id="sec-scp" class="level3">
<h3 class="anchored" data-anchor-id="sec-scp">Split Conformal Classification</h3>
<p>We consider a simple binary classification problem. Let <span class="math inline">\((X_i, Y_i), \ i=1,...,n\)</span> denote our feature-label pairs and let <span class="math inline">\(\mu: \mathcal{X} \mapsto \mathcal{Y}\)</span> denote the mapping from features to labels. For illustration purposes we will use the moons dataset 🌙. Using <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> we first generate the data and split into into a training and test set:</p>
<div id="3e794a5d" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">using</span> <span class="bu">MLJ</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">using</span> <span class="bu">Random</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="bu">Random</span>.<span class="fu">seed!</span>(<span class="fl">123</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co"># Data:</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>X, y <span class="op">=</span> <span class="fu">make_moons</span>(<span class="fl">500</span>; noise<span class="op">=</span><span class="fl">0.15</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a>train, test <span class="op">=</span> <span class="fu">partition</span>(<span class="fu">eachindex</span>(y), <span class="fl">0.8</span>, shuffle<span class="op">=</span><span class="cn">true</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here we will use a specific case of CP called <em>split conformal prediction</em> which can then be summarized as follows:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<ol type="1">
<li>Partition the training into a proper training set and a separate calibration set: <span class="math inline">\(\mathcal{D}_n=\mathcal{D}^{\text{train}} \cup \mathcal{D}^{\text{cali}}\)</span>.</li>
<li>Train the machine learning model on the proper training set: <span class="math inline">\(\hat\mu_{i \in \mathcal{D}^{\text{train}}}(X_i,Y_i)\)</span>.</li>
<li>Compute nonconformity scores, <span class="math inline">\(\mathcal{S}\)</span>, using the calibration data <span class="math inline">\(\mathcal{D}^{\text{cali}}\)</span> and the fitted model <span class="math inline">\(\hat\mu_{i \in \mathcal{D}^{\text{train}}}\)</span>.</li>
<li>For a user-specified desired coverage ratio <span class="math inline">\((1-\alpha)\)</span> compute the corresponding quantile, <span class="math inline">\(\hat{q}\)</span>, of the empirical distribution of nonconformity scores, <span class="math inline">\(\mathcal{S}\)</span>.</li>
<li>For the given quantile and test sample <span class="math inline">\(X_{\text{test}}\)</span>, form the corresponding conformal prediction set:</li>
</ol>
<p><span id="eq-set"><span class="math display">\[
C(X_{\text{test}})=\{y:s(X_{\text{test}},y) \le \hat{q}\}
\tag{1}\]</span></span></p>
<p>This is the default procedure used for classification and regression in <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a>.</p>
<p>You may want to take a look at the source code for the classification case <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L1">here</a>. As a <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L3">first</a> important step, we begin by defining a concrete type <code>SimpleInductiveClassifier</code> that wraps a supervised model from <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> and reserves additional fields for a few hyperparameters. As a <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L26">second</a> step, we define the training procedure, which includes the data-splitting and calibration step. Finally, as a <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L56">third</a> step we implement the procedure in <a href="#eq-set" class="quarto-xref">Equation&nbsp;1</a> to compute the conformal prediction set.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Development Status
</div>
</div>
<div class="callout-body-container callout-body">
<p>The permalinks above take you to the version of the package that was up-to-date at the time of writing. Since the package is in its early stages of development, the code base and API can be expected to change.</p>
</div>
</div>
<p>Now let’s take this to our 🌙 data. To illustrate the package functionality we will demonstrate the envisioned workflow. We first define our atomic machine learning model following standard <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> conventions. Using <a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a> we then wrap our atomic model in a conformal model using the standard API call <code>conformal_model(model::Supervised; kwargs...)</code>. To train and predict from our conformal model we can then rely on the conventional <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> procedure again. In particular, we wrap our conformal model in data (turning it into a machine) and then fit it on the training set. Finally, we use our machine to predict the label for a new test sample <code>Xtest</code>:</p>
<div id="5376ca33" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Model:</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>KNNClassifier <span class="op">=</span> <span class="pp">@load</span> KNNClassifier pkg<span class="op">=</span>NearestNeighborModels</span>
<span id="cb2-3"><a href="#cb2-3"></a>model <span class="op">=</span> <span class="fu">KNNClassifier</span>(;K<span class="op">=</span><span class="fl">50</span>) </span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># Training:</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="im">using</span> <span class="bu">ConformalPrediction</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>conf_model <span class="op">=</span> <span class="fu">conformal_model</span>(model; coverage<span class="op">=</span><span class="fl">.9</span>)</span>
<span id="cb2-8"><a href="#cb2-8"></a>mach <span class="op">=</span> <span class="fu">machine</span>(conf_model, X, y)</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="fu">fit!</span>(mach, rows<span class="op">=</span>train)</span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co"># Conformal Prediction:</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>Xtest <span class="op">=</span> <span class="fu">selectrows</span>(X, <span class="fu">first</span>(test))</span>
<span id="cb2-13"><a href="#cb2-13"></a>ytest <span class="op">=</span> y[<span class="fu">first</span>(test)]</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="fu">predict</span>(mach, Xtest)[<span class="fl">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>import NearestNeighborModels ✔</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>UnivariateFinite{Multiclass{2}}(0=&gt;0.94)</code></pre>
</div>
</div>
<p>The final predictions are set-valued. While the softmax output remains unchanged for the <code>SimpleInductiveClassifier</code>, the size of the prediction set depends on the chosen coverage rate, <span class="math inline">\((1-\alpha)\)</span>.</p>
<div id="9409066c" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="5">
<p>When specifying a coverage rate very close to one, the prediction set will typically include many (in some cases all) of the possible labels. Below, for example, both classes are included in the prediction set when setting the coverage rate equal to <span class="math inline">\((1-\alpha)\)</span>=1.0. This is intuitive, since high coverage quite literally requires that the true label is covered by the prediction set with high probability.</p>
</div>
</div>
<div id="6ed040a4" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1"></a>conf_model <span class="op">=</span> <span class="fu">conformal_model</span>(model; coverage<span class="op">=</span>coverage)</span>
<span id="cb5-2"><a href="#cb5-2"></a>mach <span class="op">=</span> <span class="fu">machine</span>(conf_model, X, y)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="fu">fit!</span>(mach, rows<span class="op">=</span>train)</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"># Conformal Prediction:</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>Xtest <span class="op">=</span> (x1<span class="op">=</span>[<span class="fl">1</span>],x2<span class="op">=</span>[<span class="fl">0</span>])</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="fu">predict</span>(mach, Xtest)[<span class="fl">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>UnivariateFinite{Multiclass{2}}(0=&gt;0.5, 1=&gt;0.5)</code></pre>
</div>
</div>
<div id="785d3829" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="7">
<p>Conversely, for low coverage rates, prediction sets can also be empty. For a choice of <span class="math inline">\((1-\alpha)\)</span>=0.1, for example, the prediction set for our test sample is empty. This is a bit difficult to think about intuitively and I have not yet come across a satisfactory, intuitive interpretation.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> When the prediction set is empty, the <code>predict</code> call currently returns <code>missing</code>:</p>
</div>
</div>
<div id="f0d679f6" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1"></a>conf_model <span class="op">=</span> <span class="fu">conformal_model</span>(model; coverage<span class="op">=</span>coverage)</span>
<span id="cb7-2"><a href="#cb7-2"></a>mach <span class="op">=</span> <span class="fu">machine</span>(conf_model, X, y)</span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="fu">fit!</span>(mach, rows<span class="op">=</span>train)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co"># Conformal Prediction:</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="fu">predict</span>(mach, Xtest)[<span class="fl">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>missing</code></pre>
</div>
</div>
<p><a href="#fig-anim" class="quarto-xref">Figure&nbsp;1</a> should provide some more intuition as to what exactly is happening here. It illustrates the effect of the chosen coverage rate on the predicted softmax output and the set size in the two-dimensional feature space. Contours are overlayed with the moon data points (including test data). The two samples highlighted in red, <span class="math inline">\(X_1\)</span> and <span class="math inline">\(X_2\)</span>, have been manually added for illustration purposes. Let’s look at these one by one.</p>
<p>Firstly, note that <span class="math inline">\(X_1\)</span> (red cross) falls into a region of the domain that is characterized by high predictive uncertainty. It sits right at the bottom-right corner of our class-zero moon 🌜 (orange), a region that is almost entirely enveloped by our class-one moon 🌛 (green). For low coverage rates the prediction set for <span class="math inline">\(X_1\)</span> is empty: on the left-hand side this is indicated by the missing contour for the softmax probability; on the right-hand side we can observe that the corresponding set size is indeed zero. For high coverage rates the prediction set includes both <span class="math inline">\(y=0\)</span> and <span class="math inline">\(y=1\)</span>, indicative of the fact that the conformal classifier is uncertain about the true label.</p>
<p>With respect to <span class="math inline">\(X_2\)</span>, we observe that while also sitting on the fringe of our class-zero moon, this sample populates a region that is not fully enveloped by data points from the opposite class. In this region, the underlying atomic classifier can be expected to be more certain about its predictions, but still not highly confident. How is this reflected by our corresponding conformal prediction sets?</p>
<div id="3e40652e" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1"></a>Xtest_2 <span class="op">=</span> (x1<span class="op">=</span>[<span class="op">-</span><span class="fl">0.5</span>],x2<span class="op">=</span>[<span class="fl">0.25</span>])</span>
<span id="cb9-2"><a href="#cb9-2"></a>cov_ <span class="op">=</span> <span class="fl">.9</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>conf_model <span class="op">=</span> <span class="fu">conformal_model</span>(model; coverage<span class="op">=</span>cov_)</span>
<span id="cb9-4"><a href="#cb9-4"></a>mach <span class="op">=</span> <span class="fu">machine</span>(conf_model, X, y)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="fu">fit!</span>(mach, rows<span class="op">=</span>train)</span>
<span id="cb9-6"><a href="#cb9-6"></a>p̂_2 <span class="op">=</span> <span class="fu">pdf</span>(<span class="fu">predict</span>(mach, Xtest_2)[<span class="fl">1</span>], <span class="fl">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b9090067" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="11">
<p>Well, for low coverage rates (roughly <span class="math inline">\(&lt;0.9\)</span>) the conformal prediction set does not include <span class="math inline">\(y=0\)</span>: the set size is zero (right panel). Only for higher coverage rates do we have <span class="math inline">\(C(X_2)=\{0\}\)</span>: the coverage rate is high enough to include <span class="math inline">\(y=0\)</span>, but the corresponding softmax probability is still fairly low. For example, for <span class="math inline">\((1-\alpha)=0.9\)</span> we have <span class="math inline">\(\hat{p}(y=0|X_2)=0.72.\)</span></p>
</div>
</div>
<p>These two examples illustrate an interesting point: for regions characterised by high predictive uncertainty, conformal prediction sets are typically empty (for low coverage) or large (for high coverage). While set-valued predictions may be something to get used to, this notion is overall intuitive.</p>
<div id="cell-fig-anim" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># Setup</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>coverages <span class="op">=</span> <span class="fu">range</span>(<span class="fl">0.75</span>,<span class="fl">1.0</span>,length<span class="op">=</span><span class="fl">5</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a>n <span class="op">=</span> <span class="fl">100</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>x1_range <span class="op">=</span> <span class="fu">range</span>(<span class="fu">extrema</span>(X.x1)<span class="op">...</span>,length<span class="op">=</span>n)</span>
<span id="cb10-5"><a href="#cb10-5"></a>x2_range <span class="op">=</span> <span class="fu">range</span>(<span class="fu">extrema</span>(X.x2)<span class="op">...</span>,length<span class="op">=</span>n)</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a>anim <span class="op">=</span> <span class="pp">@animate</span> <span class="cf">for</span> coverage <span class="kw">in</span> coverages</span>
<span id="cb10-8"><a href="#cb10-8"></a>    conf_model <span class="op">=</span> <span class="fu">conformal_model</span>(model; coverage<span class="op">=</span>coverage)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    mach <span class="op">=</span> <span class="fu">machine</span>(conf_model, X, y)</span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="fu">fit!</span>(mach, rows<span class="op">=</span>train)</span>
<span id="cb10-11"><a href="#cb10-11"></a>    p1 <span class="op">=</span> <span class="fu">contourf_cp</span>(mach, x1_range, x2_range; <span class="kw">type</span><span class="op">=:</span>proba, title<span class="op">=</span><span class="st">"Softmax"</span>, axis<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="fu">scatter!</span>(p1, X.x1, X.x2, group<span class="op">=</span>y, ms<span class="op">=</span><span class="fl">2</span>, msw<span class="op">=</span><span class="fl">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)</span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="fu">scatter!</span>(p1, Xtest.x1, Xtest.x2, ms<span class="op">=</span><span class="fl">6</span>, c<span class="op">=:</span>red, label<span class="op">=</span><span class="st">"X₁"</span>, shape<span class="op">=:</span>cross, msw<span class="op">=</span><span class="fl">6</span>)</span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="fu">scatter!</span>(p1, Xtest_2.x1, Xtest_2.x2, ms<span class="op">=</span><span class="fl">6</span>, c<span class="op">=:</span>red, label<span class="op">=</span><span class="st">"X₂"</span>, shape<span class="op">=:</span>diamond, msw<span class="op">=</span><span class="fl">6</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>    p2 <span class="op">=</span> <span class="fu">contourf_cp</span>(mach, x1_range, x2_range; <span class="kw">type</span><span class="op">=:</span>set_size, title<span class="op">=</span><span class="st">"Set size"</span>, axis<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="fu">scatter!</span>(p2, X.x1, X.x2, group<span class="op">=</span>y, ms<span class="op">=</span><span class="fl">2</span>, msw<span class="op">=</span><span class="fl">0</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="fu">scatter!</span>(p2, Xtest.x1, Xtest.x2, ms<span class="op">=</span><span class="fl">6</span>, c<span class="op">=:</span>red, label<span class="op">=</span><span class="st">"X₁"</span>, shape<span class="op">=:</span>cross, msw<span class="op">=</span><span class="fl">6</span>)</span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="fu">scatter!</span>(p2, Xtest_2.x1, Xtest_2.x2, ms<span class="op">=</span><span class="fl">6</span>, c<span class="op">=:</span>red, label<span class="op">=</span><span class="st">"X₂"</span>, shape<span class="op">=:</span>diamond, msw<span class="op">=</span><span class="fl">6</span>)</span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="fu">plot</span>(p1, p2, plot_title<span class="op">=</span><span class="st">"(1-α)=</span><span class="sc">$</span>(<span class="fu">round</span>(coverage,digits<span class="op">=</span><span class="fl">2</span>))<span class="st">"</span>, size<span class="op">=</span>(<span class="fl">800</span>,<span class="fl">300</span>))</span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="cf">end</span></span>
<span id="cb10-21"><a href="#cb10-21"></a></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="fu">gif</span>(anim, fps<span class="op">=</span><span class="fl">0.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-anim" class="cell-output cell-output-display quarto-figure quarto-figure-center quarto-float anchored" data-execution_count="12">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-anim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="data:image/gif;base64,R0lGODlhAAMgAfcDAAAAAAAAawAAiwD/AAEBAQIaJwMjMwMjMwQIhQgtVQkMkAklMwkoOAoKCxAPDhIsPhMqNxUuQRctYRkZGRoygR4yNB45Rx8fHyAuNiIiIicTficvRCdPTCg3NitASSwsLC0vWi1CNy8yNzBQOjF9SzMwmDMzMzM9OzQ0NDVHWTZKeDg3Ojo6pUA0oEFTkEGTXkIAAENFSUOZY0SWaEVDqEWTbkY6OUZIOEakUEeLe0hER0uDi0xUWkxbc007eU2DR058mk9cNFFmtFJSUlJ0qFRutFZsuVZtuFdtt1k7NlpZWVprtVs9mVuxblxBOl09Y110vF5eXl+tTWFDO2M+OmNjY2RDO2WARGZpaGZsq2dqOmhYOGiCwWi6UWlfpWptqGq5emtIX2u7UWxGjG0ABm5spW5wcW9HPG9PO3C0THGrSXN5pXOHxXRJknRsn3SRvXZ2dnd/hXeVynifSHrAiXuMyH5OTH7FUn+YpoBpOYBqloJMa4KAPoNOPoO6roWAiIZ3e4aosoePj4iIiIir0YpSjI5ti46TiY7NU49riY+QxpCbPZJTP5KXk5PQVJVWXpVXP5mZlpq6SptnP5tshZudnZyAOp2ipJ25153P0Z3Rp57SVJ9XQKJahaRZQaRseKVSWKWtr6bQ4qdaSKenp6naVqtcQqucQKvW5avY463Y5q5dQrBxfrDZ5rJubrO8SLSzsrbIzrdQRbeuvblhRbmCOrptaLpuZ7xier2/wL3fw79uYsBrScLh7MPCw8PlV8VvYMWnp8bGxsnHScqgjMrLy86aPM9rUM+CjtB/Q9GtQNHR0dKQetPd1tSHbtSKcNVra9ja2NjyWdnMSNtwT9vb29vp8dzc3N3d3eLi4+OEa+TYS+T5W+jaTOj4Zuj7W+mSdutva+t4V+uER+uhPOutpeyhh+25P+3Pxu6Ydu7XSe7p5+7v7PDy8vLArvTeS/T9t/Y9Ove8P/iMRfjc0vj6+vnSbvqyYvrBQPsAAPulO/vbkPwQEPyrlf39/P///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFyAADACwAAAAAAAMgAYcAAAAAAGsAAIsA/wABAQECGicDIzMECIUILVUJDJAJJTMJKDgKCgsQDw4SLD4TKjcVLkEXLWEZGRkaMoEeMjQeOUcfHx8gLjYiIiInE34nL0QnT0woNzYrQEksLCwtL1otQjcvMjcwUDoxfUszMJgzMzMzPTs0NDQ1R1k2Sng4Nzo6OqVANKBBU5BBk15CAABDRUlDmWNElmhFQ6hFk25GOjlGSDhGpFBHi3tIREdLg4tMVFpMW3NNO3lNg0dOfJpPXDRRZrRSUlJSdKhUbrRWbLlWbbhXbbdZOzZaWVlaa7VbPZlbsW5cQTpdPWNddLxeXl5frU1hQztjPjpjY2NkQztlgERmaWhmbKtnajpoWDhogsFoulFpX6VqbahquXprSF9ru1FsRoxtAAZubKVucHFvRzxvTztwtExxq0lzeaVzh8V0SZJ0bJ90kb12dnZ3f4V3lcp4n0h6wIl7jMh+Tkx+xVJ/mKaAaTmAapaCTGuCgD6DTj6Duq6FgIiGd3uGqLKHj4+IiIiIq9GKUoyObYuOk4mOzVOPa4mPkMaQmz2SUz+Sl5OT0FSVVl6VVz+ZmZaaukqbZz+bbIWbnZ2cgDqdoqSdudedz9Gd0aee0lSfV0CiWoWkWUGkbHilUlilra+m0OKnWkinp6ep2larXEKrnECr1uWr2OOt2OauXUKwcX6w2eaybm6zvEi0s7K2yM63UEW3rr25YUW5gjq6bWi6bme8Ynq9v8C938O/bmLAa0nC4ezDwsPD5VfFb2DFp6fGxsbJx0nKoIzKy8vOmjzPa1DPgo7Qf0PRrUDR0dHSkHrT3dbUh27UinDVa2vY2tjY8lnZzEjbcE/b29vb6fHc3Nzd3d3i4uPjhGvk2Evk+Vvo2kzo+Gbo+1vpknbrb2vreFfrhEfroTzrraXsoYftuT/tz8bumHbu10nu6efu7+zw8vLywK703kv0/bf2PTr3vD/4jEX43NL4+vr50m76smL6wUD7AAD7pTv725D8EBD8q5X9/fz///////8I/wD9CRxIsKDBgwgTKlzIsKHDhxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJs6bNmzhz6tzJk+W6UcpSvnrVs6jRo0iTKl3KtKnSKwB6EeynjNIVIUmoeSwDAFc/jcqSSGiA4c06hsqwClHLFtdAaGyTrE0Cyandu3jz6t3LtyY0AjkKMgBAmDAxj+oYeKCX8dXgBh4GW8C28BUBAAQuZ8ZMwKvAYIQ3b77St7Tp06hTq84rpHNBABiSCDL8EeoojIkJvGGsTgWBGgvZERtOnNgVAhK+foZdfDjl1dCjS59OvTpGbAySFzzrrx9tj6BVYP98A0CFcn/YXUf0oJsgaA/W48ufT7/+aT/tEXoHcBgiKCEnCMEIY9a8QRRBGBAAzXkTYQAAJQUlAQBpEBGDmTXuAQCffRx26OGHILakAgAHHrRffw3R0xoBDFwW2BsElCgQFQAIYhE2l2lFECQaRgQVDAy+5w89DIZo5JFIJqmkQOxkxp2J3zXEFQZBUcMeKBg0wNiOgLnHyJdghglmibgQxk5BrwDAQJEK0dMAAJYUBFp2hGFQxnNL5qnnnnyaFgxyCp3oUGIkKteLhgRAYdCfEhAEY2GQRhqYQKCwuKiZD1lCgJZBEkbWYAA0IFWfpJZq6qk4VbqhflEuNAoAEmz/2Z0EhMkoEDSYndeLIYHw6muvwBryinKvNloQrgCo81ANBFBIkDWQcNcPLgk28CSq2Gar7bYcUVJeoK1+1su4437lBwCTDpRDqGyqQ5iyDzE4yqYGWQjAmQ1dcxmKCqnTAAE2civwwAQXXJCmJ4DLn0G0QrpOP+Qp6igAVByEDaYUlQmArAJZRgCbCMG4KkPHpWvwySinrKdlGCjMr0BvXCGzzGfCKERB5BlykDJqEiSIBEAHLXTQSQxEDWF4CqRpyw31YwEAOjskCAHiqWz11Vjbh+uaCQnaEI9VD/R0xQZZNvKjkaadbj//DksQV0mAXLaa8DZEnslZ5613SPQo//PKKNfufRKtQbG6cEPEsPikxiMPBEezF0EBwM0D0UPrbQ0JMflD7Dz9hn2vuCX46CuNksNYGKgABzFyHwSNg4T1oo41HJMekoQQGv6yQuxR8VU/I9Jqqz85EIB5Rcpk5rY/x1nAsQUSxFmQOsqHXLhA2KzLwDUysSOICg1IgIEQgiS90DrX4EuRYra3X5LkVAsBgwQEUO5Q8YwMx47kC7ofUppCKJLm0gYACzCkF4M5wRtOMDlIsKgEdWMHAxqgvoqcCzBXKIGaRDeQweSOIIEggAXkRisLqEAI7MnM8V6yDg+EKgcAalFdHPK44UGkAWHznw43kiYL6Kg7uPhgQ/8sYMCB8K91O6yI0whQN4FAoQFQjCIUS4BEgfSCgYQ5wVkg4YEG1M1bZchIPyjxtCwGwyAYkMAKBQI+PyTkCgkqDANysLuWHEcI6qPHKDjIkD/EKImAhAlUGNEQv+HiWuxYBwE8sI51JFJCwWgkvhLZnWC8AhoEIcYrrkcQdfQCFMGoYD8aWRB6OPJqIQwYR9YBDfMVxDc/xEg/rEGMJm6EHdAgBjRqBxMHYXIgcvPbKxBJHsCRMiHXwMUrIkmQU3ankdCEJsfo0YvQ8TKQ7oPKDBMSDBeGpgxb0txlCAO+SHngK1lSRhwJ4DtoeHNyslKGBjfTAFX6Q3NC1BwhrUb/jzRWsCSWCeOpnubKglCLMwQAp0DeSRiuGSR7kCKAH5TDPn+AhoAlMsS/PCVEbLqPEQTAQB0FogwGMAAOlvRN0fzRi3lZYBSgUKZvDDGKURwIA9mhwt9c6AcJQOEVoNCgKl+hAkgskxIJkp4/1CEBBhTOEPXL2igasM+T5MACtuyT5oRQUIHgYlOGqOa6KIQLzb0BpmscCAwA8IZeaPINcFAOAUogkJ+gdRSW+Fd/HucBSwTDEglKq0dHxw5vWoAu5tOncujxtDMKZK6/8wf/CuIggfoDWc7CEV0FUiRsNGCzVlykcBhggcANlnTEaNFcrzCKCjKWAb9kIwF0VMM2/zEAOAipqEE0F7C/LGYg/hrhad1HDz/EkTBcZRJyOAbVzwlEt5IFQP8G4qCk0Sq2/sjSQUy5Dt9w7FxJwKljh+s+bFChYWp6g3LKJLGBvIoRX/GjDYFJ2q7O9SBcIZs/HtdRGnGSvKS7xiio0CIMMCZ5uB3IodK1SIIcEUEMKAh7GORd984vNJlJWj/WBYBAAHiH/SAGJIrHToFAVQVUkFmKNSdQOJBoIWVgUQ4MgV1/QNfEv5HVVlN8hRQzcL4f3ts16HcbC9nvVgAA0mNBG93pCkS7BIkMhQmwJUYU8A2MqOkJCGA+rigoyICsFAHOci4LlODMaC5BwGAE5IFQov8GoFLBdO9LELNdi1keSDOa+Qhm0nElrrjKoT/KZD/oPpi6DZAwAV5J5VlZ6zxbTlqaElQCIvVZhy48o5XjmpDaNoQdr2gN02w8MmJAkXsE0dyoLg1IKki0H2xjwLVg5MbHjsy/lE10lCNMkAorUsl1HQyePNsAbMDIWay2XWP9kbgEH2Q2y3OIb55DZ/RYgAHjHchsJprs0TGCEhxTxptGdRzLepbLA6m2P861RigPRMq9brQ/wvckGgHgOcAjACi64xvBdttgZeAzj7Qk223eijuasqdB2MHJfrAHXhUtrPEOkhgG8Ksf2f73yY4jASG8oQwkbu86EpSDQLyBVlH/e+7I/jRHIQjU3QtddLy3FGMPCMIPKpCABp8DI3OPBUMaT9nTMECFj8/zeNd4Wg3eIIgyjKh/6anBDlZakKOpoAyM8MOW20tnqFqAxzwunGPq5wc/UCGNQU8ZNLT+JjWpgBIMUgcVNuqBNZ6A6l5NggoCJBD5MUjvBaFCpQVCjze8CTDMeAME/aGMAFm6YyVAdtoJhosyRMZTQli1QNRRBvqxSAWCUB8xqACDEgi6rldIYUgHNBC++8MSekbzeNPS9gbkQKmTR1kikbiOx0ukigphxzW7c2l2tPSa7KAEjVOmHGcmhB3/nEpDHqaR3gM/a9CABCMyPpBXCELzxBDE/yiun/vyI4QeDGCgafsRID80YKTm/zc0LHCFP0hAEEW6AugxMMNR3F8F7RV/Atg09JAsZXNO/mAIRzaAGkcPW4ILugZcsmZRzuMPHkAUblJjDLiBpQQApvVxJBWBHJh2rzBqlBI2DQAN1GNpOdBRIziCBZhVUFBrK/iCQVdYHTVi1IUL4mZEtWYR61AG5GeDSrIO73CERoiER/gOSciES5iEpRd7VTUkHmgQVMBpOHI7RMghsHAJlyALXgiGXxiGZDiGX5gIIRB7JcBH9JADQlgQlJAuEkAM1OBQsoERVrKF2NIP7+AN3eANgPiHgQiIfkiIgugN29AA1nANjNiIrv9lgAXhBxLTC0X0EQ0whHp4GiuQAALAiZ0oAJ8Yip7oiQIQACFADY3YiLLShlfAJtTCJAyADfSAbv6gAv4GEXmYiabCh4TYi774i4SYiAxRgE9iCQsCDcUmWc5liZioi32xAqAYjdI4jdRYiiHQJkIABQyCC15hOW7BCLglBBMlbtEnEbnojH3SD/oAjOz4i8KoECUQRUxzApjzM6lTjhpxiehoHdBYjf44jaaoEKYmRWdyBerlD68gAR5AJQJhJWl0i7jYOPuYJ++wDe14kYgoghNBD1nVEfo4kdPRj/84kgFpERxZJOowfOYokXtBD/MAkh3BixjZju+oEx95F/3/MA/NqIsiOZL+WJI5cY4EQQ/QV5RGeZRImZRKuZRM2ZRLqQ7l8A3l4EhOWZVWeZVYmZVaKXx8oo4zSZMaeRM3ORDVUJZmeZZomZZquZZs2ZZuaZblsAzfgA1vWZd2eZd4mZdvKXxE0pf94JeA+ZeCGZiEOZiGWZiIeZiKmZgq6RA96ZPUCJQ4IZQDwQMKsACYmZmauZmc2Zme+ZmgGZqdGQKlUJoXIJqomZqquZqs2ZqYiQJ9UpFfCYw1mRNj6Q+8gAqpsJu82Zu++ZvAGZzCOZzEmQqn4AzIiQunUJzM2ZzO+ZzQSZzLmQqsUJ3WeZ3YmZ3auZ3c2Z3e+Z3WmQq8/2ARjwmZ0iiZN0GZ3YECBtCe7vme8Bmf8jmf9Fmf9jmfCrAIpcAH99mf/vmfABqgAuqeFdCVfTib7hiWNnGbrJAKRlAEEBqhEjqhFFqhFnqhGJqhRTAJutAKSvCgGhqiIjqiJFqiFxqdKJqiKgqcrDCeFVGe5gmK6GkT6ukP7DmgOJqj//kAOtqjPvqj/1mge+KVCOqLtYkTDMoKJrqkTIqhRnAEWHAETTqlVFqlJ7qiWJqlz+miFAGjMTqjNVGjNwqkZFqmZnqmaNqfQronslmkwaigNZGkVjqndFqndnqnE6qlerqnwcmlE+Gl5gmmNCGmaVqo81kDTXABhrqojP8Kn2uaJzLppoB4pGJZJNWJp5gaoV5QCG0gpZn6qXhqBHw6qqPqpxIBqJApqDNBqI1qpjVgBiHQnidQmovQqraapg5wBzs5H0QqqRnJE3IKqlV6BIUwCVhQBEZQC7qgC2QgrM5qpU8QCtNJqtS6oqYaEajqk6oqE6x6qz5KmqXQCe1ZA6W5Cd56rj/qAG12JG0qqZS6oJaqpM/apHlgCx1aBEdgr7rQBvParyb6BNNarQKLotcKEdlKkteoE92KrjgKrp2gAAagAGbAByrAsBYroAsQS3oSqe4KpzQRrP5aonmwrK0AoXnQCojgqSG7shdqBIPQoAMbs9BZsA9xsP//uK0xsbCLCrFA2gQUu6NVUAU8erFEuwC7Wh982A3doA9L27RM+7ROG7UeOxMgi6kfSqVHgAie0KwhmgeTQAYgyrLPagSXELAye7bDSbMOoQQr0LYz0LYr8LZuC7dyG7crQAJMlp4sOaaG+gD6WQUMWwWqUAqAS7QXuwCloo7usLiL6w2M67iN+7iMyw1TKxNVa6dG4Am24AlKMK9tsKy1ELZi66yDgLamS5xq2xA2+5MJG5R726gqMLil8KMKEAJD659mUJpmYLiHayr6wLjAG7zCO7mVGxOXW6dK8AvLyrVMqgRkoAQqi6Gfqwu1MLr9+rKnm72/mboMsbrViLMw/6GzaXoBnbCfP7oInbAJtxsCZlAD9PkAZmAGt2uoiDq/vGsAiFsq6zi8/Bu86VC8MHG8c2oEStAK1Au9THoEBuyhEKoEk1AInUuhRlAInsCvmZoHhXCs1ku2Zqu9p8u9C+G9kdm6k/m6jXoBJ8Cz83kBIaDC8/kApVkKsRqx5VsKitqfCsAHm+C+rjq4ZuDCvJu/pPK7/VvE7vC/DBEMb+AHrtQPloBljXkRAkynStAGGlyhVYzAFooFy/oLXgChHKoLiCC6W9wKrWDBVjqyuuAJ1guhpevBcAzCCiHCAEnCensQfHux5Gu+9mkGqrAIPKsANTzD90mu4RqxNVCxP//aBKWgCvx5v+4pxH1CxEbMv0isEL0gAYxQBgbGIFCQA6MgF0fLEFPsrEqgrAxsoUfgCWscwWE8CSGKCMvKxmSQB1fMpIVAsm1cBGULxx4sxwlBx+dpxzRqwoZryOJqnwrwAC6sAnyABP8JrvxZBaWZqD76AHzAB4R8vw4Am/pbyf17yQkhBB5Wi7hHPWeRgSBRysLqBcuqC7cswVdsBFgwCcbatctqrCTrBdFbokrgCVvbxnFwCh3syzILzAghzNEIvi8hvgz7AI9QClJAnxcAxAHqs4ocAjXAo3xQCrMwC6oAzZBMpgugUPoLueDsv5U7hwLxB8gGDQ7lAQbHEez/DKqrvMZbrMUSagQ8jaF54AmFgKxtkAdVrAu/MA1rTMa7XKKDQNAGrb0IfRAKLaPEHKbGzLsW7Z652wk3LKCzesjwGQKbANJ87J4PIAUiHQLZPLQKUNGLysw66gCAgCqUnNLAK84mQouMcGSWcxt/8oMeGa/Wq9MSWq+6kAcmqgTv/MUR+s+6YAzLerUQ2gaT8MVYANAarATxTKdQyqRP8NRxTJ4x+r1VPahXPdLxuQmlycMCCq7m+p7sqwLgWgMuzAfl674dXQpN0J76CciFWgOq0AnbHKAQoIF8Utd2vbjpEFIY0NzOXc429kuSWBC94AEWAANFtc6CvdQTOgnK/zsJSp2hSqCvV6wEhYAIXmDAbKypoHsEr2wEZKCsQW2nCry5EUyiW1DQoB2zUW0QU22NO+HQqN2eW93VAvqqHPCeChDDF/AABt6eub3bflwK7nsBMTzcZcoHgzvROAoBzEDXya3S0SRN73YgV8gmsGYBmkfT283dEGoEaozYJkrZnRqhubzGnS2hZPDOSiDLYjzBumyn7rysm62h+b3f2dvfBfHf2xpi2ncQ3icIUk4U6yDlUt5VESHgA24ADQ6fHLDWOArDpjmfai2/BvAATUDbZx7RgGwGncDhZcrIpXACOerhdI3SIY7Xz5YD9EANish4AUMNf/kGp7cRNT26WP8Qz4XQCvOdoT1t47NcoRPsCXlAwIVA1EYwvYhQr5zbz827wJ5u5PqN5NWq5ATB5KUtEMTgAVd1EKBg5ffnD35u5VgekXi85f+Z23DO5SnsnzXwzK1dvj8cArJrvz96AQ9O3B9+Ksid3HpuEPSQBOGTO7iQA19heA0gBB2Zjy3u4lv8zleMBTUu3pPgCVgQ3hZaCPaaB0egrIeN7on9vEt65KSOtqY+EKiexJVIcbEo6/ueEVqO6/CZu6Ug0gbAAbqb1WQq57Uq5q+N2nbO7CF+1wBcEKNMEYfO3Vhgr7UQwTuuC+Dt6PB+oawM8kVQ8mg8uvRe7wct2qNdx/quEH7/EECy3gBUUAbcRxEBL/DuqQBp/p7ArQoPn6YhUL67zeUbveUR77sTz7jPDq8FcanejqFkUAjMmwfK2wojT6+/YAv8qgR5wLzWu/IsP7D3LhD5vhDB8O+UdSDY4AejoFH7hoenzfP++QCqffR9m+xKv+ym8g71UA/dUA/6EPiEb/iHb/iFH/gV7xIZP/UvjgUGzO53ytOJDvlkX/albhFs+7aeb7efH/p2SwKbIkVQJCNrnxC4ECsGAQnOVhE7b/f0qfBhns0YLvvtufSkoo730Pu+nw6/H/zA3/vpEA+N3xKPD/mNHeomuuiNrvwRmvmaT6pn7w+oLkmO5HyfwfZG/7SMBBFUAF/3uB+fNdAJfODgj7AJiqzgOErNf0z7OFwFZsD3hqr7Q+z7+J//+u/7xn/xAOFP4ECCBQ0eROivQb+CrFgVgRhR4kSKFS1exJjRS6tabTZ2nKjESEaKWHTp+tWGpEUjhTypXBnz4pZTqWzexJlT506ePX3+BAqUV0KiA1cIQJpU6VKmAUIQ7XcNlIRr6vz1u2LVHzsG0Bj6I3bN3zUVb4qeFUjNw0EUBty+hRtX7ly6de3KfdCkRt1NpUrVqOKXz4MLb82U4qPg7lwkpYzt2qR4Md3GqvhMxowZAjO0nT1/Bh1adEJ990yfRp1adbyFo12Hbk3QoUzatf8rHslTSMkRiohOepr0GwsWiHls1SIuU4ktY9N0keFdm8zJWtFt06YZVPt27t23D3V9lOn48U6JsjtRQn2Zfv08WBP4KgnBURgYWHhD7+trtWwz/wdwMj782muuAUtRoQa/zOikFDMMeMCvUkJY7AI+FqHQrSZmUWXCAN9qDLEPR3TLAWheQzFFFVf0pzTVXnyRNRZnLCi2gWa7LkeZ8vhFF08qyuOkSYL0URdb8ijCkx4L0agVT8gYabolr5tOl+p0lGkN77bkssugwBtNPPLGRMo8Gmnsz6C2SGQTwEUIlOwtBS54oIY3+VBBhRA3ceuRUjp5wC0FzFhEBbmkEEz/Tj5UWeS/OAVtwoxA2/zPATjoOTNTTWd0EUZPTZNx0xVtFAhHLE+1qJDfRpJouDY80aWVPF4VsojgdGmDNyw88cSLiW79EaJCjiMjJpEkymMSmFDFKI6avIQ22i7BFE1MMskzU1QU0yxoTUq/neuCRR5pgg9J43rATz4ukJDCC/p6EEIVJjVAhQ47kauGDuN964FH71Khk04yvOsEgsEtEZT9tGW44aI6/RTGUB0ejVR/TGWW2UJq4fXJiYK0pQ1bTsrDCCJzNaKNYiECdiJVdWEyIiyUiEnVVpIrwghWW83jWGbjYEVaoYfWjtrQrL22qacoFo1bgrxFOOrARJwr/wQJ0y0lMrcIq8vqUhqNS4EaavgXwAP5rasJAqM2wAFLFmY6bochjni1BuSGDW6MM8ZSiZNwrQhWXSaB1RZfixgu1ZMQ2bkIJfLouXGZaiFZcomUoLwVmlE1IpRniQY99JuMBg3ppJXKFm+0nB4Iara/1beUKuhS4BHLIDwh0CY2MaNsuFQwo4nCXlf7r8XOZtsBUFRnXlu660Zt4uaLsnhvvnM0opWTcEb2pDaUaIO4SWqJuaLHh/QZIp11FHxli6rUhXssPRe9ftBJ/8z008tcenqiWBeI615HqQT5TlAXeFSE/HIwuSigL5ugl1yAx0DMhICCczlBJzbBgeQRw/9/H2TR86AHqruBMCHVe8j1UIWFPLivJNyDn/wiYjIhWc5xiNANbY4QvowoAVaTsKFttGQ/IgoNf57R3/5SZ0KCANAfAhxgFOviwD8Njy7s8osV48KuXewCCb/bxCK0KMURQQAWTETjaEQ4QumlUSAoVGEcSYKFzG2uIi9rhUUm8Ytp2GI3xbGFJ2RoG+ucCmhFRCS0jtiZJJ5uiWl0IhRHFKkLkvGKNeBg1SbFoN7RJQSqmIYxSqGYB/BhFxySwltCMEZL3qUC2HBjLD2zRui10Y1wPFUeXlJIOV7EC3k4nESOQAbiYIEjuarIJJpjDCb5MJRHGgkWoNPLlazhc4n/xGZ3FomWRibtkWiMJLjspQo+tZJNA+oEK+FCJ7eY4ZRaU9AupmE8AxymFJn8UA348MVvBQJTsgQoUWhZN1umEZc68sLf/kjNi6yPIp44ziBz5gWaYeEXxvgFkoLUHMBVaRLX2dUkJBqTOGTTpNp8TTev9U0mhvNbKvDLI8zpSSkYyi4NoudcqqCKdLqlBlMY3gVUQc4TvMV2peDnf6rAOwnhk01wCGhUETLQiBW0IPK5wokKwg5BJOEKytjUQXNkkpPYkaEyQ0QeeCkRyumiZMm0UjEL0bMiJPQXtVgZHmmzq1ZoTxeM01FJTzpYoaR0f+XpXyxd+i0kmMGpM30L/07VaZhSPCKCcenLX3wXArLBRW2P0GIIVGDArXVIQqWYLIACATepRpWqn7LqQF4hgVcIQgLsKIgQhNALRjQAlpkSa46ShcyzSkRJbr1IcG5WESOMDLkUIUPPouMFyqkVIjsk7h1P0iOYYUmwhAXvTrZ5FpWSiaUmXCxko6iAdt3FX3YJTE/R5aek9utR9nKQXajYCeDZlFJQbW2AW1QPAhfYwAdGsD1KmJAcQEIgDS6IBDzojxK8QlPBLS7f/Gpdi2BhrREJDnJCoj1EFPIISrAjInr0ViD9Bofps813wztjm4y3KEpYwQxyvGMd95jHPyZBCQKaXvUOUJ9N+BYC5/8Su3K+RQVF9axfGiU2/66zBkpGmD8F3Fp95MPLXwZzmMWcjwUjRAJg9QccrlAQKlwBG6+wgFbOhOEMM4sMwIExbYwwM8m1QaEyk25EBAfENgR6hoXO83VkTOPw2pgo5R3TeUFIZLY9AAkqCAGUaYcwC53rdV5b11t2mlMDXOAR/DXAgapsAA6M1ncXSO1dALzlqPJjzLceMwOgQoDfMkIIBYEGBjDQAEawdlR6S6EK21CIXy50IidGlReAM1KQjmy5iLO2RNpQi1Z4oQ09CtZ129AGh0ZkmM5eyaIZTVhHJwTS2EqsGykdtQHNYhb5ZUxlY50ZPjQolSQKgRQ0vc7/4vHzQLOjy5uQCpcTLGguxavkXbRM64B2GdcX9zIAGrBxjjdAEANpgFf84QcqEIQetPXHOjBgYeAiO45ksMVFrWRWiNDxSB+WieAKEcSMtAERUJoIFnzj1pT9eYbCynZEVPxc4xqJ2hRR97pP2m6EvBuxQ16LmsjoJ3szii5HrS+J7Inku1zADFL4lwJwSq+xKQZRVFPBJkBbl7gPBi4hAltcFlWKfwNo1hSXpcUxjmtdE6UEoxBIEj4+EGwQ4J9Q8MOFXa7sX/BxexTBI81rc6vyWSRZLK45dY4VXfH9xnGw6vzlPCGrpv9Vcm1FkkyiLvVsUv0gVlca1v0jRRUs/2IRm+hEgd5ygkXwod6z2ESsxRZxCEmhCQrAtF32LvytSWh4sZud18IeIHEFf4tSMANPmV+XiQPejf0Q/ODHXOaDQOIE6uiFb8FShqtIYLXKQHnLG5JsvilhEn0dHOswAkRwEpQwho7AucchN+bCgkLQjTzAAhvCAufinoQqqyOYQCvZocpZibXKA25zIaFrhYiijdmjvUSyPYPAvaWQtA+atwEqm71rghPILLKji/BDPk+ji7cTvlLCEELJLOrzqUWwQXu6DAjZtym6LLmwHVUYrRH5u4Toh3OYB2Mzv03pB1tTv1srPCl8AwyoMIbohfnwB2XIATBkhLCavOtxKP8Ys0BcEZxwo4jg+AVbmIREyxntMRyI8CFZ+T/ukh+XiBn4QbHEqQ0Ui4618qvvqQ0TxAlUeIVeOEGiScGCWEHUiTdIyrpuKTK4CD/jsSfm85NTUoW+MxC/QDgDKJ7McpAqIK23EBcMaRMVmIVdmIKb8otV+48oRIh2QIdvOAcrvMJMSb8tBDP2u6U1zDC/mTke6S6LgJVQIjqLcK7YMw6U+JshkZzGOYLxST3a8AI+moQPMwLYi7Fr4olhaIZmgAV0nEQuqUSCuMSkaEH/eUFzsjT/OgFYOzvfqYFN4BBV6Cy8OIEa0CArUpCvialOXITmmAXS6j1XJBEHuANhFAj/cviGb2gHixxGTjHGXIsqOmMoL2A2iCADMvCCSSiEtdo2jGK6y2mDSQikP6oS5/KEI+A5vpmEaQglPNSlcbSNJ3BHnXAGZ2iGVwiad1QkwzosFsxEcNrEp+nEu1iEDhFCuMiLgWTCrFnCGkCCBagB4enEKgglVWglB+CBf0KIeSiHcliHjmwY9PtIMUNGg1LGOqOIDeuwuTKfOjKrZWOhQni6jDEZnjSGONKZJwiFn8CFZRgGVhhKpeSOeDSKpnRK3dM6KVKAKgg1zFC4q1wnM5BIdDGt8YOLEDg7c5oCPvAAWNTKqFkANINL/8nCuQyzLpQlkTyVV1nJldDL91FJ/8l5w2DCCP8TKWpyiZXBrutxxFRAhaBBBclcyvCwTEw8j1F4A7MwiF64gja7gq+ABiiAMBW5x8mYFAXgg0cQwoTMuwoJnldclF1YhCXst8TAjAvYBWMQyAB5r/+wkwcJgQY5QoRZAAiQzdn0n2Kcy7pEI90szj9ChFooMYn4zYwgA5W8iCOohYsCSnODFTlsqFaYhl/whJx8tgjckVYAoluJPVQZhMiUzvthyuoUAElTBiGAAgs4CEpQAVAYBcTzh5MThGDwAAdLkfK8i/Cbz4RsMp+SsrnozwAxpWmYhVtsIK6ZDDNwSNC0CymwN1O8C/ZaoITEl0PBkw/pgHXgSP8EpRgF/UjcjCUH7TDKEcy/Ic5FnIg946VyY65a4MmUoAglMESMIAM+moYSNZZWMIb4WQlmhMPFaRz/exITlYgtiFFsokyBmEf+OYtg0FGDoAQoKIhRUIH4iErXQNIpMi1MS5S4QIIzWKUmIJjGGJj/OAHhYRdUmgsO6ARVSMUuVQX5DJBNcMjWrJoxyiw6WYRO2L6G+5NXpIvyY9PmkUvb/DIGZSI5bbGZo5xacLaURIQGRCYjgBXNiQkyYDYywChA/RgOvAiTwCjitFBDzaNAZcSIaCtvs4Vuc5nfwLmKaM5LNaIZrc569NQdtQAYSIJgEIg3oD9/UAcCWNOzSNX/ulgUCDKAE0CCJRy1e5mURVEFG7QLwDDIyio10VxCAwgRmVoMBUCC18QMLZ0GVTDWuDiMTnCqC5jBcBkXC/KLJs0MXpxWvKlNa/UyOE3G/bMNLxiZcfwloJMZyuEulTCJHoFa4CQSb30VDpOIW+nQi0BXee0hPjKGmwyJzGmVQoAJ69iVWoAc05OJFxXYIspUf9jUGg2BddDbvX1LgjhYgyCGVyAGRmAAsLoC7aQHAJAzVD3VACIRBQiBlIULP1EFDkEtt+ADYzCGX6UL/MKpUQqB4kvZC/C3VkICPuDSzCq+gaOLqbkMwHisxViADqiGof0gfbCH3NXd3eXd3lWw/5C8y5iQJt7g0+I4Ced4LrJ1IYrQUJQAxDxQ0W28xhZVoZDyAsmpEhL9WiDpkVY4AgcczIgYhMWcWyKqWxxbgR1LXx1b3/RV3x0jAQLoOI7Dhf3424SgArNwWIGIWLVk3N2TovgilL6rAg4Z0LpgUkLZiwMRWbiYkymqAdN0Mj5o4N7rJLpQm1kwhlko05HtEIQblEXgUrlAS9yyXf/hB3lQ4RVm4RZ2YXHAVhPSVpCinNXzhM3ZULf6V0ddPd34m+WtOTxkIbGtCCyYhONUn0KQFZwMVO0JpYziOT/zEYiQtl4hiUEoX0Sq27s12E9NiMP1B0rIAYbABQwgz8Z9ov8B4qxJYae4wK/tayDOPJh+IzV+W6DJULs7fosgtIsLmIVQwhexeb7OHUiYetbJQIGJPWGGSWEXdmRHhmHgVVq+QTQjUAIv4KXg2EOM0KXywZzLow09HEyvZZU3HKmdDCWN0g2WjJwkqaGMgNEsHljqpFG8hQpcMAQJwAUP6occgKVRIAZsGIUG6IWtaIBRwIYaWLxtQWNJYhPSVQWWrQtYe1y9GBE+7uMTyGMPeQuFYz61s7e9CBG0qQsOWMjJ2AFFXmRRaeRHducVjmEQmuGYkGIQlQgjIKbrIEkgzognqDxdUIMnuGdzC5+h+6iaGxlvZYlCuKhWoKEpzoih+0b/iohlWY6WLa5lW04IdsgBGMiBHDCLXoYlQ1ABD8iB+hWIYIABD3gDdf6fZn4dZx2lqbwLB3CAJhCFR6gACHCAt1gABVgAt8CvKkBNIdRZ/wpLVgqBKigBDWnVxbjVwqCyunAAHXDpdSbGd9bqSA6oeV6JYYkVvMQII7iEVAAGxwyaOBBoZ7kElvGeF7OOZVsZdF0WPpwrkXgZsy1OyBEJyPmwQ7Lo+sHoWq7H9mCeigUQ9NyEBg5NtMsnMxhhu3CAMvBff7iDQJldZUCBni6e9uyaJ7WLUuIDCbbZDtHFtqFsrKbWdtbqR0Zau5xkZmlb6tU2TwC9mNCluiaJzkFH/4cYhPFNhVO4hCfwq4m+nLaSoejwoZfY7fUhEiCaiEFIysAWncGm0XqcHsRmm88MkBogxSSMC+Wp7KuQhQW4Av3ohzJwgA5okMh2snuZC5eFWTfxC8ZeAFAYb9WOG9Zu7RbmaoDy6lNZjpPg54vIg3VFt4tQzMg8hWs6hVdYRxQrzh+mCMDMkaFDVPGtaOr2Eusu2KdsKZhWrwcI3bUBkFIoS/B2iwJVhvwWCHb4ivaohmvABjjo6ZY1A9R1C7Nz7KmZwRqQXIB5BLuLCwjQ7wTtb3e2GINghBoQAoYtiCQQAil/csmLbYYCHwqPiSPQhT9N8IrIju5o8LbOCOjduf8iuFAmscBWKLTwbZW+mibxnW4Ol1Favm4QRy8RJyMspSLecezfmW+4AEhbbNkSQYHa/Yz9AAUIiIsQEEuL9Ysv+sS9O+BvqQB1aMvFPXKHycIkh+Qlpw8MIIZh7tuBGAUfZQRes3LZ4L/rOTfH6VbbbhxEw7kNZSaMgDZr6hLh3hkL71PvkWLucmhmke5hWAakpPOh8XDLxO7m0e4RabiQNQCvKQV6mROxcbiuMQM4Xic/aYIFSO3XuIN1+tk4EZuBPJAvshA+eDtpBhcI8MVvIIdNlxv+9nQVfm2CUAEgFYJAQAhByAE1vHK+OYJW+AXNIcTocBW4rYiYNG6I2Db/W6CEDf+JU4iIKqlXiIfAnGmrXPm/W9GFf6WNQcCFonQGyEx2aVn2pmz2w9bzu+AsaNUpzX1IBbgTOXmTRXi7Sg+bfbwLJgMEFQmEoHYLao+T4iE7s6sCot+a9KQ+mV+MCmiHb0CHdqD3/b53F47nkGMIkkMID1ieVb+RVi/ijZcJi+LJldSecBsWOzyJYb8Nj8CI4GiGYaB4n7B4iO+RWmAVjIf44DS38eFazYtbWCjKZUj5WQ6TjG551alYUOsXKQh0uKiBYjUABYggoRIMDmZdm/WLzj/NUlCFZVgRWKCXBTAD9YyTTyTnxWiCTphPNjHyeQjGq2cafch6FoZh/2u4ht73ff24ClX3B187iF6QABdXETn9ZIUuAp/T7ZAw1IPmnuMy+IxKLu8xcF04yjnnkkEQ6EE4axbLWvXZRp1hFSUYwYfPCOmGBWBAhedM/OlcfMLG80l7eQT+2bc4kAhOrQcACFW7NikwYPCgAQWLSm0qVaoTwogGF5ZqIjHiBRjE/HHs6PEjSJDEIBhwgGJdIAcIQ8wyxufiwQsXFHA42LBUDZg6I1boF/In0KBChxItavTo0X785DFt6vQpVHkAMFCtisFQxwbKOPqhEhJKGaRIG/j0yIpVkbRq1xbxoustliJK3toi00YJ27RGPBn71eZI3jy/dA3WFTdv2v9WbwshVksGFqtTqSZTrmz58uSzly6dQpUq1JO0c6fZUmIEMRYySsgAzvNWV+PYagexyoz5Nu7cunfz7s2bl1iPKwQQL278OPIAIYIzZ07NQ0gUOw8+4NMp50SHi1o+minRjCpVVWAqUHDhhMNN02uU6j69JLPmIbGhgEOvXz9cCwwuCKHK4QMJmbFICAfVEF54fBTEh0MXTKdCEwFeBIF8FVp4IYZELRUVh0+J04BQKozikxBYfcROA9CUlaFHZH10lmxpTaLLJKdh8dYvv/SVh2lruTUYXmwdoQQWN8IVm2utHNZYHJL59mRll9jy1l9YeOLJYWTg+IsnR2AxZZf/sWFRSBuI0QYlmmmquaZlvKwo1nDIySmncizaydFz0b0HUwh8DLjLNLPMglNE4Il3UROqPBJgDWYUOF1B7zkgy5sX4sfRpRwRU0EnqixiEBLaHWTdLLv8F6ACKjgYkxlIrCTqRT3dOSuttYKkT4e5NsWAUJZ4oMwoDazjTy9JdESJCrb646JZaMlmxGlrFXLlL9NYawtjjtHVo1pYKMZYG5OUKdsRgMU2iJNs9raMLbbENclgNRZRiC3VHonFXeZ6MUm2ib1FRl5nqjswwQWncop8cc65MHF1KlthniBJt6dONQBqTKAvIXSBGWasGtEm4WEHkwqduLeTAhCoXEF8/w97hA0Mj2ySkwoOaWxAyQ+VcrNEjzikwkEq/AfRhC4bfScxCMFRqVH9kIMO1FFLPTXV6IAoFCMq5BCMpmFxJMgrTLPIbEcwxtgYFrVYO40xtbA1bR6BbduYEq1gK9saoVwSSroG43bKMLUgogQii6WVNmG6eBKtuf7q8lcRRkypS9xsCew35pnvJh8dSnj+Oeihi95CskcHF/FHE1MM0wNIzMK2GRJFepF1pXxM+39S7LRAB7D0Ast9pnN0jqmiGFRDhAiVZ95OPhNqkAIDjsyT2MJbTxQP0O9XgXz8hPM9+OGLP344V19vFNkcmX02YkYIZm0r7LcFZmPuv+U2k/99a34bLM008wsWlFAIHkXrc0vKi2Iop5Y8tEJelqvN/iKouUGs4RQIaw4d5CK/tSiBdOczCuo8orqLhAAJtzNIFTYRO4M8oBThwQAK+QC06ZzghN9xyPQi4gAeBO+D6kDHL9Szuo05qE8WWR2FPqhEoUjoHk40QAeqRxRykK+K5OPVEoeSPn+sjy1KyEMeGicXT9QijP76RdywMAksyQZfYmSLlhQXLbbEAYISvA0qnKHHLbwxRqk5Ahk8UYg+msmOdzwkm+IQGgtyboN58WAWgxLCjowwIg/oBENmZ4ALOMR2BymBGbBTs4dEBAkeG6JBVPAomKBAiqabxznggMr/4/0nhxSTVSRz6Q/oOfGJ3GuO96wozO9hUZch2WIX11I4XfSrCG0YjC30xa+0LNMTa8mDuBzpBQLmxQihQCRuYPEKWAzCkYizpiMvB851+mYN0WIkBh3JFkga8yOT5MgIH7DKEHQyQKtSQEM6ISGJ8JMhCBnlI2b5HhQYMxB7atQMDbAIY8yCZ0is5xKZYRAO9PKJUWwOFYcpzGJiNCuVWt9qzOWJKdUogG15S/wQU4i3TEJbuqgFIR1phC084ZvstMxZUjEInq4lNHopxCTIcJo8sO0X8lTnT6N6mVNsYY7wZE4G5akWepbUH/f0h+ou0JCbmeERFmHQIgpyASRI/8GWBqrC7YRmUIVKZAEQ6EAHlqZLUHSgAhVwABL4UIUmXOABNUACB1xYikh1AnazXMAOXNlVWvFgP3uIR0fvYYBfMieYIq0iSbuKTGed8zRkaIUnvDDTWsSFDIhAhFLzIsBCKMFccSyNVovKN6n+LRWXuNIkcBGKPAwQpqeZBMZgs8Et6I+3vAXNHItw1eBkNbdcLelXVSdXoiGkhQ55lBlwuDoFNMFRdNUhD9jhD8kqURDhmcYuvlEHVYgCPLuYxaP4ILKLtM6tO+zhZI0Ggf0kI7MeZS9QQvrZKwaYI6NNSxteEyS1JJAxR6jFkc52hGmNK7dFeEJznVuZUwCjGf/TyEYzhuEMWyimL6YRzC8m0Ufi1nYtFRQxjkGTl+mKpbpavS5Gs0udhqwwIvoliEEYVBGKXUAF5TkvQhwQCAQvkR3ZeN03vkGOX6jiDHy4r8Yu0AS3GkDJETWIA+5A5QZf6CAG7uVmu7dg0LL5wXLBsIzZMiNbeKEIRtJFn2OkhDYcMLdGCDGOKQMMZ5w4xf5bhS36goghEbfQznwLOtMC4kQ79xKN4TFSfCxPINdTyAdh3kUuUIMHRCoEi+BDCAYqEY4RFpOfgvJBHLCONX+wH/NoRznKcQ518KMZORCIKiwKE4q4CiELADCba8UOg1DgzXD+KHMUPOfwhbakdi7/gpf6KMAlFaKBXojuNcWlGNZ6WC2cxg0qgDGMZQwDFsMYBjDsxRhoNcY1uoippg35bnAOwqg7viBW201qY5p6Opf0VKEeYsMkOwQ8DtHkeXUd7fV2BD/4WUapNjFxiZzg1Rh/Nq83LhaDZMHacOZscDy7bfB1G6Pfjo3dalFjP+MZ3UW47Ws67OGB86YzzjAxG2WjBE+0osM7JTo7yxkbUB9F1I5cuC4bvpMTqGJQmsTk8ySi5CYsZDy4RvOwVA4SflyZzPz108ccAAeQ0IMf5ZhHytUOEgOYA7Mu1yy2g6PtmYej5vW8OWLmkqMO+xt/cKTLjDwx4aFDXTesWIYe/0EhP0R4Ig+n2QJmUDHvVwi88mvytGyobhSrbxDr/liHIJJgLJC8QggegMErOIKNHMCA9xuxkNZ18oDXzULW4RU5TDhWhYJgHMoLUK8S2dGOdtBDLP2Q/jzKoJI9hVcVK3QAKEJyjiyXI4u5mAMz8r5yv/89zsAkPLfrfFJnyUYXbOsw4moqU3EZYfJa3UIcxIFz2RvpQQksAAMunALqycYz6UI0CSBm4EIz6JFUoUIffAEmeMb+XILPrYXqFQXryY/rUUMZvIEFhIQfvMI1vAIDbAU1SAAxxCD0QQx0SEwMnVl3IcgqGYR3nN2e2FUZ6EAZVJ8SPc03tENz4AcgyP+aRDzACTxAFThEFSwAy4jNPGQZP6hfhmDDF3ShFhaFJezH313bFw7ezBmeMT1YHghSY7TCYJiRaFjaWnSgPDUJooET5jkDLqiJZIRCbHhBG8RRLaAL/+jRMkhVHzABE3zBHQ6M1E0dwlGXwpVOUATDCQYFDECCV11ihgiZXAnRRYBHWq1EgUTPKRnWCfigs6FANWTKEhkhEspHP4yETiyEyDVBE5gEO0gRLEGb8PTDOnThHLiinUyMKYyhL8kZ/BGT/L0IK/yZHK7WkgxaXCBVGxgBFuRBbLWbWtRRouXhHvLhKYDGE5TjE5xGhNEINtGGBkYg6Z1C6UkQK2CCIn7/QQQNQhDEyAcSRQiyj+txhCUGhTpohVcxAAaUgB98oUcIWUEllPCVEiYhQRPYTJk5RCqqogMMoTGtw/T5YnDQhwMsQEiGpAE8QNfNggo4gNwRYVAopKX0AzNkwq7VigEsADKSIUgtIzM22GjNhQPKoVxM3rqlo84lEFCmUzxGlb0BQ+acwhrM1C8sw1mwQjveRmQkZQShggX2ASZozinEAfvs41D049m0gAfEIFrGIEv6Q0D+BD3AwBv4xDr0wjoQgwf4wYWYWg3A1RCZwSx430SWghkowCPU0ib5CRMOUZphlMfVyjVUwAI01jQgITH6wzmUQywypksKRUneZDI2/0c7fEM5iOYxjGY5lCZpmiZqnuY3mM9kPVgbIILQKV2O/AK93JRPPo4RcFhOxYYRXILpaU4iTEM4ZAMsVGUqiN4yhGNwFswpGFzqRaJYDAIdVKd1Xid2ZqcXMEAJdKd3lgAueERbgkQ/CEESMM0onEBe1mDqnNcmGIMx1IACVMEp1UCnLF/t6I5iqiQE/J7eXQg77MAZNIOWMQ09fAM6fMM8/KeFVFa1eSYUleEzTCiFVqiFXugzuGZI9MMbYMAJ5B5IjIIKYEAOrOXYzJ9WeQHG/MIX8d9t5kE64hb7NMluNaffaKX/NMNxWsYrGKKNOid0QiLn+J/8GME/siUnev9EPySBEIgNsqynniiUAjiEKpwAxilZo/zHEf0gBMCCMijDDDKohfTDNQSbOmxogqJDmIopUkBAQXjmZ2Ybhs4phmooSEDCCagDLjQANnwEKGAALuipiWYI4rFP45WLWhgBhlHO/fTmWnDGj2pOvNHbZbCCBDrDMESqI8qPWAoFWcaI69EDJLxBA1BC7vWDB1iDP1yBBDACJEDCRoACJfQCJUgAJUCpDSoUEoTMIiSmkiEBFDZB88GELm4mmyKFOrSDOhhrc7ADM3gkrbgZnAKehNKptU6onX7ECYwCRySBIHyEB4SfshSqoMELM3nR5JABNm2jbHBGI2qq5uACMGj/JVZ6JSZkICKBJadKZ6hNYlDQAxVcwRVQASOsVxn0qSAEbMDmXjBQQQ5QAYgCH3uKkEKxRync2qx1zH6g0gIw6386zd3pHT3MwRcM48NQA7VNa5wK3rVea7a2iIr4Q1d4BD0QgCB4gAcULK2Qq2/OiC4ggs+1ARs6kgXBq7oAwzIw5ZPU6/4kIhP0AdMOjDttUKcGxafKxpEuUfBRzIFcrCo6W1fRAzPMwRzkwlqyAz+gA97Jxzykqd5xYReu6Z2UAcup7IGBVMtaKwOkJVqmXT8QQJ/6gyEIwcsQgBCwwwvigse2CIpu0F68BdByowcO3ClgwhwwwRz0DdJmqprA/4IeOQMs/OjlPi1y+g1VyVPVAsXVxkbWKtHW7kn08MHIrc4JbALy8UdXZQIT3EAXruX4iWZR+NqyfsQVAu9REFs5QOvD0EMmfEEmLC5IDJgBFJjdahbMiQU55C2dEgDvdW/vaSJHSMBWyKxXdETNhueqvsHONu4GqdEkHOXZzEieSdfAJeINKGJXTkYeTSBzwhsuhG5l5JEelS5uIG0BrhM9MgG+ao6OoS6/Vp2/Btjr0tUDqIqrCeZ71E6RLYDLYMNMFgU9dCHvmmxHFC85IFhoKihI/Jry/gQ/ZFlm/mI/tHCbGUT14qScam+dYkpjekQmckQOgG9HeACIQoFe3f8Jz/rmEUTXoAFiLdzNH77GYbwrm1Ru/vLG5cZADHxBKLRjHgJwbqiYHlrGAe4ob3iu/6BCZCBS0RYtA3tY6v7E6jZG637QBCsURagC26jC7BpEYNZASFIh9IJE835ByxRFLpRsLsjtPMwDDXdEOSRoDMtHORDnJB8rSATIA9zwy8lH9urwhb5sR7yCBLwCI0jAsOBCDvgEJYCnJTQANayvM0puEXgCYWAMafSmEmBYLQDnHY0uJlBxKiQwV1YlLPwvbwyD/yjtmsACcWZDF0etpi6gVsVxSMwxYtTx+dwxKk2pC7XENAgU9CRmKqkABKCvyxSy2QbF2D4vfrRwZQL/xRWWwy5eSDlkQzZc8qycXyYIz5ty8t3mMChXqCh3BCgIARVAw3opw7dyhCUIwRWM76wk8QZhmI7Aj17s3FpkIxhL0BcoYh/kxgX2gWdoJQETMGb06DJ0dJpI4DQ0gxrvDyaUrE/dkVPS4dlYM0hg8yNRYldxMypFoZ9sAh94AA82RLPxh8pAQAUErsv0QyLPATZIUT+QrCEvbjxbZjuk3VGEJjoMr62EMMkessvYMEBbrycPtIUWdC5RtPzQSwPZQtLZsuTpxSDozTpdIAbiRgIzQRcPTFBdxgHiAkpjBixg3jBIc5qgwkc/rWJX8dTmlk5/BE/Pk09j18RS0tcm/8RFhEp7HMQCoMD/As+a0UMupJ980MOgggTZGrLLtK3xCuSCdpwjD3JIWPUHZ8g6LPLe1eRZUyveqjWFsnUkubX8lEt0/RnAeJMwW4YFZmBh50aN3kYCM6Jn1MZj8wYq+A/o5sYxtyMq9K/mADMqNLduoAImQK3AhQJO5/QDr14ETxZQ+2AIYNL38RDTvIIFlIBC/0QmkGwudAQ7ZIJMLi47nLZtrzD5uRJst8ObJDhI7DZZY8jIlmwPvYJBgMBvo3VwC3eGNmOz0HJjbEEz2EIzxMFd38YdSMAFAEI8Oi3UTkYfzEGME0x6X7GkcjdLV0b/YCplmDcfhgJX/jXBXP/uF9T4ZFCzZL83CMb3T2c2Pm12f82OSbzBGwRhGYCC2IwCARAAAEhAfxNyF/YzRxTy87JIDyuLOtxzyAZFO2RDcRrFIydFhdRzhO8uE8wkCuxHJWw4cAu0cBN3Fhk3+wgQN9EoYR+MijMAABBAA7i4c48uSQ+zIjJBeRdMdA+M6E0gM6d0OLx0TOdGZ2Q3vGklkCcnkVfGF8QA5lbGILR3WDI5Pzo5Zkfpe0TPIridAVicfJbEEbsSKHQ5AAy7+M4H2dp5Ijsvm6YtOji4UMzDp2fDI/fDaJLD+dBDbkd1bnPEOuD5ri2AGPo5hwO6Wgv6Ehm3ESBCK8BhXvhsIWz/QYrvxh0w+rA7OqT/+EzvNaUvYk3/KC58bqhXKi4Qp47qBi4sQzOIt5pc+m6EAiZAEDEL3BfcQAxMeiooEi1PtkdU9lpo8/XMdyo5RCeogMlBz6iEhxn4FS6sdojS+7ATu0QDxQznAm+LaQrr84lEDXtdYYKyvK2wA8mSuT9YdS48ODsIIzswn7gHtOAdg9M/PdRHvdQfg7krkXG7xWI0EF5wiyf8gjPMqzDP+8vX+6PbkRtXxo1n+sB5rjMcYm4IsDNkeomlGAKDdG047RxchqRPhr5mvKwPBQXRwRoIPuEPvuEXfuFjgQlAOK6255405CbsgksogH6NxyUZQzPc/weVjYLLj8ELvDyYD0WaM2g/nMPasnD1qMM5cPW/Jmj5WQ8zdOEXdMR/Y27Re0RMlu1GLf3KigUw3ALwB7/wDz/x30LVf5Bxf8lNVYsxDJAtsJYS2EI4dDdv3IGwA4Dnk/0gBLxldIapG604QYa87vhkhH+9okKPfj04WaAiZi56V7rFH8xIT0ZVibh0/b2nEin7EIHHWw9AUPPgj2BBfygMJFS4kKGKJhc2TTOmqoYqixVyzMqGrt86ev0MhiwIigEAk2Pw4XthEoAEZSJhxpQ5k2ZNmyL7gSw479u3cjN11uxHb17Qm0eBrpvzJVPBfsy+RM1lcOkXCgYq3dO6lf9rV69f78XLYqACUpHkbqVVu5Zt21sNzMaVK7KBUX+sWBXRu5fvXjKIyPyaFm7YsmbNgOFythgVLFapIEeWnOpOyZMpVxIg0ADQ48mST30WPZp0adOnUaXCmwpWM2fLRq82jRcWrNO3caPCxIRJn1SodPPunTpVH95zTj3pu5x5c72nTs0lSMd5db0tVEjXjlQgTIQMwYOvMS1bOWjfnJW7dv4bv3Pf0M2jiUvz5ZQqWUpYt51//5jzyvlGPoLOQccnf+YpKi51yilnQP+QwmaOTNbxyCB6ooriizkI6ieqLypYAKwRR4wnmRNNGKusufoBxq0X3YILwhkNqiskvKz/4ysOYLJpZhhgnGkGl1AWG2aY11BhJbTPALEMAJTuWwmAzTBZErcrscxyNCCXSfIUXFzrEhdcsoRlmWVs01JNyDDZEBNMIoPuCyZiYAK54o4bJMc9+YJOO+r4XA47GgntTqTvwktogUUXdaCCa+Y5h51+2JnnI38q7accA9uh6QoCTHrhvvtYAuAVu2qiJ5M5mCF0xnZ6IkenfshxkJ9svmkHVZpg/YYcV23KJKqmRMImEyY2ZIcgYzNRQAESoeUqGRA4qFaRdMjSDi0YuU1LRmD9s9EgHJsbZJBLzr3kt1dewQsXWFJDBRdUDhPSysl4qK+BUVPSDFQ4sGxzjlCI/1vTYNIWcwaX0FAxEhjDhMTySGeAKfhg3ObgrQ+LT8EkY94IRqWPPjDRM9A9/ZQO0JP3GhTc/gwNCVHwFoDAEktAAQRnZf2ZNahz3ONnsAd3amfAV+p7clQpW8Imrlyi4vDl7QrMNSRNswmnvLjeQ6fTqWHqR9gvpsKJnqUyoafnfgJJKKtooTWFA0XcqbvubFl0sVtuvwVbOnELIrevJ0Kxckm8PJPslR+dIS/NyHBJLBVA/CUASsxABaCBSyw27eONLw59smFcezyVU5YZDLHOSwMSMdFxO8W43j47JZTjGAbulC1YzjHluVbu3WW/54rZoJkXWgCFdXK6iR0D4f/r6Ryjnofv0lEqh5Jpl+SCiqldibdJHaILClBr+c4x2qacEgQfbHpyyWUdp8P2SKcKEkoGbmgroSAZu+2Gt7lsa28v6lv4zAI4guBlDVtYQwMfGIrJ3OszqMhGkHrUDHhFBhYJS9Idkqa9zDEAEFmanW9gB7svme43QZqGM2oDDGDcRl7zSiFqQjGyN4nGdtCBDCqS0zvfRUdlQrxOdhAYF+MVZAco4AEPdvDEKMLhUgSZh9HsArRz+IMePUEHOXpCvnVAb1IEsQSoNDOG7b1kLsyQn6pYlcTtAKgdk5qHgdBxk5y4j3i5uMENiEUQN4IkKArZH4niAQQbSAOAAVz/kVxaVEAYHVCONlHgXSJDHNbBAhjtShwsfgSvxbhmMabrYClPd4dSqbE+JEwcDXPomz58AXQ3tOUrllExVixjMTa0ZeiAk4o5/LEPnsHExoBopVAox4jV+Z1cgsey4VXSJkskCA9ysUdtXg166jCIOsKhNeZdsSjnIB+B3GMU7PkrP2xkUU6gtiFqaocf6OAHT+BzlHa4Z54eYsINvqCTXKCtIOxIyAMO6RVz4CELWQBBFrjRSEdqS5IGnOdRLimb0pAuG75MReoIw5rEwOJdn1mcJ6EDQpOw05VqwgsqhIMJ1v1yTS/l5cN6OdPJAGMYC6Npaf4JUDbx5gs+hEwo/5o5xD81c5oXlYk1+1EGXvCxZz35hjp+Fo5piINnHZJJ80RyxlJxrz/eywRVnSqSLvZEHe0gh3yIsh+C0KMd7aiiOqBXRTlm4o9nJUg858AQICS0K9PKgiIUYQqJAlCAcYlkRdtCybTSxS680KlkeOmMdkWmGdOYxjB+c1nEySalpdJcCQ+GijkxAU4/hd0rFoOmHwGnpJDBRU8hFyRnXJamp/hCDG6Awt3wZkmnMFlSnUlE4DEViZONCVR7ZpN5pPOb3whHOdBaE7G2xJ1llZ9zj6Ip+IBVvOi4VK90RZDqcSS7hGIGM7DBjFkphQkPMEAWCPsVU1xAsYuVaGPjQv9AyKpFsheiQgMsQAmRXAEDDaYCuC7JjleOBpS6jMwwsuZTLZXWJCS82GOO2VrXho4VpwRtZDJrG3qhkjVhGnHtQixiVCylD8vUixGQa51nxiWaJ2tqSLBxhRM0NyRwkIAE/jASDDQgCV3VjjXD5la5ztVSdulIUVD1kfYSZBQNwEB3+wNW8N6EKHpdq4AIgt6gkJOaYwskDwywAIWYI79e2QMHhJEO//73kY7V24AJTJNA5IAd0GiANUIiBEpUyMk0ivArUcFTL/2mtpKR1wYnw0LSpLQBEkAt7Hj7YiyR1NKkJNMpd3uKx0RO0yOe3RwmeIpL5DhQOzZLjwP1Y4P/YMMQjLAATF6BAXWsAwOv8Mc6GkAMegjhDTAbSE0KhI4GlUMd9DAQdsMGk655c8zd1mNIYMUPnazDrXq9KDP+yYS0+UPOBlDAAhC6lXjU2RyKZOSe+UxRQAd6Jh4wtj+g4AejCGEUYHu0ZIARpmUMgxUTY6HuPnOkYVBwNEYV9cVFB6SJP2ZxC/NMqH+JiT8iK04N3AIzaa3UIhpR1yEJxq9FkgRBEEQQSfAHI3JAkGBIwNk2eY8XfYXXnky5JpuymreRjhQxr23pF80FE6LAhKkk5FldkYYc0iCMeYfFFfr7ijls8ACxZwHf/gWw0v+87wIXhAHQoDkUEt2ABnig/xcQtouEER6kcPTSMJqdsGg6eJhWY5zwNAWOklTz98L/xjg3iIFMU2FjvvyABjQYAo6L8IMfEAHztLY1UnDNp5Yb5OUwOcGp/PGKE/jjDWUgyDoIoLbtQBkndYWV1/rBD19t+fbn9PY65Jt04TsFvvOdwxzK5oARuGLrWomHK6KQhkjM2xyuSEMUXOGVae2h7GU/O1IEDGgGjGIUoCC/+a/RIQLQzxBCCAk1QEKJBjQaQgfPJE9TzKVJm4aXXVo8DXfo/wTQYHIomFKhTWgJMvoAB4agL3BABmRAB4zgCH4AAnEg5Z5DuaCJqTDA/Mrv/Iiu9ETC3wjiFQbiCpqNi/8AgNue7NnWpx/MSZu2jCDUoYyGbx2GZQanpumEb2xaxatmZQRGIA28zvmSAQ3SgPms7wbSQPq0ohgUyQYooL+6b8++T49k4Rgm4RgS4RhWgQu9EAy/sAvH8Bg4gQGSQAjScA0LjiAkgBgIAg6uQCYwABeAxf5+6IeAYYOSBOR+CF4QbwBH42OqRBBPR/EMMZPm5Ask6DN2QwZooC90AAJ/YAhoIAYwMRIx8POOIhEe6BNBMRRFcQ2GgMnUUA3TEA4LQgRDAgYsgctgoB/kcFkIoOfMQgeHTybi6QsMIhcoBBf7A1bKwdzA7a3S6vjIZlcMQAjRQBi0T+vuoQmbUA7/6Kx/TMEVhOHeqtAK+ywuZIETwDEcxXEcyZETLikkcoARCCIHFAwm2CHZ7vDuFM8PN03VElE0VquYGI9k6DHjmqFLAhE0eGrwXmy4WKuCHlET+WIILq8CM/EHMLAIOPEmQi9HgmD0VhHmQuIN5tAfULAfTJDLiEw6aI/M6ooYczFVji+QvGcOgHE7yCGcvmGL/gM+sM3pjo95QsKgDAAEIoH5SCQSmlAatMKhhGEbt/EK1wcYyrEpy5EB5kMCKOENLEBZQnLZIAESVCAHXrIm8HDTZIgg7xE3jIMRFZCoCA8YVGezTKpI7HHxMmZjKEg3dIABlwPHjGAIIFAHjiAi/yVSA3mMuWaCHgThChpAEAquH9rOH66hAQLBEBoAG3LCA67AEiygDWfPBW+xV45O+LBBfsCHHYiuZ2RPkKICWcqGePrBuqbhqsAHn26ykiBAzhQgURICCJAQKEfEHH4yHsAOCPQMKatQKW2CKZ3yOMERKmmiF8oADuiHGhSsHyihDMrAErrSK+XRNBTjME5sLCMjxEYjFDDhlYyKFY6FTr4A8kYMFRrHcViHFcDERxBR1GwHiE7nNyJPByqP85rDCH5ABxrQLyfSJioyRzCSMAUhQdswEOQKGt7gDdxpHfzgCnDhOguiJGniPWTya5KOHaKmNHdNKqgnF7pqF6UmfP90D81mIn18j3gUQguAAEZlNEZjNBmsLw3kAFqwLgpMgQK4TziTshuV7huR8zjX7mrm6Ss/o4OyYRp8xDsj43aQpRElY7hqiU30UXaEA5lezHU8ajIibQ8FcA2eoEzN9EyLgAYokQj2ovMyzwL98i+XiuVG0tswdEWhp44s9GWw4UNQErAMoh+WYg72IyfMKon6AatekxzSi5p4kgLgRhiaMPu24kaprxJGwAeEkAqBtPuIkyZapEiPUzmHT0kzTe+GARYozhANkmAmY3aKKjJO6Idm9cWAA16SZElnixX6UYV4pzqM4AFl4PL0YhJpgE0zLwZkAAfc1PMA89YEc/j/7vSr3EpRh09skA9V+qFPk3Guni4qJLMggA9EVXMm8KhF56odpmdPQ6JtDEALwII3I4HOhDIKoq8IpVERtIACgCAS7CASgrNTh1NIkcI4RbUcj9S5THUybmthVjURZ+lKIYMV2mQ4hkpjNOlNDNBWeVU0eKkZ2HJJO2k+10Ty+sII6nIIjuABMZFZ9UJNZeAHjMAIiAAHaAAiBfRZQS9ahW9aQTUlnSIm1iETcqE0hYU3zqojMuEXe4b+5qkc4AEeOvMsOIVG8McAitArbnT6ru8GfOAGRkABHoAChHAEgEARtEFgBfZTgYJID5YcSVX4FhY0HvYedWemcuhODpA3/wBKpjxmYIAD4gZwGKL2GYBhVScmZEMHqZqjAiFRL2XgBiCQWIU1QOO0T3T2KArUOjBysu4UJYEWKapCvkBibIq2dIcFUwhqstRhH1ICHGSCHKp2RhICWqwvCqZPDkbgBuwVYKVBG6QhG9V2eNn2qwz2bcUxYSfL/k4hV6H0Yj7nYpmgeYUJY8uyEAUQFlwXH57hLSWDdCiGZLGEcRsXAmnACNQ0E/mTCCrxcpdjQGtic6ujc9MKQ6MNq2YiUvA3dP9qoKRCWDKBGSYEf8VGKvzBe3jRubYXdmNCHfiBHEBXOmoXkVxhXvvHFbRBGI5yeDmYsQj2KI4XeZMzJQ/ulP80TDRw4RUc43lF45jycU5GhpZS4xSiNx8NcXufISA5yEjEd3yBVQcAtAjycgja132Ta06FiH6dCkNTlEPdEY94UPhacmkReJvUK34+gh3Qhl37Y4Fhgs24uCC+Yyuqj866whwqAQREQBoCtpGEwQ7sIG07GCmLNyb6wW1FGByVN60OLuGelMKcIRsAkoUlQ0qRZWTQ0nBi6SxZq1dtCYe9V6ROGHYuAfOImD/bNEcoDwcw2X3hlybk1zmU+KIwtFfQFUHCKRxG09uMAlAxJWrCZo+aFhsiWOnaJy74IZf5YXvhQZfX1dqsJ4zZbYLvwRyQMA26QhFcwAdcoezsoAn/NWGO6fiDlzKPxTFuk+7g4nOGRgMXPCscNpaQWzU4LDZOqPeHAvBgxqRXj6Gdj4GX3flwP0rwbkjyINdli3VZO3k5hPUH+tKIP3kmQrk5Rnme7lQdWDAm2CGcsmF/vU1CvuAHuYiKCYkdmKGWnYKL22F2kWJ7+eU+wAEkxmjognY7aFNajtmM7yEZdhcNtNG/IiEMss5uuEEYIkqaF6uOYyKERXiPncr+aqM0YKFJNeh5dyM9U4MV+mAOkEk30nnE4rM7b8OjP5p7Vc01IgYy6hY3KnkvHFch05QSm7VN+3kvGHKskSugZWKgmaOgqelO0UpTpE2YaWRVmKI0Zbmk/2WCHlZ5O9TMLKiaqvGBgf1Bi0CCHTaFJiXYALxCKHXzHoAg+tDgpvcsHQ4hCia7buwADTIbpxtJp3ECj/MYm5Fubiuo/553xo6Dbpu3eXkrZBxZNIDEGaT6NASbX54hFOBztlJBMdDkYH5VL2o2ZjuvcquDCC6Rk5OVuCNSrWOCrQWlTrvNZ4XCoZ3LyeIpkFKFXHGQbPiaXQHEQeLitkeFsMWsamJTLoiZK+ZNGJLBHLJABDJYjsuOs9GgmdOBs7lggz17ovLGmsPRpy/KtCtohRNRcGu1du7zN1xVVnlDY2NbMkBJYbCEvEFaty0OfLlZTXaHOdiXWD/cOogAAv+Hdbgj8J9TzrlhArr7wq0ryZoceHr4FycAuIri6yi+VaL9AbDQhlypaR28mCbuaPe0Y7254naBAAgo2240eMntJhK4wKXrBsrtoI37G7RFgkgTgRMKgRO2PA+8nMu7/Mu5fBLyQMCT1Cj6oR32MMIHcJYamU2wtzSkVG+rF1ke3M0/THtTIodZoXD+LuEUxs07fDlg1nL3ggJxli/Q93GLAHIXPcUz9yYSYQss/dIxPdM1vQVqIBetKUAEhKrUgVHj4paBpbu/QCfjIqj8alnQ5kP6GmwiJSjoIchpYnyi+CiMfKWBoGyjYLGEgQu4IBIWq6bp2x2cvL/dAcsDVRb/COHZoT3apX3aCeEcu02B5uGCYEOoZejwaEiFezhLWOFzdMfiSqMP/igGCgbO89E+RQ0VXqEXJAOHdVuHM+ld9LzQGZ3EIz2fY3Y52JfzZnafJR2JhUe6x+zTw4iqNiU+tgyfnJhGzmZDfPwmvqCvAlU0tVie5IgnvsgpbP1nt8PIi4ECFMH6pFyiXCHK7UDZ1ZbZncLZqX3mpx3NqQnb0WPbSeNIECPcUSHFfumEwj2T0P0GmGBjMSGHHrzBXwx8yQQycFhJhp7Dg5sv9BOfyXovmWNmjTgDDV6aEB68YJy6aALUFeQmekXcwIUeLvolBTgTGq15+JoZljaJbu8n/woi5AuCKOi6doshCxiKApq57LThmfnb5fFNG65x8ReAmoVC5mk+8qvdJtih4olHgdZcTDdqMSqGhkyNpp76SlRbplhHPI+PYLZadDKLLSE5IOVFz2un6vdkkxG969930gmUZ5OO9qiqrs6B1JGCQeJD+KzYIKhhIcr2asEDAlwFscW7oNhhUuxipPHeP5ihdkFgD7T/pRF/joWBX0UgyUWg8aXjjiVf8hOWHXLAAg4zJoKh/eNxJ0m2wsLySjRu6t89mZKJtV8tNADiVKqBBAsaPIjwIK5lw2ARDAULVihWrAiectZsGaqEHDmeemKkiMiRJEuODGkypcqVLEmeOv/lL6bMmTRr+qPTkmULFTZ7+vwJNGhMah6E1pz37Rs6o0ybOn3qs4wBA1nu3UuDBo2weFa73ptqAKpYf/PKlVs3s1y4cN/6jaXJY4GBPfEeuLuLN+/dSIek6f0LOLDgwXdNPYjkrZu3xQYqjO0ni5DkyZQrWybUAKgfIf3USVBWk54HAH7cvvXZwLRMdhU5LsOIa2PH2bRr264tsKDAQUWM6JBBQ4fJJ6Fy356NqvXA1gsbEgQ2bVo2h8c5xjGCcuUPHD+y5/wOPuXLtzjDl9x5On1QolCRfiunWr38pswy5aL3kwfYqea6movkCldedUXBfmB1MF9N5KDzTTsy9fP/TTjTlCNfGXL1lwwIhAnDRVaEfQjiYFaA4MtiJnrT2GPAXMbiZZn9hMErMV3xRk1vMAJFaQnOlBpNrHX0WjO4VEdkkR1hMkcfocg2G28iEaGDDkSodImR1b3mzCsVobKMhM4waWUqa2DnnUlDyIAmEWWaxyZL441VXptFoLfjjuxB1U4789TJp0/rMMHEF8z4JNcIhm4wYKKKZrGAAgrINVWf/rSj1DmqLYgOfupBYEBXxdiwYYd2hAiYMKSkQ6pe2tgAxDbbnMiYY2JB1mKtk73oEwPUxCQIFDQpo0I/OcaXYI8z/cgRLMNoGWazRJ7yRQxM9AGmRah8QYMM3YGH/90Wa6zhrXHOFjQMbAS94owzsFRb5CXY5TREtjJMyeYQOgwh50pvihVnm3RKmt6dTlEKH8AG+5PJDTcwgY1bFRg4VQVRKHwDEBZfrAUQdCmqqAEKSNrPOfPE1886/RA7FqeeivChK5r4lSpewmQ1KqnCZGExCHK8Cmusj0Vma60MQAIJJUQbrYxb/RCATUyGCDFTPyeANmyfxq6mnEKvDTlu17T1wYTC1GZNECA0KDzvu9+RiV0oXheEyiu9EETRuuw+O8iaKv1w7xFsEpEtDWrma9K+UPXL5r8HiyUwU/Qk9c2ei/PZzxxfMJEJPf0oALEBIAiTBsWmuDJ66ZEAYf9Dfxx75fHkfT7cqVXFAMENqbXHTApWaICojSI2cCCHy8Lw3DOKskJFa9AtMvBG886/gYtpEhAT0xtlzDQKBs17oMIoVhOLLELANNPMMG+ffxArYAOKimyDXPL+IHGceUMMaY9ExA9D6F24uF1ThL6CxME87xoceM4kgxjgi3AlMdxTEGcexfWkH9jQlOtk0jij9KMcStHcBXe0jkxkjh1TeUCi4pEMIPggEsL4S1bQsAcQ+AAIWkjG6lr3wflwLnZWMQUQSBUJNNhBG3oRhh1aKIwW3oUbdkhDFJ4YicG4IgsPyIImXqWY4p0oRbMCBhuUxyJc9SQJgohJ9/xBD3b/+IMaRYOECoQgIz5dLSbhOwi6nAGMAOoxFajowxwwsZFTbME72BkCDnTwg5LgAE1DGEIi3eS/PXptgG1aJA4MWITtCEd/KPlNDD5JAwY2ECZwIpwEawIND2BAAt6biTIAAEtYNi0JBIAlTwJWlKf0Yx4ezGGdAjEVICiqGBRQBKr+ko6scMEVT5TDHjhQDI5NJRAo82VTSGgAE3qlGCwL0QuVeBdtRAENy+RCGFxxl5mhIQod4oJepCEMaZhCBByIRDSIp8UTkcJQFnQKPYAGRsuI0SbEaIAfoOAB/IACAzSpmhzBRza6sSIikgxg+9qXilCAxCT8K4K8cJAtHfhN/yXFqejbBCknIqBJBkOgl0fRBFJthSRbn7TfAkVJBMtVo5pCgWB4TkmTHJSxoGq0iRtjkgRKJCiDTeGpNcdSAbmYQlGVoIArImEHdP4liIcQxjh35woK4KESlYhmV5IRMac+1SegmIoNEvWpIkZCG7fLSySiEAYi4kUbyoxEhw4RTnI2EQ0slMYURQACCoAACFfEZz5PFAZDDQp5AA0oZQZqE2gIAhJFxUYcZUIM0HzPRxE1qWkHEoqO6uCQJvmBDA6JplCuhDiRPG11PtLR3kQJk71Z5P1EIi95ibQIvs0WDlDiSMLpAFBzKGW+gLoaAqgjJidoZU1OoFR/JIERFf+UD1PXmkNIKcqHIJCGNL6pCa2qqolaFYYV3suBPQxoKnBQ63zoMY/pjmUqU03UHnygXmlwoUOA4YY09JoXYbCQr1rZawun6AAOcEAETwyDqxz7WFjZwVAmQ96KLFsZzILXJnP0Rx1ta9pLsASBMojSI0VSSBrQoDtGSC5HSypJVOCCOkXSKEf5NjjXvrYkRiBCS9VWBHv94Acy3l9vGllj5KJpuG36AaAy4Vw5QTcm0GCATJIQCJsoowFFTQIGPNAAS6jnuyOe3FQWILssgGAqCrCBHNDgCr526JuBqes60WBgVgnIKhUYQVHFog6zSG6CDMqUfX1iAAqcMAsjGKf/K7jBDWGEwUMxC4w09oBYOURjMdEYMBdKlOHHRmMDG+ilU5IH4lu1GSglPjGKJekkM+EAB/FaaZrW9K4ffFIHa9pCHwB5N9oAYxnASHYqhkE+rt2WkiUR8iWhBFOOIhnGKEHytnUbW8L1oQ/9dIpPwdMCCwhi3ewWRNP8MWaZQKGMNSkDFVYTk14w4Bq4lI+rZ92TdeRiHW69hzmAAII9gFOcT9SGMPKsTHAGRhsUUyLOBCSMEbggc2NpB4PI4dTHJWXRTiFGpAcUD1bdVYhZkYYmWFjgLEg4sTTnAM0VK2EJU8AKpOhZI7hwCAyn+kTbaEy5mdKPRBDii12QTNOb/54HNuSBEE8nxNSbXmKAy6TWpeUIKmp764RgglqooLZJcBCDG9wLkSvlLUmMcLYb0KBMcAcUIIkEC/I1g8cHwRKziGT2kQg5tnzjtShVEq8Z55YlqWDFW3hRnJdIfvKUpzwgLPA850HDLeoggKZykN2Z0EMCvbBJCUDR7/ScAx3oUMej10qPL3xhDgqgS4ay8BeKKwxm7hDGIdQrGHHeIAow4wbqzBEPVxiquWM5h1Ic9BNKgRwq+jGADb1SiR9K4xBYJeelPS0CKxziEL4ov/nPj36hL0b9Q99iBV5vE8iwYf70r7/9788GL2udxBC9zSuysQx8F3Zix1yD8AQrIf8DCnNcIrEd27ISOOACcsdRNAAofdB1HYEK6aIRXYcuGwh2HnGAJkEEuyZcR8A/SuZScvJt5jEQj2cRqSAQMQiDMyiDAgEIJvAT/eABMsIODbAr7HBo2WMTPUg9p8FmTsEPSQF9EzRi6yB7X/AAe5AMFGAKd3FghbEHFLMHzrQHWZAFVuCFYSiGXmgF6eAKYRBFefFMyWAOhtIwjzEPlhIU8FcTnGIAyDcgIAB8QcQFwrAHYDiGWUABcqAJA6YJGeYLh3CI7ceIPdMYdEgTSYd/k4h/+rd/NMF1tsEKWJJHCXEKF7hHfQQoX6BiJ9FII4F2MSAc5hEvvEZ3bvAF1GL/JLDwCrDQdQAEihzhYywhbNrCEr71Yhy1Wk52eP3jgkYCCDCgVqMgAYKgAr7iD38ANTGRA2EmEyWwPUkAiT1xhE1BKZHjE6t3FuCVCV+wAXe4B3hwF64wYIclB3IQBe9oBe+oCJEgB4qwTvFoj/soB1YgAhKXF4oABPFAXxbEDmihdVOhKOZAAQnWIa4gAj6gCHLAj/ZYIj/HBVf0WGHAkb7Afo2YT1wkFrJAiSVJf5Z4iVvXf7YBDOkibQbRkhoRdtfyBZhgdr/hi0UAJVKyJky2iiNhL/ujN0TwBBdFEBSlibloJbuoHdnyAyOlEmgnU3sTOIuXLw7kFLxgJTcY/xTEYAigYBrMUIT+8AoImW+MwAi44F25lB7qoF89wUHfIIdPJRVzcQ97sAd3cQhONAJWMGquAiuuohikMGBBl0XbYAdcEAUboAiukAx15Q7SwAEGNxUQEBPzwCDn4BPYwAxHBzAKiXIZkhdNFAUiIAcm0g2vsg1Z5A3RMH6j9liJeWogSZuPOCtKZ5IliZIp6Q+ZeBtIiRDp4gy48IF7dAqhEHi+tYorKBIsdlMqBRwp+HZGsAWnIBu44JK1NXZKOS6hkBM4iQMsUWOH5HZAGVtWKSdY2RRaiYzKyJtDwZanYV+YQnI55AD8YXA2kJe9FwUjcJo9U374RJhc0AgaVv+YWSACIgAqeJEOFFAJVhEpk5IU/NATzCB7WDY5D6MAipIMJmBX/XkIIBkNsNkz0dAIPUebIGmblJWbuvmeKklaXgNt6jKAqRB4mQQcNwWUT4k/bRcSNeajLPEEuVEu5YMQfXA5ZFdR7iKeQsajKsE2Oqmj3MY3xFiMLkFKYsGeRcKVL9qNCbJLb+lLYGEVyRBfeKEIeohhpBAGGUl0pEAKgGkivmAHjcAz0dCQeSENIIAH92AKYUEWSaGZNpELssd8B7NDHONDeeGPHtmIh2BOJEp0KZqiK6pLidCilLibKemb46JjAnhaKJUS5WltJBGU3rFaP8kSVZIK2Dmc6bP/Pl9gUh/REoUklN+BQKp6Euh5lVkKFVtKJMm4jR/0pS/qFFMBAmkQCcRUhYVBIlpUiED3kd6gCXawiCZiF6oiAmVlACjgFmlUTSUzB3OQCwBjhyW0OpWAe3cBBFkgqUO3DabmqJRKryZiqa9GkplaicbamytZo10TCppkgt8BnoSUHb4xY2vDqnwEqgOBCbKHCW6zR97JLbxaBDgpW1cKHurJFMBaHV36nsXKr0YxFZGQBmkgB+samRQwryUaBnbQssVTagMmqQsAGNLwAObwZiczhwYjFw9QRYPmX/vpDhyAaiX6rifycxY2rXN6CKQQDTFLr/faVLipr/a3qZfY/6n/6ixxsFLByBKAk7DasVJWSZ23sSR6dAlbsAU4NaVAGVLg0YBQxkAcaxQeexzC6qXxObL7ZQAmmwYSeUxfmGpNGw1tGgY1Gxh7IEyQ8mZrpZBCqyh4iRcUkLTesLSXS2pNayLb0KbsBHT1aq/vNyuyIAZXi7X8urVcGyZxIC9WuhK8ikAZmxNDyrqlyEC9RmyjWp6jiiafpC1Q2SZ2KxR4exsgy5si27c+gU0UkHxWwAEw4wogwLlDFw1Qi082W2DHBwKPAimH9kGguTpWAQRVqA0WI6eQ1aYoKrre4LlhALph0L7GM6wxkXRLh7rzJwYitn+ry7pFIkhQArbFuP9kbwulRvAEg6DAziZJlxAEoiRktDud4AGdNUVl6emrT2G8tqG3Icu3y8sUllBwB2cDepUOatp+13u0PXNhsKK9i8sByeAKWAEEU3EH9Xsa4rs6pnAB6bCnVsCasFKIiQuSAVo8vnCiHMm+9Uq1SGe6+XuSquuv/wvAB2ixZsJJKcGcLaED9rMFGGVbp4C7+VJjIcWrRpDF1RYlOSqd5kG8QbHBtYG8Kam8IDwTHTAVZsW4AQkEQTyi6mcHbbrCqZZwxwQYpkABJ5sGjjkVCHJB1dcV0lCPqmMVVYVOf5hh9wSSbOqmj1W9qdbEGmS1+bu/cwgN71YT2KAM4Fsn/kv/xbbBlC1xZCIoL70rJzSlA7Ybxk7iG9yRUga8Ejg5wGyzxRubwVm5le7pwXbcFOLVFZRrhQ6wwr7ABcM3yIvBkVywxItRfloUDRbjmK5gyHjxhVGQBubQH487OXaoOvEAuAFyD/EgZzCTBZGAYdtgxLQZrSE6v6BMupR1ulCcf0ChDh5wAhZwPTQBAxigAgaFw0Hhyq88G5ewUTkhbHInndDJUiVhY7FLBG38GzSwP7R1Wrk2BPYjAxabP7D7HcqpseJxzOu5lTi4t8xsFA8DZ14Bze6QBf9pIo1AMQUKoGFgp7DCpmGwzeu3Df5oKMSnrVlAyfcAKQDjuB4zICYb/wWuYHAgkAXHtKeuUDzRmtTW25H97M84fL8CXco/8Qa+wg7T4yMxgQ1MM1rHwp0STRBMujYJeAMu4IC9gbC7K3hT9ovRaSYpuLDGGQchCKTAccavyyZMJtIvbYxjEce00cHJ+8E2bRNyMbR4AQRgDVkKEwVjnU8Yyc/5ZAcKA3x3kQ5ydn1WYQNTAZZ1QmcZ86AD8h+mUAyIbEzpNIhBbCKQ2slmbdzuh9aJsATLzdzN7dzPvQRZOxMYoJb+UAY1YhPrwACovCMRjdcHIarfQQRpVz8srRLgGbtfW6tGMAh3XR0U/QQhSBJVGh5GoN6UXYxvDBSXPRtzfIl1bMeePf8geEC0jBXEiRkFQs2Ih3ADs/lYmhAFPuALgaEIJjAgf9qtD70aBmIC0qA6hhXbxAQCICAC4pxOFyDaR2wHdqDJx+3ioWwUyg3dM/7c0i0TusIrSVATjCAEGKBmdY01340bbUvBCRQDAwylqYjkqBidixcSg1CcRTIIRlZIiMRAOkADC4jfh6ffP8HfHZHZdLzZnE0TAm4V8YAHn3Pi7xoNmqAJUJvCdgC6TesLFgOZeUEBUQ2hBrAApyHC+1EJM5wGWwGPaSANXKGuh+wDcK5Fqunijw7jQoGpNE7py808mQc99kvX/vA0qPQKZeABrDwf3i3kBUHkB3RIS14SIwj/vLb8ZK5uEnEQ5bWBnHGwBrkKOIwkyz8A61vO5THdsTNtrAAOwmZuDqyCYCJgzy77spybmMMnv4W71OUFGCJgVgMy1TKBAsfjE3BgIP1lFXe1yOYQOgCG6CqbF6bgAxypucZNCppwzWYd6UEh45VO4wTQbuwWDDJhAfvuD9bjE9UF5HTk3nh96jkREr2oqynRxfUzL/hdnWEyxhGs0eZtnq91xawYJRmfE13uE1/OEWH+32NO5jEBO11hCgtqhRwgdL7QplyAT1GLYQh+CC0+dFZAtHlRvpEQCZLbvQYgIwuQ7T0BO2TqFcl3smyoQtBbDFOoCMKAYHehCA3u4J37/+7tnmGKQAC1BEtbz/WxBPZhL/ZjL/ZZMO9AkQhiYO80buMxQQU1ooM8uCuiZwHR81AxWuodQav13cUtNrBJBra+kUCTDcHc4R26PBCzHgqXAD8PDGO6m0mHhBJHkMYMGG4ksZO9fh5kz/md7/kEAAipcIxcStPLXPI2kago/0N44Qo20OiHgNQnQs2hCytIrJGMSApRQLRQj2lAUOhafeH7oQAFYgBloAP1NRNGzzHxgCEgYAXrSAFWRU67o4bjFHRG3aZ2wMJNqwhX4DqgAAQF8M9QUe9rX+NAAQ0ScAU5cEsLZWIYQAVlgAFC4JnqQeqlHstrk3jEiEDhCRBFBP8aIYJDBxEjAhUuXDhExw8iRYwMGUKEyBAZGYcoNGLkSahUqUIZuRTS5EmREhkqtJhwpY4YMn4sLCjTpUAdGXUcWdhxJccUSfwNJVrU6FGkSf3BuJNK6VOivFBOpWoSEIx+ULVu5ZqUmoeuYcWOhWrJwIN7ae/FA5LF3VthUXxs81bX7l28pLhwsUMX71/A20iRiuaNVJgbI/ZIi8QlChouPnykSeNKrdp49wwYMJE2y2bQxPyx24zWXCQ5wi5fNnXB1Nu30oRJ44IGjTbY0kSkKfz3MN+8YcL4OqQJcF1FV7KSHfsKiIEKy8kmWlLd+nXs2Zcw0KrO0it6Q9eJ9kf/bZQl8sy1NpA+lB2rqvHlz6dfX+RNhgVxzPzJ0EhOGWjoqb+VftBhIxwymimnGGICUAaE/LvkEoUGOeVClCj8j4Yf8CNQogRl0IGjHyDiaSEAcVjoBxpo0MGgn4JqTz2omHJKPansmwoQE2j0kauvfhRyyKHgMOCyZExw6y1uHPPBl+MAi8YOLki5SzBS/LrSF1/80uuGKEjxhYsw0LCCgseieAyNLEYwJbPV4lytks0q2AyIzFyhLA058eBAGNhg4yYS2yKBzRUObhAuME0OiUZLb6jca68uAUtuRiKPGgWIAqJTLxE2tBM1O+4yNXUo9ox6T0dWW2WVwv5+yEjA/w9ZarFDhRwawsMhftioiB9iuCGGH0LsMMEGY6DBIf5q5SiUU0IaRCBZMzrR2WJjwOFXYDNSMb8XIxQIBxpkiEmmlWQ89SgbaczR1VSuwnRd9YKk916ojFTLHAoUCdQdNG644dEo/6ILy20EC4OLQ/7SZK9DstQkCjD7asRRb3wRQU3H7EhHEQrMkXPky0BLBs5k0EgjEldcEfkec4CwAbd/3YmkTFdyo+DhvXrzZhuff8arkYWFq/K4S/EtyjkFPGWOulGjrq5UpX1MtahV4dV6a5NgXcmIanHw8CefCHqIoFnFLYKIjER0SFgXtjUIIYySxYGIa51dqKQ4cp1Vh/+DamU7I7WrpXXtjXxiqNpzK2JIXaXbxXFrHqv20V7LM9c3rSRrtkIEKwuWkgswjdMrijD+OsSxKBiOBrGj6/JLjj1sfixnEJLhPBLdSV4NiNXMccUUPaOIJJ5kQLCiZthuRkOTQ4HYRpMwQs94YesB8yWaaBrJHq+kLd+003m5glrqUanOnKyricqaa/hZPeWSIPoD+6CxCRxCWGLrjmFXv8ngBhqhwbA6VLaOGAEHMWlWEZiVNwI9gSEOAZAO8hdACLmEIOQCIBHKtZOvTYQigBsb5PAlOea8y1Xyggo7goENpGDjGjNcB1HoEYxrDAlz61MaChawLw78Cwg+CJr/6O5CCordoBHeiAbpYmcXX1CpdXawQxgaQTC80C4dh4AM7nQXD5Wh4WW+i1PMKMABCoxADlFQhCk4YIp0MO8t2ohEJGjmDlMAoRtMvJgmfKEX4BQsYYeoHtKUkzmmOW06oUKfqNTHw7C0zz3wiV8l6zM/vWUSJwJzwbGG9a2BMCgmCdoWgcolk2udsoGZTGCKsLWfsRVrP8HKyAUFUhAOpSsJ5csUCsmiwlZV7inBkEAOJBCIo1hAAhjAADL9AQ0L5MACbxDSDiG5LjsdKS2VAMK/FAApI95lTIrqzeqORpxGHCwah7ADILlQxLoIowLakIYd7OgORVygGOZQWRqk/wEnMqolSUvC5272wIGc/Us2csQjBEL3MDBVSTjf095eUmepQyZlHu1oxznYwUuujE+RYzlfI0l1zbFIcjSUtGRLq3KKNUREk7X6jwxcAKFuyUBsxbJgR3TgosYRSJZqU+VM84ODu42tVwO5oBFowD9y6fRDNQ2QLsu30Y7SA6Ra8eVYgMkqFioFBpDwxzUaUMOiWIAaRkkCHPyhjgZY40fWRCmRQIOZPwUqHRQAZzhlxyWfRRFjkrIe0F5Hpkr9xQrLi6M74miKfiWDZQAN6D2SwQF/BQpRIrgjbIRRG+jVbA8gSCxEW7c9LEZpG75YmB0MOa918OMb30AHbdsBlf9gjAKGSUnkVp9SUpNe55F1hYpK3+dS5IbkFFuwpVFXhKsN7qcIRb3lEMqVSwIlsCEGae5UP1QtC071qZ+8CLa8ZdWjxHa2tUXHbZPSD1yAQh1ibYq7KNcjpawDAOwYigpGYRQLjCIY/B0KA6AxFCE4k0Z0Je6PDPBDtXBToRzwa4XvQqXh1GVKXLgi9bhgnL/4Iog1E4YIQICHSqR4jL4rBggy+690NPZfmkgDGuxQs3QsIGjTqyKIK/zHviIno0WhR21ne+RvuBcpZfDAFSSAi3mJ1LdKAVVwT9rgrRiXpclF7hO661z7KeSUAITJsir4ZYlUBM1gLkKKujsEcm3/a829KuEuVWVkJCc5KUJQARUkoIykdFUsX9VRWJGijAYQJQmCMEoJcgCDBrzCH/olcBmoeTmwYNmuwOMcBQAVKGmAIMgWjlI0NGG9Me1FMI7hQl+jQYGaSaNMkbBCFrIABAqIAA97aGMxTLHiSlDgNYHihjQY6g5t2ObToBb1XUydpVGT2i7hI0o/yIHnPKsDU9g4az8soQLeAqFpU04KqLqwhHOz4dzrRne72X3uRGu6uDM6LpdbumY294dZA2mbgcwlgy8rMEAyZYmvMnmRC1oXux964JoVh96iXDvPR56vUYJhAf4KQgiBri+OWPFxkIdc5CMHxDTfcHKUA9of/4hWNKOLspxRSKAf6gCAVv3xhjLMNdPy9tECDLAHtWC2ZooAgbSjkVgLvy4MhwAaxfhih3Ta5dWddYcraoOGf7lCDj5IjA1sQAEgFOOgIjA2sdEQBkMdW457EMHQ9kJRaYNvyEPpB7bzrOSiUCIH7tkvUqT8KRYEXvCDJ3zhWTBcnhdFy/ZG7iny3R8iQMSoCVrW/oZFg/1ciyAEx4hG8BMibhHIgzpt6pcHJ4PQ59uE/qj7xI+M96H4AQpDgQbil9LxFFIOA5SABCR47/vdUnooMKBEUthBAG0TIIf+WLTOE0+jzSjgMjZY9lusQFpSs5ZhcT+6XXjWuidGYwQ1Dv+UNmqTUM1yYWVMUoQNslB9z5YpCmrHcRZEUERz+jjuGJ2ROuyOZH7AFNkjCgNDit4CPMNLwMKzvedbPMZrqTXAN2cZnMNhJTUTuGTJoHEZOIUgJbU5gn5zls7TQDY7vdRjs9Wbh/87Mn44iiu4NHboO3bBvV+iHKx4ihP4L3VgABjChrUKj6F4hVRJsNH4M+d7PrLYjM64DCAYtrewNXgyolS7KGcjtSmhIkqRuhFQNmKjutiwAzSAP4bihkKRI2FQgM0gu9gQAStwtUOIuv17LaPwP9ebLXLAFEEQigI7ME3hlJESi0RQQEEUPAZMPAd8QPhZrsf7mhFUG7zRJDj/OyUaOBEjCMFcGZucEJvu8iDMW7OWKBBYWkSBWD06rMM7NIoXFA8ZNApBCwtCsw9hUgpckAAqwIBLewOh6AUMgAIhaID/8gdikAAoKIHZO0IkFIsHi5O8gg3QkTagoZLs2YbVcS2jGwy8GIHH4IaaKTZu4AY7qIxj0wYxnCOGMgUfQI4KGJ6Neados7BtuBgokcOXW8HZgr2hsIQaEA8CIDCjOMCnGcRBLESeO0RE3Jq+EcWeqAkQopZbMSpdWQjKUxvEuYiG1DcA6okTFL0PgiCJwDf9yMjV64c6rMejyMOhYDmkaMWueMX6MDSk6AdsAAWVe6vlU4ZXeAW0Ggp1/wCFYNChnTvGrjAA6buMFvsX6jMioAGnhMGLJiKT1IrDbfA0bfyXZOMLVzg7rJOjqkw7+oONPLILVwABEJgU/bNCLQEkauS/o2iHkczJolgHHvQHRtg7v/NDckOKQARIBRRIeSPIgoSXOJCgx0O4/Pg8nSA4Z3k4jlAzhlggF/GW/AEvNuuIagE45yKIEwmbOpsRtqzDjzIKaDirm6MCjruR3NOaWATK8vhJ1XwKbLiTyzCHN/oXEUC6wBCOtFQt3IzCuPucsgsUYbCNMCxDM7y6rgwUc2SiifqjLIy7Mckww1gYppPHlysH1zuH8gmEYpKA9OhHcfvDsMhLvTQ8vv/UNL/8y1bZgkW0LhFprmrBFYTMj3M5s59wM6NikcorF1DSpNFTEbA5L4izIeucOOxEijewABiwgOWbQdOsQdS8wdZksNY0ikDYjCwAqHiwgdr5Fw6IxyhhrYXhzS0R0bhThApQBDlQhE/zxvWTDW1AP6q0jdA6TnyyAm/wMGrknv3bhir6MLsYDBGlNiKTuPWaB5DCBmKwubokHwQczwXUCnbAhe6sNmLAhd2il/NEz0tSz0U0nKkSIQmsFTrrSA8c059gz1XSmxCxoPJyrkY8giMwEIkcRTszCnog0m8oByNVimtIUvpqUK+6rwldzUF9is3oHbXYg25SKL4SHR7/DaQ4zD7vqQtS4DofmE1yhAsKgLUxpFHY2AM5yJi9KMv9+w3bLBghVZV5OIc99RF/nA4nJU+owAYLEAIP2Dgik4AT6EVDuJcs1VL5OAXBfLyJ+KAwdVMSciD9pAnt+pAjQExNApAf4Ej+1E+eSKD8WT2664d1WFUjvcuUpMFAfVBwvSYJLVR/2AxlFMMskIN2lJ2njFQmItFtEI4weBRNiChSUJ5/gaxIcIBOZah0EAaqSwcruAEr4RJ5dbZ4RdW5M4p+oId1KNek+Lt/jFXCE8gryDl6wABceDk+JAYCAMJT+VVgrYpQiE/EQcg27Y81LQIcGBYZsJ+LXIlH/InI/1ObDdkJX6HWmboIaO0PbSWyiaVYVhTXQRPUCT3XQQUFdSVKEKgZyCJRqAyMwmgEpxy1es1COxCYMAAaIACCqbw+rB2BSJCx+EMDV/BCm6mN33QHYRAYNFhYgyG1VCWKXJiDOfiCL8gEtySLVyUpjM1YqLCAXhiKMsg5pFCHfcRSetuyk52PlFVZTVLMW7oInSCQNSUCYbmBwHmJgfOQnOAQiXSqAOGWEcxIyo2ROjWKvOXbOfBbGlFJrmBJ+nDJY2Ta1vQhAzCFOSEo68M+usWLQ0AdSFE66sGegiGO0Fkd6NyG6xOGIaqiMIgCxaiZxoiot30L2+ACGNUGgcnN4f+Vtrv1h0zYW76FXWyYl2C4AhVwuYq1yyYd3MODCgZYK38IBD08CiooxnUx2cg9CUVcXWxpkAYKG8jUN8BBiBYhwVtCqnNJ03K5PIYAQY04kdGjgaAl4AAlivNNX/XFlFdw3+L7U/tCTfyKUNZE12ySkyx4MXcIW6rdv2gQmBtAuinUi3sNp3dcuiKKBAOwgkl5OxEA3qojnccQQ1cIAzuYStiwAjmY4fGNkrvNBRD+AvSdAyVdGkMQAsUNt3Gb38ElgCu4Aioo4zN+hazoh/sdCpMsyRL420wB4ABOBWE9VlEsoBuowBCJqhGxn444gjizCIYAkJjQYNEVFsLBj0z/VJteUV0OXghtteIrhl2SJQpLgIQcEAReot2tsN35wF0k1F2gfNo4AYFlU9Q9mmKps2EPVc7ta9jjANFWg5SESTVHKYxXizVNsA0nZqgl/pw/aoRXZuVwutssruRcKB+c4yWLhVX6DTwGGAVqBgVqHgU+9AfDRdxLKwpG8ICKc1xVgdw6FmDmiuRaKSAXqMD3/MRaYZFaKhBvYcyeKNb2/JpcwbyDAJyaRWdJbt2hQF8svuJceMnmM+HJQeFBJeVjNOXYfIDGEgYKKGZWPgyK4p53/YumpMIrWS3CkDpPIwVP/dSD5Trwg1RjPuaHXYdKBuFMYOYy4KXABcRolmao/9hYf+jYj1WHnvQHSsCAKxVnrCHnclYuLvVnfWsRibxANOu8ClyRnsoVg+vItemuBBmWBgkQPFY9gGbpK87il0YKKIDfcAXUpCXXpV3hQnXoCFtUd2jXlK6wdbqiHyMMKnpK4tAELdmGEfABtR1paaCANRIYViOT44iGwxgOLMmYQ6Do/UtVbIBdyR7oOVCKZlaKZyapGViCGeiCGejsz/Zs0B5t0V6CeFMKWrVVXAUFDJg0AsCAEyiBEsDfkn3coqaKAUbqmaJM6dKbXhmqm4Czz3WgWXGunMDqQx4bIvgp0j0QCtpqOm2PyB7oSs6ELSaKsX4KT9YKXmCF7u5u7//+OPAeb/H+OEDIAaNdH4ZGQrZOCxtwhcayAkWI69WiaEjBWh+1MA+bTrvo0ew5hBvwgRv7F26YDTMsOsSGHXgMDDtwunYiE/x+J7pNVXZo6fQNawONaaWY6bBwgwn4cBAPcREf8Qk4baWI0vRgBxjqhxlq8UueY9u+bZTIbd2Waom8lkbsrgRaIFTqQAVxCcPhFcmzHxZxgRtAqn4eF6iSxB/n6vao8K++8HnJboQ+TTumJCwPiSxPBfMGt7RG16K4AzSME1MwgUABgkhYZVY2p1fGWv7mGVIVnd9Yorswp+yZkhtwa9ho8NtgHrazC3Oi89FxcPw2px1e2LvNBBD/FugvYAaYdmb5ZQ4PJ3FKH/HyxDI6DuCjrvG1mRUNirOEaERWMhaIbHIQ4RD8CJtacaWfAEGoahtV8lm90Va9nez0dXSxJmsGPWF4EeXnW2+eQ4HN8N3LiAeEOhQOyOj9Iyypm5R4fLbA6pJ2RBim9B52ghLEjgZX0HPH6l74SwcguL8ffbuCoZ4GjwIqsgPEJmZlN6JU7QdmkGw7gN05mBdq0OSxmknvDGOy6IdJr3SAn4BLb7BMP9mD5HSByPFO1whqeQiFKBHBOZuGABwkB5skB5ZRstwV0YkL+ilzURYXEe4N1iRtne6vtu4ZUQZIUAEhgISgLorthgpQlo/U/wRKYNc03pUTCYMNNFdzVmYtdbeLR/3aIAOkOK+w31B3x6geE6C6Jaa1ZRQG5cGL+g4nUrDh1Gp3d3/YoYj39N3bep8XYkC5N+jpPmTSfv/3gKf0gSeugtfSCER4jiCX8JKI64qQVM/cy+xjmCAW/NggdBHTaV11gYmBOXXyl+uH101fO9BiTMEFsoeGeYn5p5j5+PD1xLt5LHMAbQqeB3hb4TXmUTs6EeUZ/j6O1QosqKOLVLMDX3Dl69te3ciCSIAA4qGASNB6jSZsuEN0rme9dcjb2F3m9A7C70xvf197gG/7unr7v/QauRc9iBib/xilD8nZhEfyNtMJARog///QeLJBsx8w8v9R2aHl1kw430xw9OKnfKWw/Kqo+dxVa9Xk/DjJ0A2FjdCPa6OrIoDw5W0gwW2awtjZdogLl2jbvNmJcqPhNl+kNHG5cSMKqW2RKIgAElIEBzkDfXHgQIogy5YEffl6aFBTNG+kuCR0qXMnT2+KrvTzJ3So0H5GjxJNqnSp0FFAClQIynRqUTcTrmLNqnXrBAZUv4INK7aB1KHsWKVKq3Yt27Zu38Jte6kI3bp27+LNq3cv37xGhtCgMcTIXR00cACWQYNIER0xbsQYQuSHDhyPXcToq/nu5CFFjPxAbASHDBybTxdJkaRs0qOsxSqFcScV7KW84uL/BgTjde3evoVS8/B7OPGhDgzcS67cHAVu7p67c8Vh28Oe1q9jb1nd5bYwG7n4CsNwJUSNXDoOtCM+ih2H0Q5FIiUsTBhNLKPVzO6LYSObDA9lF6BOP/FWHFWvAKFAVMP1YxVXD27llYETgkVWUmfhlqGGG6YyF2ofghiiXaNBFoMOMqDomWOQmVbEEDE8JsMPRhChww9HAIaYiKTJMMQPKNIg4maqFUghUbLRRtxtHLIFiAlGQqlUcFFSqdRxyi1HAXTupANCJAKCGeZ14ZkXzU3tDRRNROBVR4p4MaXHRRgWiRdGdtE00kh+3mCEk39cACimgARS1U4783zVzyjs/wz1CjZKOQVVkWA1CKGlWElYZZQWEoUhk59+6qGQo5KKFxEyaNQjaTgQRgQOmP3A2GilycpjaCjqoJkRlQ1GFw0o/vCjYoSVmheRUxmqzqTsjCKVoowmhWRxS4Kaim6TaurblNlSGYgByGF5TzIgbKkIEN0Imu5AFe15px3j1UQdSxUJdN92EI0XXhiBXtdnf2mqJ9A2ebarbk+ETrUPPt9g688VVAhFSQn0KIWggg1PVemllmbK7YScmoVWtSPHdcogxaJsFxGSEasraSYSQeOIwdZlBI522eqYjC3rJWyQdP2IQ8y88pxyaqslvDC2QsARlB+7xTbbtCQ76TGF2/9aPWEF3yYTT7jF2FCuFQanq14YBV9XEUN26HQvT74c0shDFrnNk78FkS0owkwpDA5Y7GDwijoSELNUpAv+pvHGD3ac9XAgC+UpyZOzNUjRRgt5xK+LoQYakCH+hYPQk/2wmbCsfnY55ncdyxQ+C9Mz6eDEKCPBNUtJqyTVUFN1zSi9LLXOK6A8KtQ1xCAPzdXCOV4cNd/e4zWW5gCxx5Z7jJ03mNswFAYpAWenNkN1a79u25rYYce/5Ye5N1Hk8MPP6/DEP8+kuFgAQ9NLWYy4b4ovLkLNKw7k/CE5ylHuZKsr1hBQJIMTCU11d3kRihizQNX9IDA6sOAC99K698X/b371K1A/LOGBElCCKbkbDrVAVbUDSeAKHihDUoghASFAoQGjEEoSPACDHNBwQlgboG9wAa5wmUMEWdAGdLRBgXqxLzuNwEmf2HYn73AkXaQ4BHq4864uzosLUchiFC/ikOu4byjweB0+FPY6fmArBxKQCjSu4IehHA5jTAFgALPSOCLCpoAHRODITtHBYs0KB7+Ska6IQAPIzChEocmVqUhDyZoZgQYwuiQDbdSXD6qRjW7EBzkmdcKhEIMKkBjKCn/Twk9diyol2OE6GFC8yEFrFB4IShJSCKUhAhI2RgxXcmxgvetlL4oBqsl+uGCfnsCEIH1iDxQD1B2J5KQl/83kwk4ycgMr8mQm8hqTeMB5MKAopR9rZCMb4VikYEjAAq+IHDZy0KgE+a83fOzjVf4YzAq9ZpCEBNUpJHjIzsWMR57Ry2Ri1hgYxWAxBjWVDB7TIrsISwaXQ9UNfqaXIeiAk3s5VYr4Akp/9GMfo2RjKZkCCgwQTijrSCUrpaa7kb2QKesAQOz8AQNfVmyX/kjCFShRuOX9szfDDFc8HrCl5wDhS8oUEHVgQj6CuOk8JxFjFOSEkLq95xAF64554HSfte2EFF21U0/69MwxdQ87aUQpO9bBjr7Rgx2xKxA9PDAKXEhgHTK1Z1Oeks/a7JOf/kzqVAQpsoEWcqIHRf9NZyToSMXE7EeQcaBIizBJnp0qVb2qSwNLcznHRJQvtpIsSXtkUqQlhR52fR048tpTpaxDAr0wIcX8oQyICaWVvnklk2LJFGU0YChJEMRS+rpKf7yBCmWQAHANBEzGUgUUR1TOuJ7qjixEAl1TTZsvznhVaf6HINGYJkPMSpCFONMl4Wkvd6LhXu0cwg7V1MndsGOQQ+x3J3MlSt9QahSmlCEJQnnYYO95MQYlogUSnjCFK2zhFiwWu0pxLGRJVtDJjqqhki2ta4vgqorGYFh3WWTp7PKiFDvUxTfKi6tw0GK9rFYzk/wkbFvjD4Ux7MBLSUIQmRaU39Y0SSzkBSv/mOzkJkP5yVIGxA2TIAQhWFkIwRAKNDK1XKXQA4e4bcBRncc8DVMFDtDDUjI4cEzoKOKJ48XOFMGDHV+8q5r0epedW9II8ZCnJWYKsPm4U97qbOOMO8GTnqY64KGotBxCXooyMCBYA3qgF9egAgbeUFhJMUgNCBg1qUtt6lMjIMNDUYclXtHbpKgDF7fUFIc7XK1QgHhUCtXMqlQWLBShzi6LHG3qfETsvvxgoSZW9l1Ct0GjnZTA+yjHbSs2saBgAwPQUEYSSsBcn9qUhVTzAC7KjYtXlPvS7ADApVWwQ6L0A8sFKgEohHhmNC9lawZIBpaKQQFTPNUUICD0nF3C/+dAW4d81KFXmhRtJjAajM/uEc/6Cj4gdFIFKQbqnx6X0g9Rozrkp1a1P6ARwxyoQClUaEADGNHx39Ta1kzCda5FZAQH3pgvlzPCX2K1bAuCNJKkOtHOStvZg0Yb3hofjnB7Q1wOXWvS0WKEP6jRAMEqY8v9sDJr1CEUZTCAGvbG91TWjCUgmMI50EmHAwhucZa4qT3ntQmAz4unlUSD4ux7j34ZYudmsvXtLnl0lfIYapEjntQkh4Kn++GBeRJFsEIwhMdiLnMNiarmIYJgjE3Fq71QRjKbS1loRIerIxA92LlOOpWaXpunbyinTLGhHKkOXQXjAgAWwADvhdKAE/+ooOVIJftSDGACYtrAFU91hQ0En7Zx7mS+XLjqNvhMJzmx7yZywiZ18s6Fijt/IIQXyqs3js+XtwbkiRc5yS2wZegGMSlCcDm3LH953AwiCJoXEhGOYNDUf1SKCYYDMduoLBKqRMZf4Mr+sR75UYjrwQbsaYhxTQU9EIPXkR+jyNY6cOCl0YMyKAO0jB3xKYUBgAAxiUAyqN1zYE/4GUw0dM97aELdWF/e1Uf20Yff/Uv3zV3BER475AADWAKFGF7i3MH6IZ6q9QMBFI8hCMFSTF7lBdRj3V/JxMET7F8HEV1I6UjN+EwiSdZpvEyKyUDqrEwWsh4QEsC7FQcEioX/BGaI7JHgUFwXCRpfuNACCKygO0iDnLlgulREI8DNeGgH3MxgmqQL3IhVS5DCRchJoN1LeKCJ4D0aEAIAABDAEGZMDrxCUFxDCcyaUHDc4SFhyBHAD+XAD/0QUIWdUAgCFEAh/WWL/VWhW7CCAmXh6tSIjXyOXaCeaJhYGFYSMH5G0AHb5bgKDeTcAiUdO6gAAUAjGyqFM74fMZyACCbZ1OAU78whHd7bHDKDCU4PByjflgCBSfwhIL4XIWIVTqCNN9CNgMAXxL2E26mHVlEixl1IDlwiAWCiJjIFPCkLDHxbUhTh/6hfKZoaA5xbuaGbrA0FBuDCgnmaUkRh/U1h/y3ixinEgTDmIuj4DM6UxmekzmcEi0cahmk1m49wEEb14iFFmzP640xKY1K8AgbQQ1/VZHCFmytRzZN0I1HUIb7xwALsG5ZkQRZ4Fwe8YzqGCZ4cIkHkIMJt1ffJIzuCSZ3d15zNFT3UADS+AD70I0AuRYIxggoUyCgmTkIqpOIVxVsSxRvAIjvEFDZ04lDMH/r1Bi1qJFtswUceVEiNFokV4A+k2NHlxemACAVdVAedlCUCQFiO5VQkwRu8gRAUiBuGBRzmBjcG5VBqGAQYpTn0Gwfs4XNQQFOmo5moJnYsxNm4jfaZ03U8nKBsAym4nTLNVQ744xiwUT9CXnNhQP8DKI8BlZtUHKQ+HWFbLuRXqIMHnIAFBNFLuWIDMAADNMBE0lpG9qVbnAIWAuaHsGQY8lzLXBbn1AwAbgZobJBHFlusuGeInBQMXKJvvk4/4kKB5JYEFI/wvB+4KZlP4hRQBiVwfCPZmZ1yZIEieJc2PEAPOl93yAmEekNtzsuhuYSa6FeY/Bn4OSUa6WNRMIA/stMLQGNFLgXgSAAGvsIolEEQqSVCMmdzggU03FI/9NYGcmD5bQp3dudafGd4iucx6lh71oWIjcgQKNKx9YVhqJ6u8ByIgRI9MMAllugl7o9SYIME4GRQjAIoUMG3aSZYcGZcUOBnHii+JWgxlWP/uWQBhb4dDDJEaxLEn3mPdkQRDIqHon0oiPLGK0AjALyOiRJACVzaUjxMghHFKFRkciIWWzInyeEbX/YlzQnpaWSUZpTWk+pFlH7IzQHLpRpLjzVFoA6qP14jUwjBHwgBivqDINDfmH5FmcKFHHYjaGLXmprCBTDRU4mAK4hXn9ZpfVCo2VClMnUHfcBpnw4YKFRpZEKjoU4FYK2DTgpFLwhBb8WoPkFqW0oqmlGqRlqqqPZFMs7YXniOYhzU5hQguUbbKASqiQJAqi4Fb+UW8PjDK0CBVMgqVdDqW5zpraYpmiVoJVBAm66dAwirweDZIpLNFh1rmpACnS6s+IUo/1E4KzQW6qFOY+AIhUDiwgn0QnE6Kmz0w3LO6Kh9q4aFay2OK7n2hafyRY0toyTZGDImG8yyDqnikcbOKzYSxZYelS4xCwwEw+0AqDZWi63OIa4yltkVAwdIg3dFhwhU7NXK6dlQVSNCn7ASnrMCgLROBTTUW6NkHSRAAuRt66OmrFsW6FC0bBW+rM6SK4l1HrLpAJMyIM/2LAHQ61IQQ3D6wyhcAy6gbX4m7U0trWcKbFCaXSUopXd1iSss69WOV9ZWrltZ7vjhwh9wLHGUrFicbAqkAA+QrumeLumm7uqmQAF1Y9ze39zS7aW21t3uRWl51Ec2YOcC7W/061TwQv/wCu/wEm/x8kLANu3AatjjWgHV7gEQWG7FBmJu6kSdeeiHjl+UrG1tqNm3LIBRgq8BfG/4kq8BrCx2we7lye7sCill1OztOlB8Yk4DQsnvMsVtnEL+6u/+8u/+WkvKvW3VKW9SscO3HF9y7MEepIN3+WH0CmvlqtchOGzFZi+UhK5YdO+3aPAGc3AHny9jpa/MDQJ4sm8Jx+yu2JiQ0q+R2K9t7I5eApLTApK3GIAWYIkWMGjAnYsD83APZ0cFG8n2wkYGd3ARe3AA+56P/mgqjLAJO/ET18UKP2BPDtdPIrEMExHXYIkpUMDUPpUVoKMPi/FAfE/EXi0QE6FhwfD/UBCxEbux+SKxP4QwZOEiFEMxCr8vYErxhLSwUvyrWyAvCWLxABUsBQjDAj8VeI0x2XRt+chpQ/gwGk+IEGPwG1syHCPxHBPSKWyB/NqxZrQkynwhzO6xgfRxUvxxWzCtIA8wIL2C2SVDF1OtO9iAVC2yoJwJn2qP92ltD0uygVxwWLTxJXPwByeVJhPSX35yyiQS5uCuzpZyG1Kx071wAA9y1qCAUVaCckDuLO+B1d5y2WDlU6oP2viCJlAvs0rACbFzCbTzO7tzPMPzPMuzO2PA+RHHMBOzBhvzPyFzAnnyMn+UA9mu6eBAZ4UeNDeABzB0Qzv0Q0N0REu0BzAA/yCcgtK6EIEW6DVrCg0bJQcrwBuH9D6TdEmb9EkbwAaMwAhQAEp/y0qPgAh0cEiPtEvb9D4XQE7r9E7zdE/79E/zdEhXQHHoM0n3czAJUiqwwlIzdVM79VNDNVSvBRUucVW3BSowARN8wSmACiZkNRNgglV/yikAQlkPQlmbNVoDwlmjNVundVurtVuvNSqgAkbDEuMmL3YRw03zdV/79RtTwPfatAis9Ab89WEj9k3TtAYrwxoLRVHv81EDUgH1QzVY9mVjdmZr9mZz9lKL9We/RShgQijcWlZ/AWmD9oYwtVKzNlq4dmvD9mvLdmx7Ni/YdXFpNJrG8W5TydL9D/87ZEIusINj8/aEBAVx+wNkE7OkQoMgQELvNo/rFvd0+9hwYEMmVAOPUjcJpnKT4HVS9IIgWAJyEwdHb/d5Rwl5o3cwKfclkxwxNIAfQIEHaLfjSPd643dYHLd653eUdPdarPJQWIIFCEIOKFgwmXd/K/iCM3h7WzLJfZk/nMBO2jd/M/iFYzi3/LdaBHJE5ic7ECeCt3KGk3iJF7eDvzHJxRT8+bOFm/iLw/gbWvFUqAMB9FYOANUAJXiM83iPNw+Ku7ESMqFQOGGL+/iRI/ltQ913f11yCQUU3BEggd0JlECVW/mVY3mWa/mWc3mXe/mXg3mYi/mYk3mZm/mZo3n/mqu5mVP4UoACD5QBD+jAFcC5nNN5nM95nef5FTBACGS57fkDAxTnK/4TA6z5oSN6oiv6ojN6ozv6mZfZV1SD8VJ68YJCA4QAlV854nYZXlJeMCnDNYj6qJN6qZv6qaN6qqv6qrN6q7v6q8N6rMv6rNN6rdv6rdN6tSUKUriGgR1Yr6MUNpy6CD4eRf4TNOB6siv7sjN7szv7s0M7rbt475i6NfQWOxAABp5A2SZ5t3v7txM1Zg6OMoB7uZu7iRsZfOv6ubN7u3c7EFpAAxSku9N7ve+2NXgATHG7vfN7v2e4Xvl7wAs8vq3DtA/8wSN8wiv8wjN8wzv8w0N8xEv8LcRTfMVb/MVjfMZr/MZzfMd7/MeDfMiL/MiTfMmb/MmjfMqr/MqzfMu7/LcHBAAh+QQFyAADACwSAAIAkAINAQAI/wAHCBxIsKDBgwgTKlzIsKHDhxAjSpxIsaLFixgpthtQLKPHjyBDihxJsqTJkyhTqlzJsqXLlwfhDIB10MyAIctE/hkQ6p/HaFEuNBhgZh3Df//WwTHhoEGGKsuQDvxXT1ikKkOUsJMKs6vXr2DDih1LtuxYbA1QFJxQMJe/kOwcZPCYy+CEawv/RZsAYMCFDEMHkOKajQABAH0BrONqtrHjx5AjS55MuWEVALDeDnRwYciAoW5FyoyEkR1fLAP8sdMBwIRmhP9WEMgQzd8/dkMAOGA3sPCHKHAQL/ZZubjx48iTK18+kLeDerBBv/4YbcAHjDs/QBcYF/P0guwAEP+gObBdAwCkBvpr5/OacObw48ufT78+xUYAUEcfEPohLCUCCSJQNoIVZAIAwhBH0QcEHFIQagAmhI14BAqE1AcAVDKVVO4pZt+HIIYo4oiN6VDgfv0x5E8UiA3QVwz1DHLiQDbF8R1EG3FUUHoXKOSPAwDUZaF5BAizYXvvkajkkkw26WRE/gyFTUL/SOdQHARM0FE2B1ZiQgM5DkQKACsQ1BFD6QlUDAEDGEVQXQTUc+NAgwDwwZT/tKMEACYe+Q9eiin45KCEFmpofMsAEBiKcxq0EQGXEJeTi54VlNOiA9S5EAFlCpQLYtsNtAybFSZ0yAQEfIBCU1jI6ad7bTL/duistNZq61ef9killQzBQoADqVmoa5oEGQVAmGcuNJhANGE6oEDVKIvCYYhN8IerFnIoHFKC3urtt+CGS1F61+3K33fJCgRdIwOoRdAQBIBp0HZ4PSTopwR8V90ApcaU5SVt5nLgCqES1OEA3Iqr8MIMMwwLAHOZm6JAGbA5EDb/7FQpnTcdlGO/ERk5AG8E+YJYmAaNSkBH3LZTMbsGdThctw3XbPPNTBrJlsTfxQFepgP0OdBOf9w4ZZwDwbzQEJq5WRtBD++MkCCpIpywGQQIbfC2suLs9ddgw1cY0ow2RG5B121cMgC6CqTpQp0ifAEAkRIER9Y0DxScDVZL//UHAe4WJHPCYRdu+OGSzSXyQVWe25B7BJS65gARFyRghBVhkTVB/sxFWkL4TcAeV7mpPdDgXSOu+uqss1TFAAKW3VCZGwtN7EB7fl5RtAPUPYBMohN0ne7YGFZFPVJdchjA2QqEet6tRy/99BblQoAN3UZhcUHALlQMsCYMUKYNoYg3wJTqNkWyRYewGUO7A4y31gAO0onYBUpUcSCfr/2zP2IABADfqEfAAhrwKNdB30D0Y5AMQM9MshFIuS4RPt4JhgBRyMg/bmcCIQlvALoTCCn+BwBrFewfMXCACleoQqYd8IUwPCBpbOQSE01Kg1MCWUPYUYxi6FAgtuHWA/9jSMQiHs4fH9hNS4QBgAwa8YlQjKJX6iIjlihhAj+Uoha3yMUuevGLYAyjGMdIxjKa8YxoTKMa18jGNrrxjXCMoxznSMc62vGOeMyjHvfIxz768Y+ADKQgB0nIQhrykIhMpCIXychGOvKRkIykJCdJyUpa8pKYzKQmN8nJTnryk6AMpShH+aR2mPKUpDyjNVa5SlPK6ZX+gKUsY0nLWdqylri8pS5zyctZIpIBwAxmJRqVSi6qQiCqSGYy6dMKRBrgmdDEAzGLKUUjWNOaokAFNcECTWjGbptfvCY2tQnOrnTzmdIspxfFaYRsqhMm5zTAN99ZTXa6k54siacB0on/Tyiyc5z9VIk+5RnQJ/4ToAU1yUAfMItpJjR6BzWCHB56En0+ABYFo2gBD0oIcmp0JPGMADYc+lHWsZMNJS1JPHtA0pSqTpxHmKhLRbLSls60cP+U6U0/UtOdEpCdOvUpRnoqVOkBtahDPecDmIdUk4qTCx5tqkTi+YCJSdVwQI3qVR9C1WvYdKsL+6dWwdqQeFqArIj7J1ojEk8PrBWrTx3rWxHSTQZEoBlfnau3xMkGuerVINB8QArYkde/2uqaKDUsQ6DJgIwqtmbWPAIhmvnYhDC2sl6LLCb8itnLYvZm1yTEZ+n6TAaM1mahpexpB+LZ1YbVCEfYrGtZW9rZ/77WCKK17QBaq9tvpda2de0tuK4ZW84q9pymFe6t2Jnb1cYzucql1T8n69rnRvewxJWtc5F7Xekyt7rW7a6hOKrazuoTuuJ90kGLe9qBoje9TYpocz/rXvgOSr7lrWx97euk9WqXvuflb385ul2lpkDA8c0peLv5ADNgC8Ekyml+zRtYfkJYSeyEwoQp/MwI7OvCGCYuVGer1GaAeElZJXFgBeHYE39InHLYMIWr2mIX2ye0xn3sMx8QihrbuD7XvCdwefzjCAc5x5UlcpExLGQnyZiOOw7Fko3c5CYdc49RnhUPutkD5R7ZSeS8sh6zbKgHPFMf+jAAB7yMUCbJwf8IqEAyHMlMqNKiOc1uFe6Xl4QKLlgzzmMOrJQHVYxnnuDOaeZAYd8qziqHCBVQOMKf5cxGpQ7aSXF45iQQjefe2pPSzBEFFMQJaDxa+kn+ODOnE71otH6aRKgQK6jVeOonMcAAq+60I5ewi10MoAxGIEiwK/PqEYlC1nU2gA080QcIPJO2BkgOVS/NJDyomtNqbnUer5mIW3xiCdccQLgn809H2+fY7Cy1kwb67HMex6LUVpIHnmmMXBsgz4qMqL4jc1Bz00fUyF43uweKAU54YjILbSiToJlrNGc73/qOqB524YosDHssB4WCKIwdUXUraeAgN8ACoh0Zi+7Ax/X/acczIdBwh+P7kBGP6BGOAO6LYzzDs0YOJvTt8RGF/Ockf4wBMMAIRmDAADzW9nEu8cwbtNzhikZkzKc+brEYYQmUsIUeRiwiQkS85yEC+s9LfgZTmOIMBvDZklLwzFo83eWIdAMSqB7zshjBDb3eRVA/9Oav5zw5kBD72IXuBLNPQZ4on8+tcf12qCs9jrv4BN3rPhBf38LmLTHCF3rtCjn8nTKoYMPUwW6fsws+5Ky1AiPIInIb2GABSva5AVjeeLgbcheGmPzUB4B1V4i7K9YsgyGysEz79JnqpK8PCkZ+epDvtptj6WYEYkGiWTS99nd+eCGBrfvuA9+aXBBz/30AjvzPG6f56Cd50OH5TAsoMERsN4DbsW97Qnb//tdEgq8FonmUXNP8koFudBdnQwQf6XeAszcApsB+BsADjzcZwMR42GcJW7AF91ZI+JeBRuB7BLF/JfF/H7JzugeAkJF+dhUBEYBczUd0DNgDicccdkZ/tdABlmAJA2ABBVhH96dxmCAKXmdNbIAJkkZ3S/AJtzAASJASIFgfPziCJNgY6fcAPRALvhAKEbB4DWZmgrcCq2AKB9cS0OSAIJILhkZ/+mAJGGAM54APAxB1fnR/XFAQOydT5Dd1WZB3X6CEf1YfcjCEumcfUchivcEBD2AB1uAPs6CFQCcCnmAKq/8Hhs/kgh+yZfJnhltwAspAEDj4hvrGBYTwiaD4iQeBCqoFaTH1T1DABjN3dbewC7awBEfgf3s4H6p4fx8ycIIVB7q4i7oYC99RD5cQJlbIAA+giIFlAcYoAkkAAS4Rhg/YGItnhuRwAltwDgXhAc9YRhHXV3HWjclnEHKwcaLghyPWhF9gCF+AeSSxhPBxfLZ4iwtFQ/4wj/TYUrnAABaQDdngAYuHdNIkCMb4bJBoAJJIH8+0AGaIhnzAhgWxiXoUc3tHEXEmClwABZ43EEJ4UMImEuy4HHX4hwYJckv1eM1QkPXQAxzgAR7gi54SkNBHEAswEKvAU6VFQ/LRDM//1AH0N403YAz4wJAEgY0PGXGxiBLj+E9ZQAkDkAh6UJQegWPwIYDeF5IgFwHLkI0MgQ0W0I/QhAELeAyrwAlWYHYgEVhx8IKVYQaaRn/GgAGW8JMI4ZB3RHUqYYrilAjAcAzHsAuU0GsZEVnUxRwiOJVUiVzFeJgMYGIq0Q49EJAYcHBgeXZdeAYewVgWBh8pKIG1h4anAJQHIZRzeVAT5Y1P+BDuaE2G4GvAAAyu0IqfYAsWcU0x9mSU0YSTByIW1QPswA6nhDIp4Q+CwJUGsAJn0AeQkAQY0Ad9wDfHkFQ7Rh4GKHKWiImeeRByaUfTRZsooYqStgSG8Amu8AlZ/wCehjAAxwAMFBFZGleaXtF3hFkfVCWIYHGPEXCYDyCcBgAJq0ALzrljeMAc15CTZngDQSAP1fmZWBlO2RUWmNCgDWqbR2ALeckKS5CEEPFPmKActQiSuMlguYCWKPEW2RAKuUCioYAHmQlNfbAKqxA3E6FPPLAcOzByeWCG+gABP3mgBnGdOmhN69kYmDBq1uQKvVYGFnqhYnUcfeaHdCd7BoCPXlUW9agmVwhNEOAENiCQU6VPXaYexREBI0cONnqjcMkQoElHGeZvYXGURpAFhiB36rgQHWccH8mh80FVPdAOCWoS2YCf0MRW7BajyMFwNkoOBKqj1pmDacROXP8HGRvKTg/BpKRWHHV6m/CpVDY5GfXgp3/qEMw3UAU5Gbo4o0M3psaAAnlQpma6p1F0UuyJEnIQaXRZEImQjnNKGYOJf5fKYPEmGf6AjMQIdAUhAiHHAFjAqiRRDFxZo2N6Am8JETzqRkk6GdqECu4ZcQJxDLYAkdSKCrb5nvJhUb5ZHMWQoiHHCXpJBQOVBIxgBVIIol+hlgawaWOKaB2gDIiKEGcqrRp5HN96UFkwANQADBbHTkXoCpfwqiUhlRoYrgPHAONaHNnAAZx6TmcwmfoEAWa3CiEEGZlZr5xGDhCwhtCqqGEUcY0Ket4ac7xWpJI6ccBADJGRqxoYp+f/J5JMpRwnaa4EV3RHF08LwAmmMJMIJ50ge2czaAnyEBH7uqiduBwZqW+G4AqUMHfspAe34AwDoLAiQQiSmoHRyW4LEAHFgKwwgQcueXoY4ATvIxkCerRoxpn5mhDRakYZB4raGYBfS3d6QAqxUHxlEas1W3XLcV4RgAeNgAeERR+xAKYidwaMsAKn9wCCYLYhYQBOB7f6cIn4OhFNe0b/xAUbNx8AN7W5R3cdJX5kQQhCOrg2e7MMNlgikg0pwAA2YHaeIHgXZbmXuwVwO43VOLcKUbfayFdcKxaosAa20GsFS5SB2Rit8K+66rCB5WC8KxYneQJdyAhAh4+KWQ6L/+EYKleJINuWCym8CvG5diubjwYMu3ALzStzmJC3X3GtYHungvZgI4IHNuAEPyuSKbAR5eClZtEI1weycnsRxEtGUAkizRQJ3KdvGicZ0munMKhUywCv8nGPP/cAZzkQ4/AY8Td/9TqDnXsR6itGNQd+JNIKreBnEZehkSEHQlCz8oEC+pQC1/sYPDtQVqkZ6fAY0Qi3tRAE6NsQC/xF8StRx9sYoRdzagoWp2nD0gZyOjwoHoCCWrzFW8wAV2kQJitQs6e5+pAHW3DEqzpGMddRSiIKPfjGbhzH/2UWdum6VYyL1Dco4ECFfOwLfUyFuRAMGsx+0qgMYopoeXCvaP+8EEncqhFHCKM7Ilq7taTZjQLRxB5hv/p2BEBABEUQUXesTwUQLx70JOlgsmFMyPSnBmowB4dMDlNwA+ewtBmRwkW0BETqChV6UFwgB0BAOYSQCvTbjltbzNU6AM/wGNZKdzswAzMABGpFGc+EAcTKbgzgATzQF9ujMOCww0m1aocMzjgwAFIgpsZwAlqgqhjRyC9kTUvgBrusYGq0zOJUBEXwtTWAAzKwA58sTtLcwV16R08azvpwCq1M0GhGDlIwADhADrVQAc8KErbczusFBRVZkWw8z29wz9ZEBM4MzexUAwPwAjkAqZFxeAuFghYQARZgAZfQq3PEACQgBaf/cGdzwMo1HbKtrAaJ7JMiwc7UswuJ8LVHkE3e6EYy8Mwz18wzUNLstANJDdKvSxae4GwWlamaYRh4ZAEkwMp3ZtBSMAevwGnKsAhzoAUnQLIiMdHUYwvnucRGMMFzlNQ5IGlAMANJvQN+WAQ7UANAYLVT7RKmED5mtwC3a3ZDx8X1mRk7okewINNSsAiIpgytLAX1ZtNq8ANaoNZuRA3h6b5vmndL8AaiUNqlbUd5fU0e7cw7cE1M7dRjsQK0QAt98JiOOHSN2AdJYArOgA7YoI/ZoKeAxAMkQAJ8gND6oAZSgAOtfGesTAKvsMhfdASJcJ6U0Je74AZZsLyfgAyT/yzMdgQGRUAEIT0DONDUkvbaga1Q+oQCyzh7KwABwIQBK/AAkDDJ9ejNXMTVM53TnGYMpxDWanDIZT0CJ7y+/6QHeoAESOAGioAJhIAJoSDDyGRHNVADes1ORJADST0Dn8zXO0DeLyF2D1AJLx0JzhAJ5iAOQERIaiYFauDfIXvTkq0P5LAFFZCq0m1Qm+yjopAKAwDkfEQHNaDU/1QERe7UsDWEzfhzUDqPjfRMp2DIytByh2wMK6AFBrrjB6R7R8AFbNBXB+EM2nBHxwQEaM7R7HQE5B3NJBF/IScCZyC5+NgDPWATAzwd/XBIFiCdpyAQMq4MhoxmxjAJEK3OXf/UCnZICXqwBNkk5AqRCuAtR956BDkwAPus2p0MyiYB5wO3AI1oCiLgglCOEPVAD4VEqGowzlJwZ8oQ1otgCRCAzj7J5TA0dZ/gvrCAyWUkgjIgEDXQ0UUe7CZtEv/g6ewWASzKsTmYynSUDdP81QJR4wXNyj8QAviao2LkwkRJ4YVECDVsBDXwAgPQ2kaw2h7uzyhx7CH3AP+JEGWOMIhkbQbgu2gm6IJ+Z2b8AySw2bZORM20yd5+ENQwAKpbR33H5mje5kdQBDmA4dbEfyqB7AtgBWdwAlqcLgWRJ4ckr9B02QUN4zlNDh2wBTV4CgZ6RgF/TVgXCbFw2tp58HP/dJpQPQMZ7uYsgey7vQrPwAzMgOo+YkiZyQALQHv3vtA4INkP/ZbajkYrD1uJMADxbvAKgQoyD0eEAOatCwS/TtKraNIztxLI7gT8OQDg4Cj6PUbGiJC5FuA4YNmWUAE+zUYBzwaiqLXUwAwD8QyT3EcJL05cLxBSrY4zkPNIlwK6GAgDMMBm70jnhAGuXuV3Rg5zMAdVfgKnIAkD8O9R1EyiNZEDEAyCBOFZb01FAAQczeY58MzWtAM7MABO+RK1K4ia4RP0gA7ynkhkaACHxmkGrQYgz2k3AONuNGGSHgs0McxvJLjXhOQzUAP9vOTWdNdhwQOKfxC2wUjPZAm5/3bTMR6ylnADFcDKatBGMubCftSHGu7MM9Dm7ET9BhH7KdEDGh9J1zb5QRAEJPADQXADAHFDYIcKW07JUzZA4UKGDR0+hBhR4kSKFS1exJiRYiuNHT1+BBlS5MiMqLgYQZnSSI4ZO4qoVAnxCEmL/no0o5lT506ePWkaMKBPqNBkFfgYU2ZMKVKk+OThm6ZGIT6fVa1eFckR61auXauahJnyyJGwKBcSMeK1YT21bd2+5Ql0qD5LFU7hc4oX7zm9eOH+BRxY8GDCFsGWRZyW4czCjR0/9ilX6JYTyqhSfAVZ82bOnTsfjulZ9GjSFYFC0EfuRhC+FucMkFpa9mzatf8rYiIb2vZu3oFzAb2hzxiGPH49VoDQW/ly5nAxwWweXTrPFAwM1JrM57LHbdumTQcfXnxGQtDHn0cf8YHkyZa2p4cfX75EOblTzscf3sCCucZQ3M3onfwGJFA2NuzTrUAFaQtqqFowcE+nNDJbsEILt0IFsQs39MyCBvWppQNj3hspjS4o5DBFFUHKMKwVXyQMKP6EmkQLEkXqRpIB7oCxRx8jqs+8Hz17YQSHsjGgB+mAqmAuS2zsqYshp/TxQAQVo1IzErYkoQk6/hkgDqAYeCA6A5qcq8Ybs2TTMVRQ4Q2VIF1sE64ecFCIBAYieKDPLX/g0gLrGCAHKAP6RBT/UUH8me3MueiCsk5J4aohh4ZwIwTO3eTQcFK1rCNhgC0LMNQA1shRY0tDh+qgVFcNiEA2oPJ4NI/iPMXVqkxE4RWTIogAYoYB/BigPJTk4DXZZDX17KSycuVKRmPUmIOcR+kK4YYRRtgShRBOOCGEFYLIoxZrh7LOgNF+MyC4RyuwDFp5RRKlCJaAgGmsI37dIYci7BMCpYCNCFgO0TjtdN6eLgHuWqHIseSGE5BSRg2LT1FGGXIyroWPG0ScC4NDRQMKu0cjNk5hlS/CBAp9ERtrBxlmyCExldjgDLSEVyapuusczuOECoKoxbg5LB7gRnxOwWALW8sFiuQPhyIH/wNlnuI5a4kIcXmsxBgbQFiwFULsTc1EsdksrUVK1+EQt7har4vwUcaSPPjII4gB1PWMvYchcG/NtbM2Nu2Hxl4oLLMhQ9vwwT8ioQJCt4CgcuQWuOEUSaRQA8W58XqKqgWkfrSWGwR/fGU5XgrLXhlqGAAJi55l1rHGd05dIxKCMCYELULv65XYfmhoC70tOecivjvzG8TTcx98B5fLCrYhLCeCafHHbqcT+oxwIEGNWioIvC+8ElrolVNeQb8heUwrc7N2gDqhPxQi9J5nGaBgvfsXHJIdyzZTOCHl7yIv4EAeRJSyheDjHEaiyAj0pgWJnMNQmplFwxwEgYMYkP9nXOjf9czSLyIgDiNGIIRWGkPABHmQItUAygjOgbWMdGMAUlpIbCKCD0ukCyeN4UDJ5qLAEblwZfy7j/VM2BGUZKoxcyqgESUiJgOEIHQgkUQp0lARvGgBBUBREmHaRjWBtEaK8jJJbiQCu5CkRA61A8yBcHdGh/gDKJagIUVwCBF1pGGLFZFHENAQtcGsBzVzOUFxUEfHLB3GIkDIARECqJGUcEEwOmshIx/SLgZGpAt/nIiALLKIH9RieYGxTulOt0hNTgkTAesKsICACVUA5jnPamVE8LAA7VykFN8hySuk8IM5GKASjELl1PSxhcDl0lNc60paZjADP6jwLa//xKUzG/KCUHUSIr9YyDQksYmQUOU1xTQABwSTyqEYowJ8YaU2YXSSaIatBm9IxV9QccvuyVNUW5rG+xxiQ4fwgSEUFIkkfhAEfYwpmQ6yi9z8maUcLLEqRoCkvywJl31m058G4JYknvKkhgyjIpJ4DUjwMgLsWAcDf/EAezoAoImyKQdAsKhPjOA1lHBBFG+R05Vqyi4IwDMiFOSGQpLKkG8kdRNiWMg3vJERvLjTGProgylWEQlkemWMzvNmTWGEtrGopSx6YIZbWHg9baYAKEGQKESWShGolpNp5BhHMlbRhxR4ZX4GOKRw7hdWsaqIn3ARCyV20RY5DCyKrVyP/6ny6JAObOIbXXGK0/QxjnHYwAAM4EoG26WPZAQBAoONZ2ErRAg1/gUlR9DDLXYRCjj6BJNJ1KZ1FgCv5BGmqh0gxzyEkq6qxCFdQnQn8uKq2hfJAQpYeolbYJKFJaCwtjtBxfQem8u33koil+1KBQbwFD5A4AZ5uOoNgJKLrtLEQ4CFAJrosgXzMXesZMlpNBFjsJ7IgQtceG4/5Uk/wgIGdKfIA4TosgAD8ACZDLvgQo4bxodEwFUOswR9k2bfHt2OIWz1CmLYcF0WOcujHwXKiBz4mL2cQxkooFVDPzsAt7qqGH8tVfwa4ioMOGy+qeWwggpHhMCohAgh5ELtMP9BCExob8mYkMiSuXal7WoSSYClL5D/ooZpnEMg1jruhyZRKoYOFyiJiqx8ffzjIMOIEAMbAIj/MoMalDAlUPhpsbyWZIUgzAj8dYgc0yZnyBrgBB2Y4WieQkR9nACw1xLiXFr1qhj7mBy12AKEtNzm+fgZMsLKFyagaAQ8mxglbFAWr0ztOH9a5waJHg1VloYBk63Z1rcWijFugIEb8GGGm+Z0fEy8mbBcico7Pfag1TZRdQlU0QuRhzE6UGlcV3suDyqfs4PNIXqKRtnfVvZE2SXe0sA6aV4OwrmsfWtjYHqBy932hcozGnDXe465hKGhOzgaPkCwgfJQoLnW7TD/YyS4A+QyY7xVhDDSpMXe4E5cTcUUIm3bZmkfS8Zc1L3mPFQOAtO2TFwtYzEpJFzh+TmsbB4+aPuKaabA3gxeTkE+4RCk1g4Lwg2UcY5fv2cOoDy5hVKu8pVXWeKzKvBszoeCDnTAEsn1cd6ARyKYB/08QV020YueddVa2AA2qjpnQKdiup3AcpW2BAZM7pCwWx08c6pN0eMcbOAkvTayNk6LlXGDLZBDgfGqCLkXMgxguj09ViJ0aXBrM4Wfad/xySwDWGN3w1eoteARcJvduoC1wwcfZK+8j3AbntFzmsEG6ADlw9P2huwx9G+3z3kSz9zTmE71r8d9RQQ9+9w3/4o/W9AO63uP+zcbffil2Y8lEF3x4zdfInIyvvP7ZgAUQOBq0sf+RHaf/dlcAyg9hsBkuT9+P/N+/I+ZFYggcPvzh97U7Ud+UCYBL+bD//jc47r9NZPiDgBe/9Lnnv+TGjURQOzzsAJkHlMpGgR0vgBkQMiQkRDovAcMvcKhQMdohtOYPOG7wJqywA4sjFnBAPEDQbf7wBIcjDvSMBSsPEdiwRRsF/x5QatzwRkEDKAAOxukQWfRwRvcsB60Oh4EQrdQl9EZwpMTBbI4QrXIwP2ovyW0L9wwPyjUCQvbgkihwiA7wCzECgubBO/iQubqqPwLw524sl7jwDKEnhNUw/+dEITTyAMSbENt2sI5zIkrI5c0tMO14acp3EOMiIWgULs/nChUuDxCJAlfMABp00NEVBlDJENH9IhAtJUnlEQjgkQ/vMSJ+I3+a8RNzJVMBEWQaMJVGkVGahFNPEWGoCLru6JVdKHsKj1YnAg7AqwO+kRapJIkjERdjAhDq4Bc9EUqKb5hvAiGOTRhNEYfkZMAW8aJCCIDIIdgfEbokcVefMa2mUZlrEYVEYUAw8ZllAtyWAEs7MasScVwFMcFIIcO4AM5PMd5ccB4ZAhDyjBLpEdoqcN8lBF9cILHy0eV+cZM6kag6AChgBduDEgFwT9VXEX2eCeFXMgBwaSJZI/1opLIicwPLhAqevyrHiOHE8gyjZSXgSTIZYSwMnNH9iPJDsu8akwxobC9ltTHl4TJD7GVjKRJ+OhDhzzFYmCPidHJnUSPngxIMwCKSci1DoBHohwSXjxJY6SiIVIkp6wTKYw+WvQHD3kUZmJJq7SQa8xKWrSwrjyIoQTL6BDLqPRFQZmaPEhItExL5mjIWRzGryKHLXi1ppzLFGmZexvGRxuKSdjAvhwS3KAyfqyVqjTMH1kruxxGCFCmu+HLxrwQ5zoxcdyP/rCar7RM/IBKm3zIVyGk/TDCz+QQVVDN1VRNhqilavS6V0HNHukFVGBN1szCgAAAIfkEBcgAAwAsEgACAI8CDgEACP8ABwgcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYKVYbkC3jw3qkhHkcSbKkyZMoU6pcybKly5cwY8o06Q9Fg3UE2wlrFGWAkn8mVzjo6BGWjgkDUBzy53BZlAwNHJiAw+7gIaENJgyBNbOr169gw4odS7as2YSVCMRhKrAYAQIDCfwDSjIXgCp0L/55ixRujHpsE5J62yDDBbgTohFkZ2IAgQkfGryFc7ay5cuYM2vezLmhvwsN2OUVRuBDFTMA5OYdaYLANYy53l6au+zCADirDa5rAGCI6AHLMhCwkRe1A1hz68EBAMBX5+fQo0ufTr26QFi9V9cDPMBX6rkmDxH/oHxxBQEzeWERCJ2bIKkBDdoRVE+gqsALAP4MmDvXBADy1gUo4IAEFmigQzoQEEpC3qn2USM6rKAEcgPkAhxB6zxWj0UZAhBNYANkMEAlCkUywAerZQMXUQM4QAAs/vD3TxQAYHHgjTjmqOOOY9UjmX0HNQheQ9l88NZAf/gTwwA4EfRBd+09hJ0DufVUhULeNcCdQHY5EJh5g+zHHwoENMLjmWimqeaaDtmVQZQCCQlnQf6sAEAMHeXiolsxgDjAlUkOxBVDIgk0CAAoFgQHASsMedCSUcg3QDRPCkJQbA4IM5c/e10gKZughirqqNYJQsAQWH4356UAcDTQIHAN/2BmQYcMMERgSy4EwFoCUdYnrSeu2g4WUaFg5ASNODoALB8AkMEKE5zKIqnUVmvttV9RdiWDqjaEmg5DVtMqAU0SdAkBKOT1HqEDmWGrnyS+qVA9f0zQqkAokKKsL0MwJ5ADWJSL7cAEF2xwRVcCGGS3A9Xj3EDFAJUgrwM5MMCvBXElL0WU6WCQmYkiVM8KSeWyDjaXIIXbQIM1MEg07BTT7wXTHmzzzTgXjMV5fhIkJ0HY+CuQvOaZSNCSRhc0WMgT6WdCbnEwOmetnhLk1qRMtWOviTLqAEBPOYct9ths/gGAEqk6OBA7NiLJlNdhEmSepgaZiLFPDQlC13sTKP+7M9oJeaywQE82wlSDgMlICgBIke3445APSOLdBv2cEFs9uTuQigQkTVDU2wqU60KBTtqqwEkBYGlCjcVNkA23CRTKekzJaBcBPUeu++68lxV0A7nHyfBCJjIdd9sFeX2JRCCKuLpA0bz1WkKoDqGdi0aT5mGM/JltW+/ghy/+TLYtw63aC7HDWyRArTNBA1nV3CIB2FxUCQAOKDZAO7BbP1A0FtPfiFo1G4HUowoAaABRPgOAFYhmLsWQjObGR8EKWtAjlNFPQRpnEMAppBGpGYIZbPOHKzkAXAPxTqMu4g+PNUAJVTjMBKa1DLiYTyBKwlcVlPC9QaTnLQ4YAhb/YgCXDADpgkhMohIToqKNDeRJBwmdQiqRgXFFwR/KyQDTrrSuiyjHRY4ZQs2igRQBDoBeHByACfRVEGEQkQD+wsIDl0jHOioRVb5Y1UQ6csSCtMMBF9iQR+qxjGX0cSFM6YghEQKUdiyjGNUInh0nScndYaMBlGuJfrpYyU568pMzoUyhXNKOCxAHlKhMpSpXycpWuvKVsIylLGdJy1ra8pa4zKUud8nLXvryl8AMpjCHScxiGvOYyEymMpfJzGY685nQjKY0p0nNalrzmtjMpja3yc1uevOb4AynOMdJznKa85zoTKc618nOdrrznfCMp47aQU953tIa+JQPYPaJ/8V+8vOf/gwoQAcq0IIS9KD+3CYDFhoLSdrTlapQxYAkqk0DGCACs3joLI1gBC6gQqNksWgEciFIkLqSox41qVgs+gCSqvSkHf3oS7/CUpfOdJUolelNZ1LTku4UlDn9KU8N0FKfCrWTQT3qSyxKVJsqtZIcjelTW8LUphp1qkuMqlSxmpKqWpWrddTqVsFqEq8WlaxKFOtY0ToSszqVrRYUa0rh2taqnpWucdXqXPGKEbdela+9k6tOAUsRr36VsOFT614RGxHDHpaxu1PrWiHbEMcagAHLcChlcyZZTAx2swtx7F1BCzmxHkEUqPgsaRFiWAtkQ7OrPZhaPava2P8SxLJ4gK1tCSZZ1O6WtZZ93m8529va/tayBsjtcIlb3OUWBLnCda7BJMtR30pXIJZtqW6vKyrJyqEV3MWuYSPQ0PDKVqyEAK95Wys/815LrXIw7nIN24PtuhdUYpXDfQdAX/vuV0353W9//zsw+ArYq/UlcIG1qt/7DljB72XwgauaYAhXy8AORrB/LayjAGeYwhvmMI487N4Hi7i7JF6vhk9MqhTfiKLPNDGPcmGA5bF4IOiVr4Bg7EyvRqAYaeqBRTlwY4G4+EY6PiZTGeCB9uIoAkxNQZGNzNH06ii1SS5mVSOwpTNZdB4GIHKRtcojKKCCx8v0qgXWZIAFTML/AB4YM5mvbOYsC7O1arJAm08Q5hAvV607QsURUttjNaeJARadAjngzGLJXpkLRiB0M/HMo3ZYdAF50Ic++txoseYIFVA4QqTtDEzHrnlHeFhAm2uh6U3H+cSOvpEoQs1RSSvTsqfOkQcs2gFjtHrTHPDzbiV7hBthAgpatTUys6tcHCHaAE4gx69dDWuxQsG6BMKEqJNN6l6KNhfC3gxTMz1tYIc7ttbudmcIIQS1KlvJXmXAh3KUglWXW9OMFrFWj2DlAsmBuu82pmEZcG7NcMAAvr63ufWt1X4TiA0AV/cuB74jiypc0wN4NYf37dkCoQLSkg24luOdo2ZYNAQK/ydIwUmLXvUOiBDULXRVCX4jM1h0Eimfslgx4e9te1rmLG12gfRsAGnfe8pU5ijPH+7zn0+aqS0tEJSravRyI53Kp5X4ZT4ec2guuckE8uoCLHH0qyddFAHCBCYIgWxAS9Os5Z1OClJwcAPYYB6QqACry272qF5b62P5+BEG3/SoTpPS0bmEVycxjymEoOpWN/sA9Ar4r6RWFCCnLkcP/3UnZyYFiE7GPEY/jhNs4eIYl3xUF7uZf2ve7dGEeoWh84Avj34evKgAzi8u+aSb+TmCf/2c387UCDRDOhaFwO3nMQm9o773k1995WfCdeEbnvPFPz50LHqD5aOhA5CPvP/kkUB5zsza+tfHvki1/xwD9OH2pd9C+KcN/QEsofyaAXXhNW9NH7O/MwbAePOQDBVAbjlXf+QnfZsBauhnBP3nf89hcgYwDsyHAXt3gPUnWAu4f7FGTY5lfJ0RBxb1ft+XcBjYe5LFepUxaxzodOq3Zf+XGRY1DqUXBKinD/WHY4o1fS4hCuiHTZYFgpxhABCQDBhggHzXELXAcBq4dTAnfJBTVc+FfKJlRpiheBAAAReYhA1RAeXkdOl3GZLFBprxhPz3OI4lXgYQHaIVB391FvVmAL32fA/RfF8IaC5YGRiGGef3emiIXFLYfma1IJvxbDdwgxERAt3UgFBYEMP/NxP55XKW0YdnaDCAeIlp+FwWVRaD+IZmcWlIKH4QIQ/cxIg/mHQO+BX7hm2VgQmNeDCYGIuGNRBeFVJ2RYiYEQqXtoWiyE7oBwVcAIzAqFVtZ23CGIYxIVasaBZm2HWwGIsP4AEW4AHSGAHPRlTXaFfV+GwrZVZAJoMGUAEmyIULQTLehH6EIBBYNgDa1lEDQIlG8F0DkFpssG2QyGA8uBLNCHs2E4vk5Uc8UHsPIAixYAHXyGTYwBTskAK1t4leMV6xIG5FR4dK2AHh9HpHsHQGIQrxJRAsaATpWBBy4HMvAV+SeBb1yIGWKItMBXYGUQ9xcFbZwJAPwAA98CkD/+APcXCNXWFYLpkZEsh77WSKIekQIjcAZliSWkWGmVGPHTgwLFlVcTAvgeEP9ISTBBEKDbmGQ8VUU6kZImgAp0eO6GSKRtBxGeGKj3gSe2gZasmP2HKJDPAAdFmXNSkInigRy2CNluUSVSUIK7cSQmYAodhqQ/l6bKB2iql2aDcSPviUJhFVDWYZ7OaMcQmIDxAHoZALm9mZmOB5FLGQW1mLVAUBfXALmlF7Y9mLZfl6hJCPDHF5tAaXJGEES8AKFZIKZ9GOkFktmPgAoeAPwjmcw3kSMJmNpKkSdrcKwKAZiHaCrRlVRyAH1EmdRdkSqFCdtOkRRuAGA+AMk9ibvv9pVj1gBjuABT0QB5kFE8IZCuXZA6PJlcqJAqvgDOagR19Rd6wZnRx1bQRxkjDxmGvpEUewBk64ndQCkTnJFP3kFcIJC6PJEgwQAcGQk5fxbPvpEKR4TelWFvCYiiTBBrCZEvu4kp1XGf7QDMgpnyVhAK4FjhCQoeekV62IoBQRaZcxkgN6LXbVA3kZFkSXnHU1e2cxC9xnmPIkmSNqEry5oxPhBjhaGSmZM1AndJYRpLPoEaYgAgbAA4F5EoNJdjhoT1H1mpYhaOIZEbvgClFaFtVHpTW1GcUwdZmIEZ6AAV36o13xbMmQeklqBPwGoB5ajHkIEbuwC5/QpmNBiTf/c6KckQ0cEJ9MlRFcagA+ehZMZXTxZFqYIKhmwYBp2hCGsARIsKQeIaAgCpXkiZWa0Q4rGoiFxVReiqkGgKTvZG2NuRlOGaoKkWxkgQpOmqBmBZjRUQ+vCquNRWF6KhNtZquH6Xem2hK7qlZZsAsP4W6/iow86lfS4Q8G2WYrUKlVJQKmABFMJQJ90AcY8JWcKIfOuk5yFR2ztgRuUAZitQTWan9I0KscdQSJ4AokQhYCWjDxZgExCB3t0AMMcAamYAorYFgkAwGVxVR9YAqrgJtlYWnh+K4SsYTWlF/R+hKoQAnAsAtQqlVlYAgDUGwJoVVfkK+xEFFhMbAEY1EL/7VQNxkgOskIDesEfckQXgUJ1EANZoEHFrWat2oE/nmUmtEKzHALu2AIlnkQKCsQzpAKMvsVb5mqPPoAl/qlYrEMOmAKkICndaoQMzcKZ7FrEzmmt8oFBHILrpAFU2sQfjcoA9AKaCYTbLd5BvMAVjogy/AAEcCXVWUDVmC2sui15ZAOONSNbStPcLtjqoAJHOlzZZAIbpCAwrdYexsTzWiJKQC2ZeEPseALsZACdIoCDcsImIgBKEBUxEoW67CLfnqrHWkgfbsEt1CydKt5WeAGTEkWEOe3BlMAYqYjOvlsNtCwnHCJK9CwaABujxsWRmoAaOAEe3cRW/CxRuACDv9QAF8wAJ9LHeC1dnJQsrtgr5IFBYrgDM2pjuUrspnHtaRiUQUwAMyhFqR7GbCwA3DAC6vACA9rWQsQAYAwtNpwFlCWDOMAAQlnESgwABsqTRylAkfCI8/gDFKbgro5EHobFtWnraKCv0KjJsJZDuDgDGdwrEwGmmERAQuQDB2we247TtTlAm8RKzviDM5ACMEYxMA4vJ9av0VABPbLI5ZVAPcyKulQDhwQARYgxVRsAWbQZWdBY+EopuSgBmqwCDgsWSrgGKCCZetIEOAZeMVIBDMAKkt8wtbSDnnRoCpHFoNZAX2qacqgBgMwBwdxCtqUw/o7S1ywbUewA228I6r/holMTDb9ixENeQOQRw5zwMcG4cXKQA7S9AVL0IIXTEsjzFFszCOeIK5v3MQTd7S/pgyLsAjKsBBgDE2fsKa/K1kuQEvwSAQ5kANEUCCLDAGxy7Om4LOA2ABkzEuXJqattghpYMkHEctSsExfwFHBuwTqe7KSBQJw3ErHJlY5MANtnMRUaFFJ0Ac20AfHcAwosMhMhQJWELsWtc241GZ5/Gun4MwHccPIJFZ68AmGYK3HUMsc5QaUUAZH4AK8EUuDJ1Y7IAMCsa/W4VUQYLGrwAmrsApJINEN6wkQ8ABmYGPIjHLlpsnTRF3WfKjAULLsS829ewuKML+phKb7VgQ7/zAARIDE42xR52wDRNiwplCxW+pVGLAKvMALPRAKywpLtWsAykx/CWEMyeRzWfAJlJAFvHuotrALtyDQBioQqfDVsYSqP/cC0qG4BoAB6UwLeOrO62wDpsxSxFAO1btLRmsAh0iWBKEGgDwAijhMeqBVrjAA1EAJR1AGlOAGWaAHAj1XFaoKH+xKYo2MOTB4mrEAPm3KNkC0x5AByLVQD2ABy7Ahj2xHbLsC0KlMgOoKh6oHPhe/bKpWf1cQWftKW+tpR5ADOACAdtcHGV1VQ00Lz+tYDGABGzFMzxZteL3PHFUGVM25R/AJxwAMf51uIZtE+5h+QLAZZg3Mr4oBNv/Azr6ds8KksYR52sdU1VFFrwLNUUhQr4qlSzpqo5ZhCoxQ3xgAAZxAtuB9iU4Qv8JUCRaFx8ltTIfqCq7wCUvwCVC70lHFuZKpS9MarJVhA6tA0aZwBuTasGaNmc8ADsM0mKGoEFKAA6+MAcAUVYlwqMdwqG6Q1bvA2tQFBYQw47kUyqkozp/IVAtgBWfAsMO8ABV7BvvtY3FQ5PVDTBY1jvqcEOboS1q1BJRACaq9C19gCHK73gpY3UpUvzheGQZsAzx9aUPeeaI92p+0hrfrECeAz7skWYnNvqRKXbk7EFpeQW8KHXEYlYblte1g5qjUAwKx5A8Rzb1klg2XqwT/gbUwHdPIJh15fokQYAVWAAFm5YbJpGcDIOjOZH1LYAjoXaZ1vkRcJx3/8OgGbAUUbQV29VYjV6v6bAwmrhD4UMFO/np6YAslm6iAqpG7pH9djhmm7lhJYAq8cAymoOqXZbB+DkoSuADvaoECgQ8DcA7RTkzg9XrV2pzAkKhZ10uM6uiYSOEXfQaU/gA8wKrDFJZayLHNdO3Aq+KfkAW/10tN+uuXEeyGtQBTcAZmm5lJvUtTdwKQRxC0rkzurnl6cNhIoIK41LcSDux6/gCzsOxdgQNgsB/3e7QDP00HH+PWybS0VKLUkecLMOYXZQbp2Qz/zhlNQAIjYABSdr8L/7CaaQ5N7r4EndyhIA8dorDoB1KZJPwccdi8pRxvHmAN+7QO7vAb04ED34wDNcADJEACl3VZM4ADMlDkmsBmC2CC13TtZQC1051UBQIEc34m2VmoeD6CDYvsLCXeA+LyFjD1JIBoOGcMJb8AHPDyl0UCh0aEzkoOFhlN104Jh6rr8RjqXfFxyMYFiM4j0xogcegEDVvAREUxBFJ7xuDFc6BwebAAFUDpDOCF+BnRFrW92HTtenCoHSyPAZIJbFwDO1B4QlAE/ZoJOZKUApLnIqC42nUgz0kOmXxx5FD8eC/cBmK7t+uFHB99XzDNIOmp0IEKonDEQODJZaqO8zggrv9nvNYR7MOdkAaCDQF+g79mdHyQhW2GrAGS5L+WTR1/lgXC5dRVBLbfUVyQ/1wwmdQR2QAxQOBAggUNHkSYUOHCgykMPHzIoEc7hhUtXsSIMM7DE/o8fvRIDqQ+cmrUnCLp0VgyjycgvmSQUebMiw9B0sSZU+dOnj19Gmw1wIgcQoRE/UQqExUUI02dHinitCmQGTOAFIkqlQuqpF0TipLa1OtYhJCcPOiBp1Eosm0VWuAocuQpKWqUgTxlcs4cNYtG6qv18mUzt0ibPbzxsfBixo0dByMWSlVQx2RFMQ1bZIaMHFJzVP08g8gRqVCKnhbFtTJNQlJXe6U1KtIAf6//3ULcInekFIF+P5bsa1KN7r8f8zx88CDCMtsXzTwMcrNgHnnNrV9v/mwAMdXYeWLCHHbHwCKkjVCdUaPqDvNhpWLq7h2hHNfyd/JyZr+rgQV5intUYwAcUAKJnLv4mkMxgf4jR6CI9DvooRVGKmgLPiDEMEOdnMlPw5nAcq+pHV4YQIasmiKiiBKtEkugEI0wKjUN6avPQ4weIeYfG3UyYIv/PFJmjkXOOWiFEAT64SKPBlhgR5ukIwiDHaek0qBgqrQIFULaC2uAGmowyAiBiBgghx2IENNFNYUSyoijMuSiRiwT8geLXmqb8yIGDKjlR4aUGaBBKXgLFNCCkiFI/58BDFjHw0aeXDJPSasMKpVJEWotxPYQEmuGi9zMEJU4W7z0IDxLVeihBfy8KMABDD2oggoXjSNDDh7qM1JUd+XVQxBfJDXMNDHiYoD4vJPDvF6XXWgWVYFchEBFDbIEBS2MUQifizA47iUsTrVuAUh1HUhKZs9F1y1MUNwhByRII8sIKN6Uj8Zg02W2h4cqMIakQe2adiAIBoAgiAEWyak6fKqzxEf+9jQgguvaeQiCv/DFOOOuMj0CTBl2uBeppo5ggw05jq1M1C417jUCxORCeAApjCGng4Oq+6lhfSapIJl5IH5I4soOM6CC4lhGOmmZkp0KhwFIhHcs97ZCef+xy9xTGtWHOgBpkUFjVigNg055hWywtV1IGa71sSSJeebpQLDKHDohVwqzxjtvgjKdarMBomorRNMwIYQyxsKTU+8qOSowWj7MZWgahMQYIIQkt8j2hj7JgeBtz+e54SG2GHNI84sVRz1pVOw1ooh20SwMWCPYqFpqrFPHErG/tjhhALRnEnsYgeaoqCN9gnBinM/nWeWhxujuF8qBlMEZd+t5ZTrExWTfijHtr5+Sv5HICQHznRB5pQtCK4pOny1Q8Plz50k3AAPpwcd/2exX3h7Y2ru6Xf40FIpxcc53FxGbJEpxkG7cwVUVuYF/2IYB5XnuIY1ajEN8RC4BdrD/VKwLWexe9L+kJM6D9tEXn0AShDwgsAsVUQdGgiCXPHTABjfowzy6VavCOCR6JwTipMATQMe8iHb9G1YQ5QMXFZLkFMaowO8q8optJEUSH6lFFm9wg3GM4yEWKIzLFKREMtqIEJgBwlVCWJjRhKh7bjFhGV/zLJKYZACWuIjkBDIM9PHEVcXJAwYgMYkHkQViY5RjIuUjCvMAQT2deQ2LXjSvtqxrjYpsDB1L8gMcnEOKCyHeQK6AlOLUIg9b2IK4DECR/YgPkTbDZCwr8yv01CCJjuGSe+ZFwpzw7ZayZIzLDJAYj4xyIHxooUwWIbadHGkAPwKMKvGwH+MhcgDV/wNmNsdiSajkAEy/LKIRspCFEGFiY0TUZltwIxJy3MBg2FzINwrCDW8MoBQvFIg35JmTeXRxHn8xBgqKxoGkGIA46USoup5yBGVhZxe70AOXGEoIpKxuUwl1C1wWMImPnIA6PsGnT7o4jv+cggQnLYABejIujLY0Kb4Ep23StItPhAgITfhJK1jnUkM2cWcH1I+2JtGgAfyzOHmRwhzEtROKFU0xxrgBBnrHU6rOZFROyZAeQrSDR1J0J1u6ZFV3AimiGqQb9pkWg/hijD1dAlx4EExc5TqADSoKUWLFa0auGlPs5BJFXwKCV3Mih/Dk9SdNtRgHDVJF/UBTH8Z4CP9BBeKBii3AspeFQGYva9nMysWwn72IJcPqHdlBAWWY4EJqVbta1l4VtD1pqtE8UgtnFuQd9jkHtmT1TMfKjbeAmYQl7Ha01xZ3Ib6kUmllJBCwyi6OxqWJIIoWPX3sNiGwlI8JBuJYCKiUYI49HXTFSxDRjtY+zj0NCJ3L1/FeZCO6SeaU1pcoKIXXse3FL3n5NyXt8c+5+eVJHBhgnCktArsHseZvC8KqhVgXwDxFhWglJSesEuRFDw6wAUhivioFCFYYBrFOIiwE82boluAscYgxYpM8GAxLBvukimV8ES01dMZBRKw+pnCKPI3gxj++yNXYC2Tc4UFcG7yBMWL/TGQmCxEzTe4gZQ3AkmkRKWNltYiszgFPKAMTEzbu8vUgRt1S3eAi2sXIksMcS0KQOMVrZtlDOEqSqV4KbHBWMUyHjOc4r8ojEdzVA/n84NXtd9B4e4BT2YYqZsrs0A/WqaEfjTSIfMQJvDKmmicNWuRuOmuq0s3AGP0OPHp6vDs1tdJw9RsHp9rVbvlVhV+dMVcq9lKbmHVxY73nXF+qqWsLWK+F/dLnDrtUldja/XZ12wF0wBKvMHZLUR3tXt3KAB04KL6C0Gpqy5INDC12t6sEMWImeFldCOkAtCBqcZdRVFxqN6qsLUFz92oTAbpDDOOdyKVIet9Yctlwg52u/0b/W47l5bXBMySui1Vgy3gruMKvh3CJ54mOyq74vlUW7ozr5+IY73i3l5LLkO9IGAaAAHU/wruS7xsKfm25h2Jh0N3p7Rd6jHneUAHznGOoqX8hB7eTduCeq47kRdfPowzQPulwGemv3jjHn+6Yh1C5QDaY+rCF7O+sr8YA1fwN0bvu6jZ/b+y2ycUwdxff1Jn57MtaHeJk/XbHpJA4HnG49bhBd2a93Ox8X4wwBQ4Yt6Nu74Dn1WX8mnDEr9QA9AbJJBq/6Z3/ffK30TBxBUgCRFyeSrueu+fHApfEjk+AvxB9lUD/5tTP5JBAt5mm9Xb41mto61KvPU1UpfKVA/8xBGfNvX1uH/rgO37wihJ6/oRX/OtEnevMx8m4QN7BIIyg+tuGvmPebfnsRx/l/xGI7AWY7u67ZeTcLz9GTq5o4jo9/fkdPu7fHyGU3/0jpZ5/iFdP/PxXpGL2fyzI6b8HQ7jnG8CDWIeKKQ5yEMADzK8C5D8HPAi4QrnjY0D3k8DXir8IzMCBkK5r473faMAO1LX/IkGEgAsbCEHFGMETNKzKAxYXREEDsIHjGzgZBK1+uzAcNAgLYADTCS8efC0dNEAZTMEVFELjIkL5y0Ci4ZfikDzxS8KEgsEiJMGNqMCjCYJakMIp1CbnY0IHjAviEjsvdKkNNMOBMAA0sAT/zUtDvNIz1pPANZyzu3lDsdKSGEzDHmnDILxDCItDxstAOvTDP3SpPLTCE1yGh2BDOzTEqvq2MJTA5zCASWjEenvEhNofORRDA+gnEehDW8tEhGID9BPCa+OFCoC8GxzFdNq/OyyaChiuVqQqVDDFU4SAumJFWkwnW0xEFywaXaSWLuTFE/JFSXTAtKPBOhy4MizGRKK4N0yhSegAMjMIYnxGAWouDsTBh5gHWggBTMxGTIpDWOQTDKCyccSoUkRGB9wIBsAAuzGIPMBGdQSfveLEAfSAPUEDyDOIh7PHg0MnHOQB3yqIJkHI+QlIjDEcmlCFh1QFXsJBCnyJhUwdFB3JiVZoBYh8yDv0B3CxyJDUmIAAACH5BAXIAAMALBIAAgCPAg4BAAj/AAcIHEiwoMGDCBMqXMiwocOHECNKnEixosWLGCkuG8Au48N1AzZ6HEmypMmTKFOqXMmypcuXMGPKLNluQoZ6BXMNEmjGZL0LF9qNvLTCwYQVl/459DVkwoAMWLApLfiv6r9lSgbAmcm1q9evYMOKHUu2bMKtSQeGGgBgYIaTkQjszFhFYIYMbaNUXbiz7QcCAxz4mirQ6j9/KwAAQEHYrOPHkCNLnky5skJ2DSb4I0iqgQksUZ6erDehgdCLlQA4yLU5l4MBkRbmajvIn796cABM6DjQ8CACHxbvtUy8uPHjyJMrH3CIwFaCQpVeIvD2JBbYF/1dAHCIYKMBmhXq/xgwZPNAFAD+mB9gNVqDFYeEN15Ov779+/jzMwwu8uD06g+1M0gMA0QhjECkDJANQcIAYMJ8ETVoGmHtNDCALwpZmKB3AHywXlWINbBMI/LpZ+KJKKaooljVqAbhQP9BtMx2AxFAyj8ZOLDeAP40QMCCFQlCAAoGrSBXQu20VcxwA8DCFm/s/UNiHP40F+WKWGap5ZZcOlQJAeMlFKND7VxQYDv+kEKAYANUMZ8NNhJ2SUPRDFQFAUMYpAQAdSFUDwEAwDLcP5WwhWFh2DTwQT3+kMjYi11GKumklBp33XMIjdlQI2viJBAWbQ3AWkHXmUGYmQylRV6b812XZ0LBwf9h2D9RKObkQDoQMNg/ggzAWKXABivssGHlOVem1D2UZ08DwQLYBJ4S9AcAWQ1UKEN1CpSrrAXBAaZC0zYQjT9V+UIAoBvCBoAZ5EopHLHwxivvvBjBGZuYyRYEpUAivaUqR4phAWFzYVKUp8AF9VQekiYA0IAScAxBnQOBbpaNUexY1dyj9Hbs8ccej3cIpANoOlAuBYXp1K0DmYmyQYMA8CpFoc08UK3VIvRPO3eeC2Y1AgmjVK6CDuQokyAnrfTSW4ZGJb4ADpSt0UpdQAAs6/njFEgGbeXmeQ2tJdAfA8Sw4wA6APC0zlW1I0wuCy7TVjtKOXXX3Q4Q0MBdQDP/7fffgNcXB6tQMzSVkd8N5ItiLxeU1bEDoKqQjc0GtqM/ebN8kFUFxUGADVO9ptjoo7M1buCop646ZCh/QLLJC21lcxW0HZSBrhIRVk8DgRLkpGkKcT7QOnnfWJhhAm2M9OrMN+/8SxUScJp/+Ta0zLm3LpMZddMLxI7D0VK0VQZcr/MWpk06xWhhsNQzVTQmEGD2VLMKdDTJz+ev//4T5ZmuQPVQzEHQhxAz6C0rxSPQBK5jrQJhpB0Nc0AUojABB3UPFm1Zn0BUs4IhoABQH1hHY2b1j+5wjH8oTKEKZQOAggHwNQeBHEL8MQinCGRw7KjCBRYmkBgA4EAYySHv/wbQgCrsq0kANI8/dEAxgUwADu4zyKxiY7YVWvGKVjSBgkpytoNEgwArwF9ETtM9htQDG8WQCv7qh8U2ujF/uSAAwmASBdy98Y54zGNXlDABILkEGxPImR4HSchCGvKQiEykIhfJyEY68pGQjKQkJ0nJSlrykpjMpCY3yclOevKToAylKEdJylKa8pSoTKUqV8nKVrrylbCMpSxnScta2vKWuMylLnfJy1768pfADKYwh0nMYhrzmMhMpjKXyUwVteOZ0IwmmpqZSGtY85rYfCY1ucKAbnrzmwyIQ/i2SUhVmPOcqkDFOS3TClwa4J3wjOc7e0BOQhrhnvjMpxFEgf+KesZEngBdgBnG6c826lOfUOhnQV8C0HgywAPW6OJCrXhQfCYUOaq4ZUPf+YAeaFA5DGjcRC1TUSNwQaHHyagtN2oAC/CoPgZIwUiLU1I5tBM5KKUlSz1wn5jOlDgVPYJNk5PTWW60o/Z5p0x/WpmKXpSoGgUoAwZKn2LAc6lMncxBT7qcospSqqGQqHHeOQqfZlWr+vQqcQghCpXWUqo9ZYA4zHrWyBxUOagwgjqj6lD7rMMAC5grVuv6mLsS9Qh7Xak8GVAfPLwTEoIlrF31qRxCJFStsITrcjzwzmOII7KSLSxlkUOIe6ICs6/UbHIY8M7PfpauoS2LYY0jB3z/npav8GQsctrxTgy49rWDje1YZmsZVHDhCLZFrStVaxzWnuG3wBWuWYhbGS6kVbmsbKhuj8Na6EZXumIpaXFEcdDb6lS7yWmtd2ELXq+Ilzjkve5b0WscqxrABt4FbXu/8l7LsAG5+TSvUelLHDO88xH51e9+u9LfyRi3ogL+KoErYwH15pcaDAjugmXS4MiIAgoAlu95mTuZd8o1wcfogAE4sGH3VpQy8S1phDOrXQ1HxgArSPBnrdCHmIq1xSspKSawC5YYy5jIpzyqR4ljAB1/dgqTWDGQOXzQI4hCFJPBREmTK2GAPgAPP3ZMd3V8jBOsgr1TDnJFCVEZLW9Z/69ILuVGI4ANy/DWAL5NMC8wAIl5SDnNLhFynL0iihAfucvyjIAfJXOJdzpBx6PAAC/m4ecUhBnQIxG0ZDBh6EPHcs51nkwK3gkMJ0OZ0n5mMaZZUlJC3PQxhOi0p2kMUDpPhrVNdrI4OpAMVKN51SYJ6pAhU9o3B3jQowR1ZO4MAV2LAxIrQHWqga3mgw7bMXIQgrGPjeh42voxoXC0s+2AgV772sbUzvSaXz2WB2+b259uaASm6RhSO3sUJxiHtKedbpRUlAuOQQWI3w1vWufWAte4tFcs7OQzMGLfle63v/XJBmS/JK8EL3hqHdqDMpalGQxHcbkh/meJlwShqf94jJEzPuNWyvMBuSDoWOLwWF3TIgKTgHjETX5yfB6Bq445bsa5HG94wlzmYalwrp3MiQgkQ98QH4Cqea5ufAKdLAKX9btbvkovx7zegHW2OE6t83kMAN1Un8hWLc6SD2t96waP59HLko3ein3sOS+71NOekX+zXSUrH/o9i/7yr8/8nXa4+yggYO6on53vGPH7WNwseMr+nZNHNXzSO3v3M/C67GaXusIhrxDJh6XYlR/txr2OdJmwNrBip4YNdAB1naNBIB4QI+lLv/awyOHtgie83DXflTvn2dm82EAfQD+OFQRBH7u/iOm98t/UU9fl2o3F6FeCeMVDYBWgT0b/BQiS++ir/aBy+Iq7ra/61S/ABitYwAOoChYDNFvsnm88xCeBgYJwYPvmRxD4tAR64AZD5RWox374NGAGYAWmYApOEAgAyH3352TUoAM2UHsQd3sGUX4B+BD59AnAIBYJyH4jZgB98ICuoHstMQs152THgAHLV3bjYANBcBD/94EOoU+2sAtiIXQKeIIGIAKMwAjdARY98E60oGuRlnc6lwz9hxAeqIO8l0964AoDgAqtcHkYsX4myIAABWZfEQEhl197pn/7xn8KkYNUmBBbxk9ceBEfpoBGoFgN1SsLZ3/3hgHgV3a8MH4KMYVteBAlxU9cUWh0WIfz1VBiyBUL/3Bf4/Z5ZSd+tbAQbDiIBvGGcVgRnJaIiiiE8YSHXFGG3uUEKzAOGiht/FcL0BeILPiBhbiJFFF9dIhb8tSIM0GKrnUMIrAFqShtkNABxtCKaziB0ReLM0GLQbiId8gVfzWEOnZzTlh2FUAOxOiKmEiIyBgTiFiLzMiIxpgR4WYAiZdgdtABkwZ688ALIXCNxZiNAvhmhggTnbiM3+hlQBQTZOhZCWaKv7hvtYABlegQggiPW+Zq3Ah8BKdL2mUBUxMTD7B00HUMKzAF6hh6EnGJ8DgAwjYT9fiFuQRQHkBvMeGCEulatIAB06hzAnECElGQBqlP6eeRCtlhIdlQPf8QjhmRhAawhNBFDRGQjo5HEOSQkTqZdhU1k9w4dMHEUjkpE7lAirI3g/s2EjA5iDUlE5igbRnXlBv1lDEhCCf5WSmGBiw5EhqZjVkJE1m3kMLklEdpEUnoXdJ4lgMRAhdxlW1YU+zWEgO3bcR0VNoXE0rnXZJmlwLhBBiRlpiYlH3Zdl05TFJlAaEGE48Ie791BhaJmB6hl1R4UIQgixFBeYAZmInmcSthfN6FBh3wjxiJlnFpcuUVEyVobMUEUC4FE3jwiM/1WxeYgXpnEp6pg9e3Er/HlKYZT7nJUAZADd61AmapdzYwAEUJmxspEMWZEv9Vk4N3TLj5T5j5WRf/6ASgd52s1n4rgQrcuYDeKU/L2YJ6uIsiEJ06p4bmmRIIdXHIeZuJNpgtwZOlRpYqCXpoQCT3OXFWJ5oOcZxumZwm5gGVyRJkeJI20Gc6Nw43cKD4mU8V9xK1FZkOamKomRIMJ3s3MIkdoKEIik8I2RIf+m7IRGIsYWHJR5X7tgqAKFzE9Ynx2J3D5XPXxhIvapsptFED8U4HIU+QIaMqUWGYyYdllwdRqKPilU89aqVhAZou4YVbpkIsZQADoKQCYaRmMWErcZmuhW9l1wcZSqVM2aX8BZqPeRJDWpr686V4SqZjsVHbpRJ1h2e/RXb7Jn7VGVueyJ4MVmVBihJc/0qk+5OnkCqmYsGnLOFYBtCbruUEK0lpk7AF7khYh4qoM9Fq6fmXdqo6kZqqeTqpZmoSNNec3mUDtABxzTeQTBWqjkplcpoSbgeiqaOqwPqlYQFtTEoSFeZdv5mK4+CSZ4WrDfoSn+AKeoAEQKqgBtGWz4o6waqqEHAGVvCIAPUVDwgJUhWbDHGsrnUKVxADW6BzU5AHE+WsW1YGlGAIwPcSenALwGAL1MqiKmFdRnAEO5ADQACnfrOtCPtOZ7AKEIinM/GAPfZyHZcS6CoOwDAHL/ADtDoFJ/Cp1CSvW+YKu7ALbvBmLWEEZTCyriCTKdGWQDADM1ADBrs0CZuwff/gCQ3rsMy5AjYAAdrlAYtmrEuXDBirsdK2rJ66UKkHBUzbtE77tFDbgyTbrzN7EvfkBnqQBeiXEgD7sjFrkx+DsA/AAGNbtmR7tmabtmdrAWdwBj67qi4BqQywZCUBcksXDrVAAtM4Dh0wCR7bTJX3VBYBsCarEtvGZiYhcPgEBDtABGDbMWK7NhPRLtmQArgmrHGLpw+QAiNqEa9ajuLACxHwcNLWB0lbUJUHcB6hjI/rEcaGuCbBuoWbNGJLfBXhD+3QAxGJuS2hueJkEs/4W6IrlJRGC9WotIIHBSXBoK3bd1t2gCRhXNx5sAjLA61HEXjwtiyVuSzFAOaKEFH/CV2jQJ7SlgcVYAyom3pXhxHtFGuzG2wldQSL6hHum6sgU7MGQLcj4Q+5MKG8S6Jf6r0nIQgMAAzj4FqQQL6U5gRt6k/vdgSEEMESHMFzehGk+WJWu2XzixGqEAhEcK9ME6kZhgeNQMImjAciRRKhsLvby30s9QBY8L0GYbkkIAVz8FmjEJSoNgk3UKjk9G5QMI8sgXHvW3WgyXUXIQMzAARaR715On8yJ8MHAQ7BcLl6CsAN9WUnEZEPIAVXIAXiQG6NB4XomxE3EATyYEtAHBNEXLWuq6hIbBE5UAMzsANHIGshDKkPcAnXixLMwMItjMXxtAARUAxSTBDv1Gxz/zAHgHADwElpySACfjsSaVxL78YFFawStYmeGWEIinoSAgcEdPzBeEy7chsBsdAVzWABVtxQKGEKViBVQHvIAhGVBqADu9gB9DkPOGoJf6tM76aUWmmyPugRI6u1FoVlJjGHAXvHGAy5qpphQSsT7DBq/zsSx3AMscxxHzUSSpimA7rDwvjLECEClpxxodkVqEAIXHlQIjsS1AAMS0C1mJDJnAhgzvzM9AKsHdXHKZE1YvmlNuAJ3swJtEALSfByYmMSHHBiYVwBaNgBrJgRlrAFtJRxEGzPQ7zJ96QHfacHwHAMwJBPVkanMArNTxwBEbDHtGwRAQ2pGKGwDKticv+30CQBBiQQAjtmA2iIBqeLEZNw0dsmB5hwZdbKiW9GtRRxT1nQg59A0spcEkBgqtkJL19qARXQTZcQC7HQDC1tEdngAa0cyBMRTyKgvRzFA517ESRQAZ/FADqnmCVRybC0ZUgABECQznHMlhfsxgyxBPiUBWVAtUF81APxBkXwdqbcUBxAAo6dyo9RD7obqRRxBl/6AOL01QKR1aF7ApxpEVNgSy5QUjswAwLhVqftFaclCnJACIRbUktQzG6YsrtACVSbT0GcEm+Qz5y8zxvl2DjgB7YRGZewA2bQA2MtTx3ACAzhaLxwDGfGUpl9ErzFADdQl1XpES6JD7XUAKP/fVA5ABm31U8cbQRLQAnAINuZaAR6cAwDIM9JqRIgVspJQwAF0FAV8AIcMRmbsRmXAMgAtbCmEKYIAU824N60gNbyJLkk0WgG4ASQEAG14Hjwuk2A4d352QR0QBl9fbUjuwuAvWVuMADUcAzIzLKgDIRVPS/2/XJgptkrEQsKHk9T8IBOkKcQgLOcAK5eFggoQWqjIInSRgsjheH+elqGnbgD8NqBrbK3fVBLcAu7YAshjttCPBKK69cdcy79iRz1kNzv9H428E424AQzDk8fYAMYcFSiaBKPNXL7Bq9lPBBzoAbU5DDfbQQtOhApBxmye09lkLXsbQgn7nNH8AV6//AFB1XYJxF4vb3lA9DiHFUMXp7cC8DjBoACD8gI2/oAkP3jBiDklDYOcm0QUnAKd05E3x3VlSG7S3DHyEXbKzt0rF4Sju6jfsPlBoDZyfHlACUCnuAJK2DgD8gJQxh/qcoDLmwKg2rORDkH1KkM/tQAQnDllMG6ibALrjDP7C3lVK4HZbCeST4Qt44651IAMAfjLeHr8nQGEAtPC+BwNtAHtLAKlh2p+nsS76SBfxha426cJC3lu6AH94QElOAKhuAK6U3wxnYEgKfP8VIAgLEQBLAAfLwccdDKNmDjANUHz00LnC63owLAwHi+BiEJ0H5ME58hAtHnxKGMn7ALt/+g6PlkCyQODJ78ZrnNqxBPLO9UAAKEEPbNABJIH6HQyiIgAg3FCKtwDLSAAu93BkrfkA8J6qhWCx3gw8nkg/OsAgKx8gbhAsrBoEvgBoVu3vo6ALcg2PX6b7W+zCsuKQ9oCtoL9EJ/3w9A6fVRDBEA5vGEAozgtgsgAg/oCVms1uouEBG5AKjmBL68TFnw4cisAueCEC7w9sVR3h3tConw6iI7tfmkuiqxzlCApT6fBH1gA5gO9KFSIwXAABGwDIkfE9UM4Bu1sH2g6aZg+C8nTv58EWGOauMAAVpvTPdkCJ8wrfjk9WAvEC7w7zHR4fmUBSKb8CPL8PckzClxwcP/Eql27/oGAFH6UQ9m4PeJzLCmIAJJgAbDDgFq/gAPYNMoYcuejWpoUOrFRHCUv/Lebe0AMUDgQIIFDR5EmFDhwoGijDyEGFHPrl22ynwyZIQLLIYdPRKKaMTjSJIlTZo0kFLlSpYpCwAQSKBASjP+Tt7EedLfpQctWUIyxQmCygWQnCH8lxNhDwYG+syDOm5FEKVVrV7FmlXr1gEhvYZUQYCAQBdGRKHimpahKChfjXyh+AkiG4HM1BKUE/LuXq0QFvgE7BIAgZU7bPJFbNBfrAiAH0SwoGNDBMoRPGhLmPQqy2RRJ1VIHFr0aNIej2Rx61ZFAwdlzZa+i8orF1Gi/zANqJ37GWJUXI7ohR38YJKgGAIfT8nAQzbhiOP4fBAqVq5YvmIJu95uYD2B2rcaYLBgwTioyTpMMZZTXnP27YUb+bTr05LUqaGIcp8VVVuIclD9T+U/AVvhiw0uoPgtovyEM4ARU0xxArnAHujBuwW3em4lBiyI5rCBPNSMoKRCrKoYA87ooLN5VqnAkpFwkCI90Na7sEYbr4ooC4qAKaO+r6BA60alCCGSSOFQOSJJBYVEjCUrHhRBQsA8YDKrYuLAEks82GnOjJRuIG+eSTq46YSBaKwyTTULCgkJV3ZxhT4fQ5JjzZsEbA6TBCGykyvARBhKSp9S8LA0DyyADP9RCxaFjEqs/IEUUvYacwqqeXipgByF5lAGoRuk6DPUNL9aoowlkJiTziBFPUkV0jD5itXNBKUVvB6Cy4UDDpoKLAVZGUppEkvn6aAWfXJS41dl2Uu1WSPuW1U0OnDLrVq+UCEQMUL2XHLZk2ql9QEzuCuthwpIgFEcdddd1wBfvT3IgAWGpeWGYw+aYqAR4OXXPWdTBTK4GnJwCz+uqBkoW77y8qrfksAVlIFQCkUsBV4NsADdH0jQghZg2BUnJYcHSsEACIa9wUWDkgFNGWM6HcDlkWdG7N9UjzA4NLRU8aMGGQaogQhuX9tKnIRDYxg4mhOCmFYGSGOAAQ5CqID/gVpOmUMKKX6woYMVqFk3SgOY65fXMC8F7aAKTjkTnwHQXDrurGxuNlq+/CACCiiK2EEGGWbYYWgu7LbqqNH0VFpug5p2ei8SHmfp8R9qsdSYOa44BSpGKoAEbHHsSCkOflVScR5I0lY8ddGGpvtHwu+aYQYgEtwh9tm9ClhZkBJXXSDGBX0AD4qzeuDxEVRiIAgp1FCj9HmSMeZsXpyoAIIVaAkZY3hTQsPSKUJI6Jzex8exdR9zT6uGHQiRQ443Xvh7hyIgAkJor5KEVlaHeO/9dykj8IVaqgEeEowgD2FahBpgtIioLIKBljrbPMaBKTuIoylPW5a8hDUOM92L/3wfvIqSzOejwd1lBztA0BGIMAO/zUBoRMiB/H5ThPl95Tas2t9DPui/cC1DLRkiwQ9iZKlFzGEOfEBg1jI3jjmoIXPDSsYKnEAL4xhgHcpKSWfQkAcQdtEqI2wWIdSCihwMAHBGUGHsZFCE3+Qgdjswwg5qEDS3iFFUORRJ/1giAidUkYcseYA1hpeTXMRBEI3hwAhwkLVa/MCRWxDICSBwHiPO4RTiMIYapDCHCEKlDzeYZEqEJ6uUQIVMXkTlTbziBkOgBowRIYTCtCLHN84RCDmowQBQZQQ3yu4IvYRjHV/HpByOryUQMMUqPPGXP67kARaaVUosgIMfzGERfP/ggBB/YIlkaEofxpjEDUZwSQlWcljnHEcequioUFnAZJc6ZSrl6RGv6AgYtpDTK9F3lf9g4m8ziGHtZlADPj2Eb3A8gkDt5xb/9AlxOkydT0RwDIr68Y8b8mFW/mGyDqABa2qYAy1Qp5AHQGAAHdBBHo5xTpYmI0Ii6xOvnjdSgtB0nvL8ihsEcoxTvbKEWkFjEWLnQpH87SAQRSMR2EjCYdaILRCNqE8wQItj0OIDzTTAA1IAzavIwJ3CmocDzVMLkpDDEnnwmoqcB8WWCMmdKqmAmDBwU7oqxC1fOMYAgPGFV7KhqTmZX0Jj+JAjjESE5/urezDBH9UdZwEOYgT/M3n4gDjUY5A5ecHjwGopXtjLJPrQhyUwsIJJVqAPyRhHalU7jymYLFDVsFFT/LIF08WzICqrK07dsoQ3ueKVdeIKClln2K7MCX9c4AJwF4QJ5CaoschZAAYk678HXOKyJynZAjJGAj6wdAtcPIgHPWIMtGKgAh2owHl5MVM79CElzbgubJpig6ewTFMHmURuvdisJXxhl+az41ZqAAQE8U8ghU0IggWSqp8q1sCjw6rTIrCM+JaEDhdbWyetgBBl4OAkoAUxaGvRgRuglnpoMEAPKgw1A6wAKlsUL0Fwq9/xfYF1r3QLJhJbElEQiQtAWGq3TIIEgqSKLvnBhBCE/zwyG0hIBGd4aa1EsILpatUaW+lJBTYLQTPxBbSf2QJqUaziCzUFrB1ID0LyS2Py+bY+WaBEInqaqiXowZVoPItWRHEEGg5XLSE5gl/dgwpY8Wlpo1iBhBxkikTTygYPsoJKxEWurLwgiyzFlEJAhRXQkkOdnUnJxPLTg1KOYwo3UEgewMtm1bk5NZSgSEZS5aZd3AI19+FKoRuWkJ+94CC1G0lIoCDLIxFCyXmkGSSifJxFN5lWU3iQe7MaCK5UzQBbLk8FyJqQNJNkBSE4wQkgaYkYD6AWGEhGMlLyLvb0xACdmcIW7osQm7I6bmW4MWFhvQtZz2kJFNmFGwa3Y/+T4HHXxEU2SdB4BC64x9iGntk/SoYcJ5whCVAGFwYg4QkqTzgruViJ9Vg6DyvkodxKEZ9Btj0QfYRTgixhJ2lSMp7antzeIExFvo1wkURQghJL0HlIEiEfvxK8JLtzi2giss/SJA2qM5t4YFDwIE5QlwNkwwoeDKAualRgrVDJlEnm6hEadXsgxtBHiqAyCTRUcQGkGaC8oOKEG5DD5jcfH4Hq86aAB52hRh+JrlMzGogctqGjYcPQ4hZ1wEw9KL+jEKWx4oGti2MK3WNpOBOzHj4UZBKWcMI5eTFdAyQmJRBY7xaCcHeBmBTvitN7avjuBroRAvCBP3bSSeOWhuv/jAsP7hfjAVNxsUEseCs2Ca/EQYsOdHIefbAtYtw2gOkPgBwQcP5LmQnbvRgAA8JKBgZY//rexd4tbqCEIfwOaB1vpTf1CY5boGCgAKcFFXLgVuqE35IzrCKyTYuAYkC+hzEZdekAWmApVKsRTAOl0BnAk1gHA0DA51s18kMl8/OKMriFW9CDfzmCG9KzAhs8ZomIBDm8tMA/iJOb/Qu5BzEFFICYCXtAkmgxcTgGEcA8KBKSkUuGM5CmtBCEUoIKBVwIEbBAucHAkNg3uXAWKEgL/tA9f/mKBtuK33u6FUQOB/GEQKmVCMCGGRwJA7ACXngAbCsPNTmnPmCmgsgF/zAciFBIgRSglLPpiLE7wqVJQomINWc5AifkCh+5EWG7PY94vyvEQsciraZ5AC7xkyHAgPUauSmgijQ5pw6ooisKheQ4ibdKjnNaAYYwhuq7w5HJw4gogx7hw/bbijkJRMLqwzyrClSoDShMOMVhwYuyAPhKCzE8mZFzAnlbEyjCANDBmNODqTCUlwqAxGEZB9cbxS4qxRFSxVUExFaMCBA0EpNIvFjpnVukLh7gKq0wgClggJHjhRCYN4GoN/c4JytwgmNQCXXRAVqBABswjgU4rZHLAzR4Ri+KRrrJn7SoRmt0RR1jGDkgNoUoRG5UHW9kHMqyrLswABwcuS2YhP/xWxB0moITOIZRYJdj4IRRcAIROAGSlC4GwAAMgAAI4ARaSKaRiwpnPAi46UdSLC59+o+7GEgbcYsEOQIkoIRboIQDIUooKEpW2AUe0bnxcUjA8AvHELW7ADnsG7kKMLsBwACavJDMgwDsYRdq8Bx1sQN044U8mAJIQC1qcD6UqUCCmMSaxMObpDOgCwkqFMgRZBIfgYtauzNA47t+Y0j9A5dH84TiSw4LoDA3JAlSuzaYdD2MdI9TmgTpqQBG+Mpx8BwbsAHnw8y1lKAV2IKTMw+4jJt/9ApDuAVb4Kv+GMSTEDzgu5D6WIJbqDW6/Ao9uIU4+a+DE8xa6QNIc6b/rVJMknA3RoDJeWCV7xoAZbSUKJoCkLFBijxOmGQZkyNNEDLNkPjL+eMC2+MLpOPNUUmNL9CD1Rwh8mnKlnCCB1kBreoBHsCDiJTIlFhGjVwWLRuWKbCeM+iD9oIAM5xOS3ECclMIUbzOfsnOiBi6XViDhFQLOaBF2CTIEly/nWxIiBEBDIBIf5BPAZq5r4uKLlsWG4CAEdCCzhiHZICELUADNADRAB1CY0kIrTxQeElQiECCMniDVnBQrki8fBMViCCC28GxJbNFRYSF4TQJL2kxSIDJTOMXZdiaAbACGLVSuVq5gjCBGo3Lf7G9HtWK3jgsCa2SN6rQZvmg9GSJ/w2pBiUtibeiBqpkqXMzCBrtk2TZAhsYubVMUZaihRC4AbTjUvK50YeIpcR4Kvj7lRk4sCI1xCOVEAaoDHB0U5JojAUQhzOYApgUgSzlF07RhxPIA2bsAwiogBwcBzSYpA5Ay3SzgRAwFsgcVASVy6+Qg9wIDYOLQmVx1Fq8UOSgkGZYhmboUL5IiUyNgbVMBhGQVVHRB3JYgSlIhlVAgwqQN3JwghBAgy0QAXn7pi1AgRNAAXIDrVkl1FoNCdvLycRYSLxcliL1oqZ8AEHgDkkRDfrEAM/cooKw01/Rhy3ogCCYBEE1V3uLxiM4VNKwQnf1ll1lNYd8gFmQPNHgFf/Ug0nouy9yIJN+9dcQK9ibK8UPBNO7SFSH5RcjfVjA2JBmgI12OD0ReNFJENGPpdlQyUNcK42SNdmaZRIWfABwDA53soEV8Mx5sAFPfb1m5dk+SUKmy9VUWdo12T+IFA53WoH6ZKkVuMrXk8motVG57D3YeE2G9doaEb4HSNLmSIm4Os7w21oLNNCyZRXzO8HSGNudlVv3iDo2rVSlMJGJ7IDjxBQCFQiOzdvD5YvYI4ScydkIxVvEbY6J+9l26NuccFkDGAVeEAGY/IxkEC/DhdzQ1Qq9qz+7ddzAFN32KJkNbQ4TEYdRiAAAnQcUINjUtd3EIBBMGFnEON3wvF3/4bCYUHAPkLMDteNB8fvd5N2L3WXX9VPe9uiBNmwPrTMZzxzN58XerWBexNBVMs3evfAHHogF1U2JY5iXPcUApP3e9T2J7d2L7vVe9k2LOMiGylWKY4UEDIBJRghN+fXfk+iF1syKu/Xd/+ULe1VbGxgF42WpE/DUuDXgCHY4VpRgEDIAHegArOWsClDaCvZgnUlBsv1gxZlIFxu5z3jbEVZh2Hi4x13hkckGkwHQcbDKF7bh4Li/3vXVG3aYDNnMkVvRDubhIVaKhUVdIoYXC2gKEx65G1BfJIZiftLhHY5iWeEVdINJfhTiKuZihGALv+viX7ncqWJiZiTCMEZj/9cE4zRmlZSwg2M4ATMMPzamY5J4KBeuYyE51g4wznNKhq7N40AuiHYtYEFmEjcOvax9YkMOZN8QYUauEZAzgD76OvPYYkgmYvhVQUyuETNoCloYhRMYuT5oS06u4ySzUFPOj6Z43UdkqdNRZUG+YzyOZdg4VuY8pz+t5UCe5ULe5eDIEDugLdHTtl+u421RVGNmDyU2gGPA4mFRp9pV5i7u5fid5rtQvj4oY9M5Abu75jBG5kf+ZsQYY3FghBPoJDS4yHHmYghNZXZuEgOoIGf+OjQgXHgm4h99Z3yWyGMQyxwclhWQUX7m4W1xXoI2vXV5ZmbkYIQuaKh16L2QZP91sYFEhiIUiOgbRoVtFOeMvgrGxB40sOhh6YA1M4gZ82j2dbojTmmscLd1kdNhmYTVUwjQbWnIJWSWvun7LUCu68VzOtqa3mns3Y+DHmqrSAkbYBde0F8/hoBLPurD1dmOjmoarDx1GQUIWIVzYpGEAOSqFl2OTmawzoljFUsGjooaJmv5FeuxXmuSiEADUGobzNfM69+3/t79QFO8JolASIkzWBc7AGhLcWK+zt6ppmXDJoiJC0txgNmRU2zsXSwKjuyOUL6v/OlzGgCoruxBrWad7myCaAwMgE5a0FNMC23bBc99Tm2BYGXoHIUbyLx1bO2o1eu9rm2D+AvofN3/kX4+8MltxL1t1s7t3QYZaojjcyrs4D7c4XZr5nbtq1YXpu7jYRmAFIZumnVuqk7ttwKZkhs5G8juvNVka1bsv8DU7wbQ8ZZbxE7syO6B6ILOY9iACRwWXmBvryXg91ZsHpBurP6+2c7vqF3t5w5us16XUVhoS4EE4B5wni1w/lbs0wMZRhhsqLDIB+fZ8kbZ2pZkHYBOwYZslNZwzz7T8QZp3kYDJ2UpdS7xgv1sCX/rl+ZtcVgBEB0AEn9x0mxh3D7w9OZtpl7LHZ/Vlfbx2va+Gs9qDYaKATBpIofLVmhriA5uqw3yBbcUgSgWKD9QI6bs4EbvGm8vmDwpLj/QyQjnbsOOa9KucYE2RzM/0BA+8tQOQnmucXHog809YTgnTX12luC2mGa+8430zCfn8yPMaSpvbQTn7TgtWn489FEUQZs58P8+7qaGSdqOdFab9H/Jbca880zd5izf9FHcbkVPbRpvdBvQAc8s9TtM9C8PbcqDgFBfgaegzle3wC9undx+7TuvgKJdCE3XdfIJZ0pP7WZgHN0uiNKTl9Ir9g9ylYFQhWq39mvH9msniGkP7cuFmGi3N4pphWwn92yP9H8gEXBXd1QKCAAh+QQFyAADACwSAAIAjwINAQAI/wAHCBxIsKDBgwgTKlzIsKHDhxAjSpxIsaLFixgp/ttIkB2pZRkRbvxXEBaskChTqlzJsqXLlzBjypxJs6bNmxdHkhyIBYCvkQP8LauEZYiSahZ1EjQDIJe/iTo3sss1SMkQMwmjcgxlY4KDFZGeClSKs6zZs2jTql3Ltq1bkRwHRhugQ2kDAHjxFssZV+C6Bh/qSdRKigBeAgQ+iC2odaMZxBcyIB7yNOrby5gza97MubNnh2QFDiGQSymADEoG6eXbd0BPUhEt/7vUAAUWJQQyHGz8LxSBBrCeCpsAYNAAy5+TK1/OvLnz5wOBDszWYEJljuwE+lvNmqAwACsghv8e0K7exkqJd0sX+IFAHIKkADio52889Pv48+vfzx906z8EwDFWa9sBsBdcZIUyBApDNCLYNXCcRJBk0Sy20Hg6VQKAYgatN0A0ABCwzk5BOUAALMj1p+KKLLbo4loeDrACABJ6WOCBHWpVz2i/GabDAHCcSOIAVRT3UIzHnXdajq1pmEFrQwAAR4ovVmnllVhm2ZCH7SCWXZJD3qieVkxlAFI17YWSwXxDRkJAXSMJY1AjdNbZiITRnZceYx7CAUAM9RHU0xBUamnooYgmCp2HwhAwQZ5hcsdnX3/RGKgvGxIQRWuNTqBTkAXlhdcAAPxI0EgacjgpQUUSOqSANgz/OKSitNZq661neejbB5ASJCaT8AEwgXnaEUdjayASUN9GvhwiiLPQPivtIcGdqqRuTMalBJF9/SMIASjIiuu45JZrbkYeahieuAPdaJkwvsQb71N/0DWkDvItS9A6eK3jn4WyosdrtiMVqQRQG/0BHrvnNuzwww57eAm4vbarl2XG5sWOP35uSpCfVXiYDV7t+DcrmKkCLOtITME5IBZvMgzxzDTXrGVosORWsXYXKwUHFkADXXKQhH4MwCEeLgNAAzoZV9AEUEc9wbbW/uOkQjo1smFcG+FmBm82hy322Pl5CGIDYtkoadUERSLjkBcAEHJrOX/wKQEEiTpqqVVb/70nQ5gOQN+Aul3C28lkJ6744mzFSBxIYPq69s4DFPPblwPkgpfdrcVBABZHepjhhiof5A9xlXgXor+RM+7667CXNZ4SAKTeOs8GjrnTRrxW8ZQ/MxKH4r0EwBY610A5meIFE1wyoGoTYCMQOybITXns2GevfUgewgIAZVENQareAFwwqU6+NDAACnCg8L2bDZjAOnkNOFDy8Tq1IypiAAj03lh3qYRO6rECAjhACVUgTgYwh6TtOfCBEESQry4goqhEYQAOyKAGHWACC/HGF+7DCwqyE4kPOGB+GsJKbKLSjg26cBC7y8AESMFCM9xlaUqYH5gQF8Ee+jB7HvqW0/804iF2RCMbMpMRAZAClQZmJUb1WMYy7vfDKloxgh6qhwypyJLuEUCFVwyjGMcoEw+RwgGNcEmMdHABHZLxjXCMoxznSMc62vGOeMyjHvfIxz768Y+ADKQgB0nIQhrykIhMpCIXychGOvKRkIykJCdJyUpa8pKYzKQmN8nJTnryk6AMpShHScpSmvKUqEylKlfJyla68pWwjKUsZ0nLWtrylrjETzZywctYwCIXoQjFLII5TGES85jGTGYoLhHMSwSiEs6E5jPx0AhqWrOa2LSmIASBh21yc5vdBKc4BREHcpYzDuUMRC7304sB9KKd8ISnNd45z3n2op70vGc+7Yn/T33yU5/+3KdAA0pQfApGlAZIqEIXOoCEMsChEDXAQyW60Ipa9KIYzahGFzrRiRqgB+vETysE0opWoAIVqRgpKgaQ0gGcNBUDUMVLYzpTmaKUpje1KUx1itOd1vSnOQVqKlShilIyQAJMSCoIfDCGNjj1qVCN6lPHsAEQFOKqV91AGDrB1a5u4BO4CKtYx4qLFYACGmhNq1rXilYd2EEccI2rOAyQgpDiRxQyVYAA9srXvvr1r4ANrGAHS1jAytSUG0gqEwbQVKk6NqoP8AFWr/oEEHT1shDoBFk364GzsvWzaH2ECOQqV7ra9T54RYVeC8va1rr2tXt1qSmRyoQN/zD1sbhtwxggMNlCtIG3l+VqGDaw2c2uwBWgBe0KRkHauJr2tM9J7WphS93qwla2pUQqCCKQ29yO4QG99cATgsvVzBaXrCDwbHLVKtrmOreu0HWOdK1L3/oOFrujXEBiGdBd74IXq0/YAHk7EYMnnJesx12vWm0BAVq4F67xhc587UvhCqMSqfzt72O/O9kI7IG8e4jAgcm6AfUqWATMfbA4IhzdvFb4xfVFpW0ToOHH+mADWE3BeMnr4RGLdQ8YsIWCQ7sCFUOYxc2ZMIyX/NoLL7WxNYbqBp5w1d0O+Ak68HFYnxDkIaNVBA42MpKT7GImm5m1F14AlKPsVA5ndf+r5GWAlnHxBBt4Ga1hKLKRVzzm5Sj5zIA27EpLCQLGshmqY4gAVh8w4E7IWctDsMOdRUuNPfeZOX8OtKb3etjsLuDQUL3xVUGwY/JCYM5PkLSXMRBmMV9aOZnedKA7TcoNZBjUPngAlcMQgUZ34tRa1sEevGwHHez5yK/+TKxlfeaizvbToE5BBMZQiO9+uNHA9nGqvbwBXhw72bAuM7M17exSRoC7oGYAVgvs6w3EQMt7gICQ17uLFUzB0uAOt2rHvelykzKyoG6DAbDqg1JfNsQG1naX1wuKDbzV1flOzrL5DWN/j5IBa66xD3h7VXbzeA9azvOqU6ziiPtZ3BT/N7PFRYnxQ293siCAc3CzPeIwhMHLEMC3ySWO8pQveeWhbHmUq9pbDw/4AXOOgarXa4sF6HznnYECUfftc5Wb8gHo1jiOsbpbg18W6T6OwQaG/AgMcOLpUNcMF1BB1CNUvdnZtW2UN07tq+7hATI3tWbP24kNWGHIdug22tOOGS4QVRU0eDvcWc4AJjwg47l9wB4m6wMd+PrXI35EDLy8gla7l/CeIcRJoaD4xYvyAY6HvI23DmCvz3zEe9CBl2PgedKCPvSjL73VGZ96DSe67liNua+fIGK+OxzwETjGg28ferySXvc//3fv+wsCq/ZWx43ewAoO3AkMLD25OliB//I/z/zOEML50I8+y1H/+P6KureF0OqAST1iBjxiyGFIQqWXX37OnF8Vz5d+FQZ0nYR6QpdbPuABvdV1jbYCj8B9GOBlU/AIENd/mfF/ASiA9SV10neAuEVqvbUA1zZgGwBy57UHK+BlOsAIJWeBm0EIraAKbqeB9SUHhzdKIJAAIEB9GwB81SZgAxZ/WXaCGHB/CrYCOrB/zeWCmnEEmEBUojBdNEhdMHiDoMQAPoCF3UVV1jdZYWBZIBYBYXBgvDZvyWULG3AG/MeEmfGEqoAJU2hdCoAJMYgJo8QECeAD7sd6k0VVVzaG5wUCNmCGyWUH90Z+bIgZUMB2ohCH1v9VAiclCqTEBEvVX1QFf4XwBCkwYDEAiGTVd3/nZXughkuYiJmxiKjQiI5IXSUgCqiACUcQU5/EAANQW3rYXe/XW08QA39YXEp3Z7sgAg8nV6aoGaioiqv4WqL3hhfHBBJwi97FhwTnegTmiWOVXl4GCt5XisWoiJGYjK41h0RlhwJBgJlki9TXhZOliSRogmSFASYGWnYQAd7Gjd34FscIjqylAGynCoRAEOZoSbRIidD4WCCwAW2AibsYXEK4Wb/2faA1BCIwfvZ4j22Rj/o4WJDIdv9oVEwQAQUZVVyIiVdVcAfXY2QVb/H4WSvgBGtokfj4jRkZWK3IdnJwYQj/aWMRQGUkmYmb2FVhMIRktW1D9gAvCZNugZEz+VdC4IodaVQDsIM2BgE82ZMLCZQJN5QQCVo5V5FIeZEyuZR+1ZT+iEpYqHpt8Hg9OY2XhWXFBQEryVZI6JVfyRZKKZZ7VZOqcJOmRIu35Vj/tZY+eVlhkJVi1YkKZgsYQIrEWJfemIp4yVcs4IqowJendJaOlYWCmVUG55ZjtQdjp2DwaHuOeYFsB4eR2ZRsxwWpxAAe+FTS5oOYOAYY8JNYiV5GuF4MQJql+RZHUIVRKIUZKXUyxZqoFAHV51jVt5mFAAF5x1W7+JkpqGCgcAKN2ZtvQQjjKJwZKQcxKApQ0JpM//AEYaCcVdmTfhhcKSBgnyl7DBcBJIedmOGGLOADGrCU4qgKkqhKDLAHtMALnSBVPbiZoBlcGyCUP+YE6xV4niefl+GGjwAKoHCf+qgArviGQrBKvbYKtBCgUaVVm5meXAWaxRV7ySWRFIlsDroWwCmhoOAD+qiXT5lKIDCeoLAL1RZVICCbmLgHFnBwIFCi7rlW9eaSvLmiaeGE2+kDoLAHCACOrUhUlkmjSeUDUhlVdLeZG2CbnbAHHiCk4cBWYWAFR4qkaWF4+omXT1iZrISFSnWlT7Vdk7eWieZ1JLpZJiqXDWqmbGF4qEAIaipTUBCL/KkCShWSubiWzkle8f9XXDpwc2z1AErIp2xxBGgKqPgZgwDYphqQVK8JgpvJAAN2p2LVCUjIVoo5jJRaqZe6lCVweHIQnquEhVkYkm0AqoIpqiBGXGMlhmyljSTHZ6uapK2akTRweGxwBIRaqM8oVS/HnLpKmJI3Vp0gAp9lB8OoosNqFpZKVJgKjkcwdVygrK3EACDQflKmjrkaXMQHVmP1CKG5VjpwdnG1rWrRrf6oj2wwVOC5rG2anIgWmJsZYMH1aJ84nWoFCslXr/ZKrN6qj/0oq69krhKApdK4lhYwglxlsO25VnbAagzbsGiBr9+6imw3aLBkrnBKVZLFnJXFrrxKVoiZVuGXoiL/67D5GodzKAoXup8pe4DflQLM6VvA1VVi55AiMKRFSpc3WxMkG4evalP6OaixxAAPIGUty5zidVlTVlzel1YNl63C2rTcWqwaSAMnJVOigAlUW7VZ1wZZOrBA2FUY4K5kFQFqBQHBOrZkWxZPq4FCQFSpwJrK6q8T+7ZwS5WbaXSX1WubBa9p5QRiy7d9exN/m35sAIVUS66zxACIC7dCK5iMdnAxW6pfCw22IKlMW7kzcbm6p51Tm0ueK1VWKphtgAHB9QAP+JkQkJthwJghy7o4ga8DAH35SY6yC6dOhask+QQeQLqbBY9qhQEpSrnCWxNQgFeqwAW6x4/eKrG3/+S5IblbCbmWkgekm/UAa9WVwXu9NrGIRMW9pbeRZblOkfW5CSiYUxZcYfBunxmv0PAIeqat7ksTR6C9QgB9FyoHGbpOINCsWBoDa0mwubu7YdV96jWP9Wi9BTwTE0dxJ2tX5oquoaauvVWCwUV/Y7UBvit+19nB2NuP3JlyCqCpdnW/mSnBPRmtndCQ0qlWK7DBBAzDMAG/qsAGuiejIYVUPlCxtGvCkzW6PeycmxUDuQkN7MvBROwSa0dUCTy/CxxSEVClyqtbU2aVPwqdQ7BZAaZWdmAD7bvFMeGd2wt9XUwIDZxLtAWwULWcPcm4nUCeZOUBdpZWwLCwQyzHLf/xm7mne346pbg0xgS5Zm5Gkvs7oii5ZQqqVm71wooME3ScgVVXw0SVrOt0VEnFWGuWqLo4t3fnjmElbAm7AZP6yTLByABYeiwAq6e1X3/5VKzMddFKfBYsViWWVorZak3LBTOqFm6IBIrnvUdsuLeEekxwa318nlgVBufbCR5QuhcsAkOgVhvAgolMqXJwUmx7rxeKmm9Hyj67TrS1WFI1BuoGf8R3bTvpkKfbVmR6zkzIBXIgB2zgEFAw0MsIhQM9rn67wN37nYCEhZlhA43HBLn2y051xvAHAtdWCBggpAuGAQDNhOl8eLC4EF18eKKQuYfHjGXBDLCACsYL0VX/RIsRYdMbIBARwAALMAA2zRaNV6vOerFXBV4jCs5hladoZQf/zIZQ8NRQ/dQJrdJRXdUH3Y9ENQth4ANCcFInu8438QzPgIwUpwIcQAF7Bc8/FFk+4AMQgZzm+gjAcAyPYKVY+NNq0XgAJ1VXq5Bz27WbdXxoxWDjR9ItfXhpKwo0QAP/d9iOLVNCsNgROqElsNjaa5w28QzMQNbjRgEkQAIqgAAWepo+RFstsAES8AANIQEQsKNt4AqyAA2dMAbfdc14fRYP0HjT5lgeBn/rWQhdinfF1b9p9Qh6G8egV4WP/YbTRVPLDYXTNdkasFqYcFKYXROwEAsynXKe/dmj/+2P1Lw4nlt95C0B5A0C5mqlEaDa59be5zYAWNfWTwXcoNBmWJgAa7EArvmRqrejJwyGIVbMpjtvhO3JUMcGPKu9oiAHhEAIDO7g8ttXjO3gDf7gDC4HUqgBe/AEfbWMCX7dMBGuaepzFEABCgC7zcw4WrhdD4zeyLlUtupdW2iuEbAW+03CUCV5XIcBpVaC5/UEoRjASVCmO0fHh0cIM3xm+Zm2kPwSavvOAlDdqADiZGO18A1lbd3WaCmStlbGW4ja6J3baKHbkGfPXLeowoXUSR2BaRUGaIDc4MbMhOCGNiUHPnd+WM3QIR6WPjfaU844Nfpk1JfbD2BbejgGPv+wk4VwkLS95c4qyVloFjcOebV7VRigsbo73NI72BCwf4TH0iad5BTH0nIQ3ipxBHxOcX6OvGLjmgPgA0kFwQioaL4VBuv5AFhXldKG6z2oca/eAj1dFpMukhBQdy9rtIYpVjoAwNBgAw9HDcmgDUWuqSeF5JgrpaaeEqgOmZtGAQjwpHxVk39a5bCuWJS427M+p0NbCBsX48pZozUu7I33minQherWVSF2XurLXqMFV2owAFdAELXwajDYCqJQAgivgZMZg02+EtvO2WbW3Wi9V5N5Ug0/M9Zs7hKQk7NO20/wBFm7mVXw2WYgVbuAo8Bco5Qo73zsVImOVZfMVT7/XlwMsGAQMH7AMAcDoAbacAYdMADj0GdOWIeivmQUwAGg7VdMugd/FaWVCb4On+pmxgE5QALeLgCqiQoFPTaSbO4tT7u2NmV3lwI6EAO6tplmgAMvQAIvsGadQAvHsAvAHFlKVRapnXHFPmrP61UIOlZPYK1ptQKqunNoCvGA5tky4N3gjgAuSqF9VcMlBRNS7s6Hj/RoDb+iQOU1o/Jef1uI7gP1Xn2FzpM+YAFV0FWFsJNjoO7wJwMvMAA4QAK97lSFcAzAUN9zD+sq4NM2sfHKCwKh6wG8iMnWWKorsHk0e4h8Fg68IAL55qclC1tX31oqwPZrL4WND1hDhbIs/8Gzb8hsq0XH4Kk4nF+lOpjRVfXxBVe+8ccBOGAGgHBZ37zeUAwHL2AGZpCJe52QHhqwAAFCw4MBBQ0eRJhQ4UKEICKAaBMxoo8Iewo9AdFJYyEIe3B9BImrE4Yw0ExCe7RC3EqGA1aFaBlT5kyaNW3exJlT506eN7lgEiUKlSpCAoweRZo0qQoSJBQgUBqVQlMKCpIi8KEhqoChqHq2FKpKjtWtZc2aVYBJlSpRX92+hYtTAhO6dCNIeCKRQSG+ffmOgfAEDg4pcDQePhxjQyEzZnL49QvYR8QxEi23GeOQQdyYDBxOtuwDwhi+IMIc3hAmJMg9EB6dNDnkxylxB/87IBzHWfdu3r19/y7IRhUq4qowkT0btWkOCmanNjdqFWryo115O0vVigt17kgpcFAxPbpQVJiAn0efcLPnukx8eA69GPLFB3soAfphBhBi/k8evPhhBkDm42uPCHyo7LLLCDpPBAbeA00iEDYgja8ICtHoiRVW+yiMDWyBDRpbSJDiCmfSQzFFFVfcTY5W1iKOEOS6O2oqDp7aaqqmZqSRq7Wg4OyWZ4hpRYgeu2uKBOgEKCEooliEMi4Q2uuhBxAGkMCHQiR6r0K/UljsMEr4I7OTPZr6AQsC+cJIQQUdOm+uBxKkbAMQ/HpiA40U64RDXHR4LUQdfphDimMKgiD/tygXZbRRFAl5URQFpKNgySMnNQsBEnK48cijoICRC7jkSCUXVVjwlDummDOqyaHkcDTWmh6k8oUBeKAzByw82KCN+ewsM1j+4ODhoTAIHKNXNy0bw7PfpqSIWQaeiAwDDDeIwc+PYgj0pEdEoOYUYGqTtVxzz81JLeMwFYApJWvkwNJUj1Kg0nmNEkKU4dhwy8VWUCnh3uTqhY6GtVThF12FC6KVLhVA4OCFF7CQCIsXmiIQWGE3RsxALSFrY4MHEFx2ogEi4I099yCi7AFq/YrgtDBA0BaXMCIAETYbRtFmJXF4YXBhoYcul5BUUpmRg00lkO5ipwQ+SjyBWSgO/9ae9EWF3augVgrU4UQl+lwG6JJgARB86KEGLLzwAQSISXjBDMgAe4JjuxGzE9kNKJzITgQrq0wz3RqmgOU2QEgBmGNw4SsFHTTaI1s/FQvRpAeo8bkgXsLmvPMVHQhElKQUIEEFHDXNgQSuV0fK1Sd50rcVrY/SABRQNJD6XjnWEgVIz2U14D3DLdsA1zAag+yJju5mXiMdPLMIshRAyGyDJ3yIwYDLfHggaLhUoOvsBCHo5BjFC9njgcPCkHy1MHSoHBo7bMj8d/vv/80BPJSSrkYKEOAR6wSmgLAERRRvyElYZmeUJ4BCFntYHdXYcgT8NQoADRhAhC5DoTVNCP9DHHsCBlJjpicwIAZ72NgTIpCCXz3gTn1hwJtAIIG4MEADY+hSywpxjGPYohAgqBvkaMahMJQkRI/AwDFWMgrvVdCJT8wJAQgQgOTkToBcS8tQYKQIQxTEDTRRYAB9YDsfRDAVxoFilABAgAbQSVrRgwy2OBY5BjyOjjHrhIewZZFgeTAyL4OhGyPiEIdEIAKb4cmD3sMECb2wE4UADGLeNzk7HBED4xIHJNK4SU7OhAAFoeIVRZkcORiwFanABCFC4QxnMIMQhLBaQrymigAaRQNaWZ3XzNPJFV1QkBQBZF/GgIEgBkuFqanZR/K4AQxA4AEk4Y/11tQX8SkIQj7/GAUtejKXLCVIB6PYxSP5EoNidqIiHNoA/EKEAV74TAer4GU85TmATxJglPc8SwOZIYoX5YKVz1BFLmIhByQghAtaREJSNPCIR+BydcJhCxQoOE/0AAAAT6CTaLzUF/+cRiNmmMEnDuMBCDwumTV7xIRQuJHATBN9D1hW2x5Bi1E8Yj04gdacBmkHHjKOLw/4YCfIuZqRGBE2KfGZODBAUaZycopWLIumwgNVfCbHdqAgxb9EQQxiBIMZrMwFIQoanIPRQClhsN0TWOeiiDY1PW2UUEXmA6agwqFENTBTzE66V1zsYW8r3QMIXLZRvyCuZJ3gBTCoAK26uOIY1GiJ/yIl8CCJqK+nbNKTRkCwoZC0plveYqfPGHEDt5a2glOkkbv+V9Uj7cF2GlBACSZVgkfwUBvBQGVB2AqwqDQQFGVc3QDWMlHT+qYBEQKBBzKWEcQAogZXgMPNPEJUvvrJQHt8pA4iIM35jKxkf3FIAiAwJVAAgxrHGINCXOgZklEGAh+k5mkKQczVhDBn66RFUjGQjOL2l3OoTS1Vasnas9ySXkYBBS2OAYpAxCIYwYAUWxZIO+AGdzjE9S9nGpAX9xIII/xBHxyiYAEPQPcTH/mEDiDQTAhAgAEPaPGLY/wAPflpmS01EwggwN2/QCAFyxLk4SQwBlB0YgxMGMMq4P9ZEAk4RJDJeqEwMaARZIZkJMConC1EcIZw+Gx+88hwmNEFYBohoFJmVhJVCcwdH+zhCVaxxTOekYtUSAotAuQC78SsYQ22zcM8OMx19/Y4QMwBB3PAhfLscN/4wcYOGJiunz7hBJcFWrDBtFOQ3ZQZDDygD6NgxApoaooFGHJ4PmhbBF7minAWgpyd0BCHUlI5UGzADknlBQYUtWdeM4rMntLUjtS85oGl9REDcEZYk/OEPeAOaoQYSu96/RZB8rgvbcDjIyG9mk+8ALoesEGjxS2iHW9gBZuNwWlCEoMLHcbV06pQCiKg6U2PIbHoZagOzrYHyzzBDnbAKF/Kx0P/wGCIfBx6gjpPYgsI5NdntGDnrqc98d1wIShrSEgo77WppxE7VWN87R7GwAUEGNiWzaadA0ExYO5k0Ti+o/hOhjeGh8wHMB7txApUw6FPwKEDRh13o20BCleAgqFTgMAKIt0anGfXZWzybskuYwtZAOMyuzjGLiRiB14szi/mO8YIE86hGGwoRCt4RFIhEYHNxdztcZEDcY6GhwEAAJRYrMqwPW6W2oECgke5qlX6fjtbXvVeBFwLJjD8doYwwPGbYSMEmKXq+eyBASuF9Qa0tYcKfDbon/eWinf+COuBmLuAoZ7ULcOXy2T9GFvyAU+BAQq/9MlDVH6ElTfghMrN/y+pdhAB44X/ld2iIhWooHsDNA41BOh973x3qAAQcFXcKYD6R/HBE6LfIwIOhRBCGH7jfdAeJjg5QcDMGM755CcdfAj0WWboIxgdIi3rQJnQ7JgF8AQf1S+rvKDQMevBBR+CDA/SCAhYDR0AOpN4BAhQopWAhKU6iC2ohfCzwJiAlFaQFJZ7vg7MJ6OTjjZzttVRgGi7QIUYG/KboTE4PwwgLL7wgczqBGzhkE5QsSfAsvc7CVBQMRvQgSTAALSzhSGsnPa7v3IKrF8Znv6rngcwm4BbE43JoyH6iD0Qgco5gw14QHI5wS5kCCiAgp94kePwwDL0lAByPhpRAD3zQv8mIz+6WIDLAKI1ea+82rnOgoBK+jxgcAVBEYG0S6pRsIENEAEM4L0QsQPNw4VPgDR3k7xfsQBUY0Gp4x4odKlCcJz1iYDcA4kIAIXKuZyVoAYfbMNSNAhoG461kBEzFIDVYsVXRDyiWDwLnJI3ZIIYsow5nA8QGII8Oif3wYD5a7RbmAMZWASTsIUVcIKkYkafcQL3gw0FrEIZzDwPS64I2DG3mRA72RsLmJNpegKMCkfRyJAd6xOQeIJDPCr6+ZkNMMV3jLCDYYNXdBccMcM0HCXXIYQuPBsQaAFbLD8LCA2Y+pXMYoBzDAkN2YVGA4UhoAIdsAOik4IfeIEWWwD/O9iFRcCkZvSyK4QNhjtHfUOMGHAhlxqDJ6itXRC5MQiDFxxAI8OA5Do3HWC29DGp1YAAYXSCWxOH4HvHNjwCTBhDNuACGuDANVuOJfmOo7yiBnoEqkIAZts+qHGdWAq/hgFIJngIOpE3OPoLYjoMBFyNR4gAcUMiRgCFUbCDDrAAEvgBPoCGlUgGHCAUhvCyYHQ0zrKZ5TkM7Sq1DZAxBpAmW3isYxAnAkGsY5CFbEMM/4i01WCAIlwBzKEGCPhJL4QCfSGKA3tFG8ERHQkPYnsCHpKFCksKkPu71TGYtWCDWXy7B8jKuniI+PCVavGoyIkADvEALMhBSwKGZEiq/8fCNQ74gQGwlYUIRNeAjXQ6x/Rpuo3AvByDAF6ALMNkvQ0wgOx0vBVQslGITo3wkBPTlgUIERuwgi4TBzsgrcscviMgBEwACtYkMDNrvqioT6TQGgp4gRnAgSZgAXy8F1Agzam0JVnwO9aBghdBBS4APwuci9ikC5jKxWDiC2gqBF55AiL6ASmYg/g5AzvgUFcYB58BhlHgAzRgJm0qiCsYgPU8CGbkhQ04A0cToRMbiXISlj14hFWQhXMTOQh4zj4JpzIJx5pRwBCJAMzJJJ9kT8YLyoNZCyNhLU25GPukCqmxFwFgAT9ogi71AymtqgaSBdjaCqzQvtVhK2kbvv/1qEUIvUU30sW+mB47tLEKuCv6AwUP4IMr4FBoCDUI6ACKRIhkUAM1WATkTCpqiIFwczRFxIUNUK67EYmLwMboxIVdsIUUGgJtIT36w4CVyLUmfTs2kINSghHiMCsCI51NsaKpqAGnEAIaoIEdeIEacAEuOBoubQI/SAU2oAEhYMp5IdOo0AA3m7BUSVPXpLjxc9P24L+W2ag88UVOHMtNLLQ+ZMAVs4EzAIZi1AIImAJeGIdTGIA5mANjSAgws8ukykJGe4CQCIOSap5g4aHFMaYH+ERoQCfP28mVsIM+KIhx2IITYAh5ENWmCkotWgsumJRg5Ro0k5foaAogCIv/TOjSJqAD4ljQgjijMxoKVHm+PTBQ07yK6+kO4UIFmIu59WDWZnUPyprQwloMA0HIzsLXEAGGMEgin3GGICABRjiIOTCIXTsFiVtXn+GEB+gWtKuvwJhX/oCGgpAFWSCTzcIFaHgsfWWNFQiRWlPSKUAIcjjYMHtSKAXTV4waChgAzbTYJhgAMMgEVMgEg5CoTNDMKA3ZAeAHKhjBpHCt3+KOASAOlZ02RSoBl22PA9meC+GozNoAag2J9ps/UMCAKVBScTiUcq3AnhgHFCgIGLU1kwiDDOW2FcDRec2HgoiHoDITRcRaagCGDlkBTzy7UQBVyyyILRjbMMtMVZTV/4BB26TggAHYVVSQAwQiXi4oVYQAghkYgDeIu6HYDo9DgHzghwEggwn7W5LdirhjC7eLAMS1xSy5jHm7tjrsBLFcjXTqPQtwOHGgBi3gACkoiFO4guM8CCZlUTATWoUYhzxYgQGwgculhhWAn11QXyvjy6ftBINY3Y6hwmPQ1z3AAECpHFf41J9hu93dszXQoul1WI+rlIv1gwFwXoOYxSKoARTu3c30OIPYA6gq1jM9i3383phrU/GtC+6hEyjzC/zzq2rVw6PaWfh1AuKkXz6YCRKwiXnogwrgyZWwgk3UgZvsrMdTNdSVWv5wHGiIXZCAgHw9IgiwXaWiBXWFCf8OdqugZCVm+JezDV6jAJKLpYMSRgjXNIKEOAInEQWgAAoZCeEeSV3s5REN0L40FAKvGADC5bUc1mEmUAGYxYwHYCGOYi5zesz08TxoCIMKeMAYNQihbbtybQnLbCKZwABO8JljIAkq2Jud01qQsMHx+k7EmNp4AIVB5gdZwGUAtAFceCxqAOP4Ybh2EoczsAJ1VePSysxc+FxRANk4PordadsmkIMiaN6bIC5MUNi1eBHgJVbuzackCMfU5Qd+0AAqOGQBuL7kgALvm7a2O7JHrgsn45KWOt+VeoL2STS8NAmjs4MVsIFunYNJiIAlI2XgWIEVeMBRjAFo4MEz4KH/WO6sDSi3SM0Q60WI671eMpguagDpjyDL+NmAMj6GCFCUCljmprI4VYgFbUA2cA5eHcHV4fADMHgDIhiAPN5pnSAE8igOr0hVhTJQteqOQV6I7LW+12JKtvq+PXsQAQUFepbN1BskDuoL5wTP3GSNDiBiiFTlRbgCt0VoFJkEDChjcXACIzqGVUismvmER8ijRtwspB4Aux6AeACJk+grLaSGI1IJ+MWASVjp0sqzKH0Eo5Nmo3AXIHiRhCkC3jio4YBjAfCt1KQOvD6IXbalR3gzAeg7Ao2wttiz8KWLNqBq9xgZOvEjv7g8lqpZ2j0JEUhrcbgFHMAJsY2LpaLM/5w0CWroUUA5KbKMAPuLCb1OQL8G6WiEBJYobKYKQ+VVUJAl0A68z1asgRfg1VTgAgxr0Lh4Z/nET6Y+6pZQ6qRIbFAwaqQQXONQ1tJyZKqGEImguSjriyzWCA+INLIcYpQgAXNdiWPogCDYXEaxA2oYBX82idZ4zM0LCYZyYG2JVxyEBpAWB9DCnFEg2OeWp5Y+GN6SZh15ihJIhUzwg2hjZM44giPITO9jHQUYZKU+Vt8a1ujQ2Pdmqs0YvzEwk0f2lfLTqYmgvAJ8HJZiDaWFjV2w0yuYgxKNlSkYB/5qOCT6LFsgJrkWKW2haFyIcGXKvdbQAWE0iWd8QB3g8P8Oh1IJi8rP5g6sANAAU5J8OT42TA91IcMjwQqHQgCDAIXkuCUeKcEbLi728oHDZQJboAVoKATxLQRa2IUzsOo20KjKiwB3IwmRxhnYAIUIsINCaXIJZBR9GACVHgBe8GRaWOhH6E0dWAFCZLFIe91Y7oRBloVBXABmioAVEGOcNWDRuo0z76TdGQ4wPAKr+Nv1To70ru57mQrmsFuigKUUWfHRDmSj+FuHivGjtEekSNPvdqsUJL/y2oV5dtlOoClQyEWshgzsgZwHuMMY6G9b2IBVEIdwGBcbOJdxmIc8YMdRaPWSyldbeISFtPIM3QM7oAUFy6MV02W0Ar1ai+L/KdhwYN8kVATxo0Ar9e6Odr6ip0AA8kjx85j2rpBp6kjvCisIfrADQK9x/rFzHH8iC0AI026PQqA9udZhH+AElWykNcmTutFkkPCQ8oziTDqXPCiIebABG+ApUYSEfxcBG8CAQFmBpKstWrABCLACRlvIyoHfvwattHYCJ6D4TQKKaJuRGQ7HY+0tv3vz7oCKEtBYRoneAXilsaCO2onhqCm5qDC87h0Kxcvxg4jvNsg6W0DctnGbOckoxu0uEEChQtiASGu/3hSRDDYIUHcLUueMVdBd2l7lTyYJHVxu2ABpzDkJK9BCnxmF2xiHKRiBsq8gKMUEpVB2tvdAGtBY/6uEkslWhVbQQNxHCivSe/F4ggFQzOpGxe5mKgMYAMdr2fZoA17Yhalu1s8Qnx7+xvnAb1izP5HYgCmonDCwAuf+nRNYgdoWxawXQjH/bZAOB9MvCLA34MtlZYPYAt1mCM2X/XIBCFWoVMlRIOAgQlAKNRhE6PAhxIgSJ0pkgWoglwEaNw4okmNHEY4iR5IsaXIAlIuqVLVCVYIiRYWgfCDcc+wYqImYBrI5cvIn0KBCh5Y0IIEJ0qRKmRQC1WYpVKQRQIxpY/WqVRAxCnHtOgbCk05i90TAZXZFGGhq19oRQU2cuAG8MBCta3ekvpKrTogYBfcv3FEbMGCAAGotYv9ox1ZBQkztMTRQG+wAphWBI7m7mjdz7uz5M+jPqihq2OMDQUOYqlevPjKQEFCfoU8ekT1AzkVULFg/3LMQ4ZPfEBUQWinK9uzkng1siJr0UWTnSn088FEV61XqXbs+ebBHrFgPYczuEZE48oZjcDVuUJ48T4efdt4C/ksLg53zU6wcW6HjPCgQ+GVfBLy4dyCCCSq4oEmjSaTBQgjwNiGFDqWECmwM3sXFQKoIUSECPmggIUIaSKSAKANhoiGLJhklHRPA7ALMU9L5wIAP2F01BggbtLFdIV99B14nDJiFSwSHJRYDJ+tptEWLB6LRgXr1wdXfBiJkqaUOf1kRgZb/K2gpQpVwQRJBMnWhECWbbbrZmYMRBQfKHiRWeKdqFgmU0ZtAQbGSKlzguZoCKmXYJ4vMwQgKME5JB0IC1+nYxlRAFrKHd0SKBYFZYfyXmC0Q2EcXorN1aeVfNx0DzE31qaoqfeJQM8UJycxDFASl6roronFC5INCTww6rERC5MYnryLVBkWKqhBCrEQlACoHcsm69yKMQUo3laQ6gpCCpU9EEIamnTyBAS6PRGDLeWGc8Veu1o50CgqZQfkTCgOiui+/BKIxjl3KyCMvwQXP5itEGpgILcMHdYiswRthshImqTU8wEVyRHxtczDaGIF1k1r1laUpbFBIuR5sYNYG/9CBCkGsGw8w8ABTDJDZCUDF2i/PvDzSxxmkyjw00e4h3DDSDxWKiihF10ZIK6qIYjG0KaICRdGgYesxVDfmKLJVG/gA5AYglNvJBk90asN50KzQJFzUxCtzEEOhcaqTPNc3ygA2bIEGJFkLPjhnRyd9uEWpNO30EYQM5NKdCCjskAJRq4I14ZspyjVSPvgAAqRjdKujDyd7hUFYZ2/wiVkPsJuYZICdIfg5QqEhwgBxbSSrlaNgsIIdkJzRwSjUjHNr5skr/5PhhzdMw0qo9DQ4bhft5lBwwk7kGygLl6CSHJgvT9TWHoPwAAifj046A2Nw9wC5Z3cCQSe4POFE2/8xMPLXXIIvMhQkKlASgJHECSIh4PgSOL7mSQQBdnIeRYQQPYgJjgsC8VCJZLKwiIDCFgMYQwmEIAqBaEyB5OuYx6byo1UVAmxt6JH7uGKyIalOB2aJgcvWsgv//IUauDOhXajhhBUAsYhFZOCvhAPBiThOesvjgtUEJQAFyGQicoCFM5ghilQ8zIhCKV9UqBMyW9CiUSIbQ9m2Uzb5dYIs47lhDqERKsrApX9eHECa7qjHPWoEiQ95hEJo0sAlyiFq01Mes1byLAFoQEQSgZrlAHW1avGRI5tzjteu0olj7KKFOhrDA+zAqktFIHVnC0ME9nCkPUDgdWqxwSP+Mor/B2RuBEGZWyVzqUA/Yk+JDwlOnQ5Hg6hNcnxHEEWKMEERFKmIEHJw5qF0ORIwKgUEERgdV9bnA7DsYlWPgB8bxcU6s5zLlWrBQJWOITRpbgQN7HznxnjpkMlJRCaCvNgEKZk8qEmNagdZGobg+ZNLLoVbLsSKNd2Hi2PQwgYok98GYnAkXPjnPI/AwF8MKNCNclRe8mQN9zYIrRKM8GpGdJxAMKHSlU5sJeHrKEmo6YMEgOCgO+rRdnSgg4eWiyxqO1IYVnCeUPFiPbRU3sDykBeYMjVrH12N5EQ60otgQp/jw40kAQWonliVowRlQiZt2gZQgqsraWMjKlV5pEds/8Cc0NgFBgZkROQ1ta4Re+oSYSJCVazojmzIjUAehwou1MauGylf6MTahm0+wStgCWcEHjFRTMVRLcBzkmEzq1nl4DWvxeriZjd6SQlsYH0iS8E1uxIGcEJUohN9ggjcuosNWOEvA7iMCeVxCo3UIrS+bVNnPfuQvwpEfL9l54t8oEKx8sh0XcmU/PawsoniAgLAOI8O6CiOWeoxPsf97oKCK9yDoFQUxgVvLpkTVpuOoVLbAYEpz1aI6a4yBgDqwF+G50U1oLe/CRKvZxWwE7521b9GNMADHsAExVKqsdsxGRvFsgLXmqUT+EnMbAcUuCKeQoAG/nByAJxXY6ECE//nBfEdDdA+BpcOSFqJ8HxtuEoMVFYy2t2jFAZQOxTz+C4iXqKxnNVjPjKHwe11sAw3EOH5vZE8G1DSWh4BgVX0cJ1F1MLMhqxlofwYghIM6Ja9aIAIKJY6SG7DGiMcg58eCYeJmUJ6AHMMPoYgzHZu0Hgp9OVo3jmBRbbpNmNYiO7E92xkoe78lmQDK9Giz46WZpedxyEhP9rPZD7oVwQ9XxqyMbKThUBlF1AfjVi50qYGYqST9qc9nXp5fwbbkV3M6bM9gcK4CAMG3AoNBoxal7Zs9ZZT3TCsmhfYyhsz2D4HFiA9gQE8pfUDXhtb7C4aMAuQ5m6N3WNhM+xxBdb/dsT+8WrsMNZSPVryBjwwUQ+wDVS0tdI7cwxuEHMbWoGdd+aQTboHWKoQL2ajG49k4bSc57KAYWcXNsJffPc3anlmzb0ZLrhxjwwCmubKE5QMcO+sEtRtgwaZ6kOL9kgTy1mW+Hcd/nDVRBzlRNP3jh6A5K60AQKzJpK4JEueXH/cFujstTTvoI7/uTzl9SZWy4u+sXGX29yFJpIHVkBdd33cxntTOtYJpvKVUyTpWScYzBPa7zFUQH6FQB117UfwxFxUX3/RATxf8XXfbp3rEvH63JNV5Ob2e9A2N7TN045rKCNGB26Hi0bzrng31d3uEMH74ks1ZrL2fYbQ1vlE/3WwgV183PD12bBA1aGRCixCGZHvaOMd7xDIn/5NY5Z53zMuP5WlHW34+zg0PH/wpo6gzq0XaOpVL4BCSk0Iv9eVAQxwcZpD4NliObuMJ6qu/OAeGnG2bVPFkAaOBMHDx+dj8O1OnKiZ+PuSd66lxtXTwFOXLIRv2y5EhX2mviLhaXiH+aUZ/pUzk6/5l3wE9B0I6EC55Fza4YLrVF9kYAAk2NYPMVXC/Z/+HR2FKMAF8ZkEsglz9JvsaUoM0Bd1rZkCXhQt7N533UEGAtH+jVfluFQK9smYWQrJlIuS1Z4IfEr1WUEsmeAL9qBdrKBwfU+JnZgPMsgGbscT/B0NYv/ekUyGAqpFDLjdABBREVZhUAChZ31P8Vlhi8SgY8nPB6YdWz0hNFwUfQyAZfQWF64hSWDhEgEUBrLhgRwhV2BA/GhKRB3gHuAg7tkBBgBDlX3XMGyDHBKOGzqPFqICtRTignhhIZRST43LAVpYZZ2HDdjAzvSX9zEi0Rxi0tBAh5QQJybIBo7BAjxdWk2ix+Gez51BOADdKMqhJ17M41BQLCrHmCXhzRngAa4i7hnGqNmBDdyiLFIgRbBAKkgNERJjaKjYydCguh0gLsTA2n3cI1Tb/OURM1rhLEJLkMXhNmoNA0QimwneBjyhHbyLbVHDURnYr4VjsnQjsRyBIsH/47VggKZgilodYMZxXvWBQoHMH4h9gz1aizwOSpANVkEmx5jhnKdNYkUpoB1sgL7wGEEuZDwaY0RMWjFhpNbgY3hInTTeGh9+HJyVie54ZBUe5J08DhR8m0oORUOeXTkeYBhU43nsEN5gn80M2Q+gYExGCUtWyOME5UfOzz6OJFpUn8EJ5JBJg1G2yVBOyF4tTlRyRkNyykjiAtrg5HnADA9uGVReJYtMJWukBKuRpeZgQCEswFbOTyWCCkY5pZ2dACGqZYKYpWoQX7HhpWYgGAQ02QE+glBVn8/tD2ZV2jT45YHo5USMn9QwpuYsABPqoX3hXoBIYauNQBBw5gh4/5dkcoZjSkSz9FVo2sWYbSXLUF/nwQ1dnpoYnGZnjCZEkBTTGJ9s1oUBoMtWhsFl4t71JWZuHh9tPoRtigJuDucXlcVIWpiuIUYYfEBYKmfrFadDNBEhLCN1ThNvSuMTWEH12cAKnOF2mp91TlFLlV95AkVqjuQDVJ8O1JZwrufpnSc/gSN9isRuNicGMOUuzGd+Lt55tpQtBqh+Mqc0vidwFlVKGmjknScydaSDcid/4l4YiMBrTmjWDWhaauiBbiUEfNwlxoyHKh6HSmiJDsB+QmRJqgVhwmKKYh2HXg5M0md7IpodfpwdaFeDxqiMUiCB+qhGrCh1RRZwVqSQfv+ddSLjRWing97oRIVo29iCCExBhiapxBUn9HDRIfkokU6UgsIOfkwnlqIcbSIjFxVoiULpkYQpWwQkmZYpw9Em9FAaln7pkTBAYlwoSvaonJoptw1AMuKnh7JpJ0TkWogajP4poD5PMipkmX7p/LCmWvhcnDLqnKYaPXbonSIoRVViGMinn2Jqo0ILKnCRk65pd+ICCLxfqJAoqSqdYxYlo95oJ1SAW60AYgJorOKbXtLAo2LqirJSZb3olfYquJllQhJWrZbFHvAcYhDVsSKrtk0liZlXjWrofupAsQrItFKrsU0lG7hUtmprWaxAHPkhg44quPrqj1WPKNaqHbaCFWJAQJW064a+a8bEqjO6lfyxK77O21TCK78uwHn44bcGbKsNZQsGSrlOqIolhg6swL0qbNGxJAtMy8NCrJSqhQ5QQcJa7KkdpAIkoypwFb92LDTYQAkCrMhWq3gdJ7UmH80awMt+nSoMgFYJRW5gDLVGQM3a7M1inTVo1UoMLUkEBAA7" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-anim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The effect of the coverage rate on the conformal prediction set. Softmax probabilities are shown on the left. The size of the prediction set is shown on the right.
</figcaption>
</figure>
</div>
</div>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">🏁 Conclusion</h2>
<p>This has really been a whistle-stop tour of Conformal Prediction: an active area of research that probably deserves much more attention. Hopefully, though, this post has helped to provide some color and, if anything, made you more curious about the topic. Let’s recap the TL;DR from above:</p>
<ol type="1">
<li>Conformal Prediction is an interesting frequentist approach to uncertainty quantification that can even be combined with Bayes (<a href="#sec-background" class="quarto-xref">Section&nbsp;1</a>).</li>
<li>It is scalable and model-agnostic and therefore well applicable to machine learning (<a href="#sec-background" class="quarto-xref">Section&nbsp;1</a>).</li>
<li><a href="https://github.com/juliatrustworthyai/ConformalPrediction.jl"><code>ConformalPrediction.jl</code></a> implements CP in pure Julia and can be used with any supervised model available from <a href="https://alan-turing-institute.github.io/MLJ.jl/v0.18/"><code>MLJ.jl</code></a> (<a href="#sec-julia" class="quarto-xref">Section&nbsp;2</a>).</li>
<li>Implementing CP directly on top of an existing, powerful machine learning toolkit demonstrates the potential usefulness of this framework to the ML community (<a href="#sec-julia" class="quarto-xref">Section&nbsp;2</a>).</li>
<li>Standard conformal classifiers produce set-valued predictions: for ambiguous samples these sets are typically large (for high coverage) or empty (for low coverage) (<a href="#sec-scp" class="quarto-xref">Section&nbsp;2.1</a>).</li>
</ol>
<p>Below I will leave you with some further resources.</p>
</section>
<section id="further-resources" class="level2">
<h2 class="anchored" data-anchor-id="further-resources">📚 Further Resources</h2>
<p>Chances are that you have already come across the Awesome Conformal Prediction <a href="https://github.com/valeman/awesome-conformal-prediction">repo</a>: <span class="citation" data-cites="manokhin2022awesome">Manokhin (<a href="#ref-manokhin2022awesome" role="doc-biblioref">2022</a>)</span> provides a comprehensive, up-to-date overview of resources related to the conformal prediction. Among the listed articles you will also find <span class="citation" data-cites="angelopoulos2021gentle">Angelopoulos and Bates (<a href="#ref-angelopoulos2021gentle" role="doc-biblioref">2022</a>)</span>, which inspired much of this post. The repo also points to open-source implementations in other popular programming languages including Python and R.</p>


<!-- -->


</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-angelopoulos2021gentle" class="csl-entry" role="listitem">
Angelopoulos, Anastasios N., and Stephen Bates. 2022. <span>“A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.”</span> <a href="https://arxiv.org/abs/2107.07511">https://arxiv.org/abs/2107.07511</a>.
</div>
<div id="ref-blaom2020mlj" class="csl-entry" role="listitem">
Blaom, Anthony D., Franz Kiraly, Thibaut Lienart, Yiannis Simillides, Diego Arenas, and Sebastian J. Vollmer. 2020. <span>“<span>MLJ</span>: <span>A Julia</span> Package for Composable Machine Learning.”</span> <em>Journal of Open Source Software</em> 5 (55): 2704. <a href="https://doi.org/10.21105/joss.02704">https://doi.org/10.21105/joss.02704</a>.
</div>
<div id="ref-hoff2021bayesoptimal" class="csl-entry" role="listitem">
Hoff, Peter. 2021. <span>“Bayes-Optimal Prediction with Frequentist Coverage Control.”</span> <a href="https://doi.org/10.3150/22-bej1484">https://doi.org/10.3150/22-bej1484</a>.
</div>
<div id="ref-houlsby2011bayesian" class="csl-entry" role="listitem">
Houlsby, Neil, Ferenc Huszár, Zoubin Ghahramani, and Máté Lengyel. 2011. <span>“Bayesian Active Learning for Classification and Preference Learning.”</span> <a href="https://arxiv.org/abs/1112.5745">https://arxiv.org/abs/1112.5745</a>.
</div>
<div id="ref-lakshminarayanan2016simple" class="csl-entry" role="listitem">
Lakshminarayanan, Balaji, Alexander Pritzel, and Charles Blundell. 2017. <span>“Simple and Scalable Predictive Uncertainty Estimation Using Deep Ensembles.”</span> <em>Advances in Neural Information Processing Systems</em> 30.
</div>
<div id="ref-manokhin2022awesome" class="csl-entry" role="listitem">
Manokhin, Valery. 2022. <span>“Awesome Conformal Prediction.”</span> https://doi.org/10.5281/zenodo.6467205; Zenodo. <a href="https://doi.org/10.5281/zenodo.6467205">https://doi.org/10.5281/zenodo.6467205</a>.
</div>
<div id="ref-stanton2022bayesian" class="csl-entry" role="listitem">
Stanton, Samuel, Wesley Maddox, and Andrew Gordon Wilson. 2022. <span>“Bayesian <span>Optimization</span> with <span>Conformal Coverage Guarantees</span>.”</span> <a href="https://arxiv.org/abs/2210.12496">https://arxiv.org/abs/2210.12496</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>In other places split conformal prediction is sometimes referred to as <em>inductive</em> conformal prediction.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Any thoughts/comments welcome!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{altmeyer2022,
  author = {Altmeyer, Patrick},
  title = {Conformal {Prediction} in {Julia} 🟣🔴🟢},
  date = {2022-10-25},
  url = {https://www.patalt.org//blog/posts/conformal-prediction},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-altmeyer2022" class="csl-entry quarto-appendix-citeas" role="listitem">
Altmeyer, Patrick. 2022. <span>“Conformal Prediction in Julia
🟣🔴🟢.”</span> October 25, 2022. <a href="https://www.patalt.org//blog/posts/conformal-prediction">https://www.patalt.org//blog/posts/conformal-prediction</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="pat-alt/pat-alt.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb11" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">---</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="an">title:</span><span class="co"> Conformal Prediction in Julia 🟣🔴🟢</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="an">subtitle:</span><span class="co"> Conformal Prediction in Julia --- Part 1</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="an">date:</span><span class="co"> '2022-10-25'</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="an">categories:</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">  - conformal prediction</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co">  - uncertainty</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co">  - Julia</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="an">description:</span><span class="co"> &gt;-</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co">  A (very) gentle introduction to Conformal Prediction in Julia using my new package [`ConformalPrediction.jl`](https://github.com/juliatrustworthyai/ConformalPrediction.jl).</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="an">image:</span><span class="co"> www/intro.gif</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="an">jupyter:</span><span class="co"> julia-1.10</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="an">draft:</span><span class="co"> false</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="co">---</span></span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="in">```{julia}</span></span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="in">#| echo: false</span></span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="in">using Pkg; Pkg.activate("blog/posts/conformal-prediction")</span></span>
<span id="cb11-22"><a href="#cb11-22"></a><span class="in">```</span></span>
<span id="cb11-23"><a href="#cb11-23"></a></span>
<span id="cb11-24"><a href="#cb11-24"></a>&lt;div class="intro-gif"&gt;</span>
<span id="cb11-25"><a href="#cb11-25"></a>  &lt;figure&gt;</span>
<span id="cb11-26"><a href="#cb11-26"></a>    &lt;img src="www/intro.gif"&gt;</span>
<span id="cb11-27"><a href="#cb11-27"></a>    &lt;figcaption&gt;Prediction sets for two different samples &lt;br&gt; and changing coverage rates. &lt;br&gt; As coverage grows, so does the size of the &lt;br&gt; prediction sets.&lt;/figcaption&gt;</span>
<span id="cb11-28"><a href="#cb11-28"></a>  &lt;/figure&gt;</span>
<span id="cb11-29"><a href="#cb11-29"></a>&lt;/div&gt;</span>
<span id="cb11-30"><a href="#cb11-30"></a></span>
<span id="cb11-31"><a href="#cb11-31"></a>A first crucial step towards building trustworthy AI systems is to be transparent about predictive uncertainty. Model parameters are random variables and their values are estimated from noisy data. That inherent stochasticity feeds through to model predictions and should to be addressed, at the very least in order to avoid overconfidence in models. </span>
<span id="cb11-32"><a href="#cb11-32"></a></span>
<span id="cb11-33"><a href="#cb11-33"></a>Beyond that obvious concern, it turns out that quantifying model uncertainty actually opens up a myriad of possibilities to improve up- and down-stream modeling tasks like active learning and robustness. In Bayesian Active Learning, for example, uncertainty estimates are used to guide the search for new input samples, which can make ground-truthing tasks more efficient <span class="co">[</span><span class="ot">@houlsby2011bayesian</span><span class="co">]</span>. With respect to model performance in downstream tasks, uncertainty quantification can be used to improve model calibration and robustness <span class="co">[</span><span class="ot">@lakshminarayanan2016simple</span><span class="co">]</span>. </span>
<span id="cb11-34"><a href="#cb11-34"></a></span>
<span id="cb11-35"><a href="#cb11-35"></a>In previous posts we have looked at how uncertainty can be quantified in the Bayesian context (see <span class="co">[</span><span class="ot">here</span><span class="co">](https://www.patalt.org/blog/posts/bayesian-logit/)</span> and <span class="co">[</span><span class="ot">here</span><span class="co">](https://www.patalt.org/blog/posts/effortsless-bayesian-dl/)</span>). Since in Bayesian modeling we are generally concerned with estimating posterior distributions, we get uncertainty estimates almost as a byproduct. This is great for all intends and purposes, but it hinges on assumptions about prior distributions. Personally, I have no quarrel with the idea of making prior distributional assumptions. On the contrary, I think the Bayesian framework formalizes the idea of integrating prior information in models and therefore provides a powerful toolkit for conducting science. Still, in some cases this requirement may be seen as too restrictive or we may simply lack prior information. </span>
<span id="cb11-36"><a href="#cb11-36"></a></span>
<span id="cb11-37"><a href="#cb11-37"></a>Enter: Conformal Prediction (CP) --- a scalable frequentist approach to uncertainty quantification and coverage control. In this post we will go through the basic concepts underlying CP. A number of hands-on usage examples in Julia should hopefully help to convey some intuition and ideally attract people interested in contributing to a new and exciting open-source development. </span>
<span id="cb11-38"><a href="#cb11-38"></a></span>
<span id="cb11-39"><a href="#cb11-39"></a>:::{.callout-tip}</span>
<span id="cb11-40"><a href="#cb11-40"></a></span>
<span id="cb11-41"><a href="#cb11-41"></a><span class="fu">## 🏃‍♀️ TL;DR</span></span>
<span id="cb11-42"><a href="#cb11-42"></a></span>
<span id="cb11-43"><a href="#cb11-43"></a><span class="ss">1. </span>Conformal Prediction is an interesting frequentist approach to uncertainty quantification that can even be combined with Bayes (@sec-background).</span>
<span id="cb11-44"><a href="#cb11-44"></a><span class="ss">2. </span>It is scalable and model-agnostic and therefore well applicable to machine learning (@sec-background).</span>
<span id="cb11-45"><a href="#cb11-45"></a><span class="ss">3. </span><span class="co">[</span><span class="ot">`ConformalPrediction.jl`</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span> implements CP in pure Julia and can be used with any supervised model available from <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> (@sec-julia).</span>
<span id="cb11-46"><a href="#cb11-46"></a><span class="ss">4. </span>Implementing CP directly on top of an existing, powerful machine learning toolkit demonstrates the potential usefulness of this framework to the ML community (@sec-julia). </span>
<span id="cb11-47"><a href="#cb11-47"></a><span class="ss">5. </span>Standard conformal classifiers produce set-valued predictions: for ambiguous samples these sets are typically large (for high coverage) or empty (for low coverage) (@sec-scp).</span>
<span id="cb11-48"><a href="#cb11-48"></a>:::</span>
<span id="cb11-49"><a href="#cb11-49"></a></span>
<span id="cb11-50"><a href="#cb11-50"></a><span class="fu">## 📖 Background {#sec-background}</span></span>
<span id="cb11-51"><a href="#cb11-51"></a></span>
<span id="cb11-52"><a href="#cb11-52"></a>Conformal Prediction promises to be an easy-to-understand, distribution-free and model-agnostic way to generate statistically rigorous uncertainty estimates. That's quite a mouthful, so let's break it down: firstly, as I will hopefully manage to illustrate in this post, the underlying concepts truly are fairly straight-forward to understand; secondly, CP indeed relies on only minimal distributional assumptions; thirdly, common procedures to generate conformal predictions really do apply almost universally to all supervised models, therefore making the framework very intriguing to the ML community; and, finally, CP does in fact come with a frequentist coverage guarantee that ensures that conformal prediction sets contain the true value with a user-chosen probability. For a formal proof of this *marginal coverage* property and a detailed introduction to the topic, I recommend @angelopoulos2021gentle. </span>
<span id="cb11-53"><a href="#cb11-53"></a></span>
<span id="cb11-54"><a href="#cb11-54"></a>:::{.callout-note}</span>
<span id="cb11-55"><a href="#cb11-55"></a>In what follows we will loosely treat the tutorial by @angelopoulos2021gentle and the general framework it sets as a reference. You are not expected to have read the paper, but I also won't reiterate any details here.</span>
<span id="cb11-56"><a href="#cb11-56"></a>:::</span>
<span id="cb11-57"><a href="#cb11-57"></a></span>
<span id="cb11-58"><a href="#cb11-58"></a>CP can be used to generate prediction intervals for regression models and prediction sets for classification models (more on this later). There is also some recent work on conformal predictive distributions and probabilistic predictions. Interestingly, it can even be used to complement Bayesian methods. @angelopoulos2021gentle, for example, point out that prior information should be incorporated into prediction sets and demonstrate how Bayesian predictive distributions can be conformalized in order to comply with the frequentist notion of coverage. Relatedly, @hoff2021bayesoptimal proposes a Bayes-optimal prediction procedure. And finally, @stanton2022bayesian very recently proposed a way to introduce conformal prediction in Bayesian Optimization. I find this type of work that combines different schools of thought very promising, but I'm drifting off a little ... So, without further ado, let us look at some code. </span>
<span id="cb11-59"><a href="#cb11-59"></a></span>
<span id="cb11-60"><a href="#cb11-60"></a><span class="fu">## 📦 Conformal Prediction in Julia {#sec-julia}</span></span>
<span id="cb11-61"><a href="#cb11-61"></a></span>
<span id="cb11-62"><a href="#cb11-62"></a>In this section of this first short post on CP we will look at how conformal prediction can be implemented in Julia. In particular, we will look at an approach that is compatible with any of the many supervised machine learning models available in <span class="co">[</span><span class="ot">MLJ</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/dev/)</span>: a beautiful, comprehensive machine learning framework funded by the <span class="co">[</span><span class="ot">Alan Turing Institute</span><span class="co">](https://www.turing.ac.uk/)</span> and the <span class="co">[</span><span class="ot">New Zealand Strategic Science Investment Fund</span><span class="co">](https://www.mbie.govt.nz/science-and-technology/science-and-innovation/funding-information-and-opportunities/investment-funds/strategic-science-investment-fund/ssif-funded-programmes/university-of-auckland/)</span> @blaom2020mlj. We will go through some basic usage examples employing a new Julia package that I have been working on: <span class="co">[</span><span class="ot">`ConformalPrediction.jl`</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span>.  </span>
<span id="cb11-63"><a href="#cb11-63"></a></span>
<span id="cb11-64"><a href="#cb11-64"></a>:::{.callout-note}</span>
<span id="cb11-65"><a href="#cb11-65"></a><span class="fu">## [`ConformalPrediction.jl`](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span></span>
<span id="cb11-66"><a href="#cb11-66"></a></span>
<span id="cb11-67"><a href="#cb11-67"></a><span class="in">`ConformalPrediction.jl`</span> is a package for uncertainty quantification through conformal prediction for machine learning models trained in <span class="co">[</span><span class="ot">MLJ</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/dev/)</span>. At the time of writing it is still in its early stages of development, but already implements a range of different approaches to CP. Contributions are very much welcome:</span>
<span id="cb11-68"><a href="#cb11-68"></a></span>
<span id="cb11-69"><a href="#cb11-69"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Documentation</span><span class="co">](https://www.patalt.org/ConformalPrediction.jl/stable/)</span></span>
<span id="cb11-70"><a href="#cb11-70"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Contributor's Guide</span><span class="co">](https://www.patalt.org/ConformalPrediction.jl/stable/#Contribute)</span></span>
<span id="cb11-71"><a href="#cb11-71"></a>:::</span>
<span id="cb11-72"><a href="#cb11-72"></a></span>
<span id="cb11-73"><a href="#cb11-73"></a><span class="fu">### Split Conformal Classification {#sec-scp}</span></span>
<span id="cb11-74"><a href="#cb11-74"></a></span>
<span id="cb11-75"><a href="#cb11-75"></a>We consider a simple binary classification problem. Let $(X_i, Y_i), \ i=1,...,n$ denote our feature-label pairs and let $\mu: \mathcal{X} \mapsto \mathcal{Y}$ denote the mapping from features to labels. For illustration purposes we will use the moons dataset 🌙. Using <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> we first generate the data and split into into a training and test set:</span>
<span id="cb11-76"><a href="#cb11-76"></a></span>
<span id="cb11-79"><a href="#cb11-79"></a><span class="in">```{julia}</span></span>
<span id="cb11-80"><a href="#cb11-80"></a><span class="in">using MLJ</span></span>
<span id="cb11-81"><a href="#cb11-81"></a><span class="in">using Random</span></span>
<span id="cb11-82"><a href="#cb11-82"></a><span class="in">Random.seed!(123)</span></span>
<span id="cb11-83"><a href="#cb11-83"></a></span>
<span id="cb11-84"><a href="#cb11-84"></a><span class="in"># Data:</span></span>
<span id="cb11-85"><a href="#cb11-85"></a><span class="in">X, y = make_moons(500; noise=0.15)</span></span>
<span id="cb11-86"><a href="#cb11-86"></a><span class="in">train, test = partition(eachindex(y), 0.8, shuffle=true)</span></span>
<span id="cb11-87"><a href="#cb11-87"></a><span class="in">```</span></span>
<span id="cb11-88"><a href="#cb11-88"></a></span>
<span id="cb11-89"><a href="#cb11-89"></a>Here we will use a specific case of CP called *split conformal prediction* which can then be summarized as follows:^[In other places split conformal prediction is sometimes referred to as *inductive* conformal prediction.]</span>
<span id="cb11-90"><a href="#cb11-90"></a></span>
<span id="cb11-91"><a href="#cb11-91"></a><span class="ss">1. </span>Partition the training into a proper training set and a separate calibration set: $\mathcal{D}_n=\mathcal{D}^{\text{train}} \cup \mathcal{D}^{\text{cali}}$.</span>
<span id="cb11-92"><a href="#cb11-92"></a><span class="ss">2. </span>Train the machine learning model on the proper training set: $\hat\mu_{i \in \mathcal{D}^{\text{train}}}(X_i,Y_i)$.</span>
<span id="cb11-93"><a href="#cb11-93"></a><span class="ss">3. </span>Compute nonconformity scores, $\mathcal{S}$, using the calibration data $\mathcal{D}^{\text{cali}}$ and the fitted model $\hat\mu_{i \in \mathcal{D}^{\text{train}}}$. </span>
<span id="cb11-94"><a href="#cb11-94"></a><span class="ss">4. </span>For a user-specified desired coverage ratio $(1-\alpha)$ compute the corresponding quantile, $\hat{q}$, of the empirical distribution of nonconformity scores, $\mathcal{S}$.</span>
<span id="cb11-95"><a href="#cb11-95"></a><span class="ss">5. </span>For the given quantile and test sample $X_{\text{test}}$, form the corresponding conformal prediction set: </span>
<span id="cb11-96"><a href="#cb11-96"></a></span>
<span id="cb11-97"><a href="#cb11-97"></a>$$</span>
<span id="cb11-98"><a href="#cb11-98"></a>C(X_{\text{test}})=<span class="sc">\{</span>y:s(X_{\text{test}},y) \le \hat{q}<span class="sc">\}</span></span>
<span id="cb11-99"><a href="#cb11-99"></a>$$ {#eq-set}</span>
<span id="cb11-100"><a href="#cb11-100"></a></span>
<span id="cb11-101"><a href="#cb11-101"></a>This is the default procedure used for classification and regression in <span class="co">[</span><span class="ot">`ConformalPrediction.jl`</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span>. </span>
<span id="cb11-102"><a href="#cb11-102"></a></span>
<span id="cb11-103"><a href="#cb11-103"></a>You may want to take a look at the source code for the classification case <span class="co">[</span><span class="ot">here</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L1)</span>. As a <span class="co">[</span><span class="ot">first</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L3)</span> important step, we begin by defining a concrete type <span class="in">`SimpleInductiveClassifier`</span> that wraps a supervised model from <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> and reserves additional fields for a few hyperparameters. As a <span class="co">[</span><span class="ot">second</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L26)</span> step, we define the training procedure, which includes the data-splitting and calibration step. Finally, as a <span class="co">[</span><span class="ot">third</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/67712e870dc3a438bf0846d376fa48480612f042/src/ConformalModels/inductive_classification.jl#L56)</span> step we implement the procedure in @eq-set to compute the conformal prediction set.</span>
<span id="cb11-104"><a href="#cb11-104"></a></span>
<span id="cb11-105"><a href="#cb11-105"></a>:::{.callout-warning}</span>
<span id="cb11-106"><a href="#cb11-106"></a><span class="fu">## Development Status</span></span>
<span id="cb11-107"><a href="#cb11-107"></a></span>
<span id="cb11-108"><a href="#cb11-108"></a>The permalinks above take you to the version of the package that was up-to-date at the time of writing. Since the package is in its early stages of development, the code base and API can be expected to change.</span>
<span id="cb11-109"><a href="#cb11-109"></a>:::</span>
<span id="cb11-110"><a href="#cb11-110"></a></span>
<span id="cb11-111"><a href="#cb11-111"></a>Now let's take this to our 🌙 data. To illustrate the package functionality we will demonstrate the envisioned workflow. We first define our atomic machine learning model following standard <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> conventions. Using <span class="co">[</span><span class="ot">`ConformalPrediction.jl`</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span> we then wrap our atomic model in a conformal model using the standard API call <span class="in">`conformal_model(model::Supervised; kwargs...)`</span>. To train and predict from our conformal model we can then rely on the conventional <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> procedure again. In particular, we wrap our conformal model in data (turning it into a machine) and then fit it on the training set. Finally, we use our machine to predict the label for a new test sample <span class="in">`Xtest`</span>:</span>
<span id="cb11-112"><a href="#cb11-112"></a></span>
<span id="cb11-115"><a href="#cb11-115"></a><span class="in">```{julia}</span></span>
<span id="cb11-116"><a href="#cb11-116"></a><span class="in">#| output: true</span></span>
<span id="cb11-117"><a href="#cb11-117"></a></span>
<span id="cb11-118"><a href="#cb11-118"></a><span class="in"># Model:</span></span>
<span id="cb11-119"><a href="#cb11-119"></a><span class="in">KNNClassifier = @load KNNClassifier pkg=NearestNeighborModels</span></span>
<span id="cb11-120"><a href="#cb11-120"></a><span class="in">model = KNNClassifier(;K=50) </span></span>
<span id="cb11-121"><a href="#cb11-121"></a></span>
<span id="cb11-122"><a href="#cb11-122"></a><span class="in"># Training:</span></span>
<span id="cb11-123"><a href="#cb11-123"></a><span class="in">using ConformalPrediction</span></span>
<span id="cb11-124"><a href="#cb11-124"></a><span class="in">conf_model = conformal_model(model; coverage=.9)</span></span>
<span id="cb11-125"><a href="#cb11-125"></a><span class="in">mach = machine(conf_model, X, y)</span></span>
<span id="cb11-126"><a href="#cb11-126"></a><span class="in">fit!(mach, rows=train)</span></span>
<span id="cb11-127"><a href="#cb11-127"></a></span>
<span id="cb11-128"><a href="#cb11-128"></a><span class="in"># Conformal Prediction:</span></span>
<span id="cb11-129"><a href="#cb11-129"></a><span class="in">Xtest = selectrows(X, first(test))</span></span>
<span id="cb11-130"><a href="#cb11-130"></a><span class="in">ytest = y[first(test)]</span></span>
<span id="cb11-131"><a href="#cb11-131"></a><span class="in">predict(mach, Xtest)[1]</span></span>
<span id="cb11-132"><a href="#cb11-132"></a><span class="in">```</span></span>
<span id="cb11-133"><a href="#cb11-133"></a></span>
<span id="cb11-134"><a href="#cb11-134"></a>The final predictions are set-valued. While the softmax output remains unchanged for the <span class="in">`SimpleInductiveClassifier`</span>, the size of the prediction set depends on the chosen coverage rate, $(1-\alpha)$. </span>
<span id="cb11-137"><a href="#cb11-137"></a><span class="in">```{julia}</span></span>
<span id="cb11-138"><a href="#cb11-138"></a><span class="in">#| echo: false</span></span>
<span id="cb11-139"><a href="#cb11-139"></a><span class="in">#| output: true</span></span>
<span id="cb11-140"><a href="#cb11-140"></a></span>
<span id="cb11-141"><a href="#cb11-141"></a><span class="in">coverage = 1.0</span></span>
<span id="cb11-142"><a href="#cb11-142"></a><span class="in">using Markdown</span></span>
<span id="cb11-143"><a href="#cb11-143"></a><span class="in">Markdown.parse("""</span></span>
<span id="cb11-144"><a href="#cb11-144"></a><span class="in">When specifying a coverage rate very close to one, the prediction set will typically include many (in some cases all) of the possible labels. Below, for example, both classes are included in the prediction set when setting the coverage rate equal to ``(1-\\alpha)``=$coverage. This is intuitive, since high coverage quite literally requires that the true label is covered by the prediction set with high probability.</span></span>
<span id="cb11-145"><a href="#cb11-145"></a><span class="in">""")</span></span>
<span id="cb11-146"><a href="#cb11-146"></a><span class="in">```</span></span>
<span id="cb11-147"><a href="#cb11-147"></a></span>
<span id="cb11-150"><a href="#cb11-150"></a><span class="in">```{julia}</span></span>
<span id="cb11-151"><a href="#cb11-151"></a><span class="in">#| output: true</span></span>
<span id="cb11-152"><a href="#cb11-152"></a></span>
<span id="cb11-153"><a href="#cb11-153"></a><span class="in">conf_model = conformal_model(model; coverage=coverage)</span></span>
<span id="cb11-154"><a href="#cb11-154"></a><span class="in">mach = machine(conf_model, X, y)</span></span>
<span id="cb11-155"><a href="#cb11-155"></a><span class="in">fit!(mach, rows=train)</span></span>
<span id="cb11-156"><a href="#cb11-156"></a></span>
<span id="cb11-157"><a href="#cb11-157"></a><span class="in"># Conformal Prediction:</span></span>
<span id="cb11-158"><a href="#cb11-158"></a><span class="in">Xtest = (x1=[1],x2=[0])</span></span>
<span id="cb11-159"><a href="#cb11-159"></a><span class="in">predict(mach, Xtest)[1]</span></span>
<span id="cb11-160"><a href="#cb11-160"></a><span class="in">```</span></span>
<span id="cb11-161"><a href="#cb11-161"></a></span>
<span id="cb11-164"><a href="#cb11-164"></a><span class="in">```{julia}</span></span>
<span id="cb11-165"><a href="#cb11-165"></a><span class="in">#| echo: false</span></span>
<span id="cb11-166"><a href="#cb11-166"></a><span class="in">#| output: true</span></span>
<span id="cb11-167"><a href="#cb11-167"></a></span>
<span id="cb11-168"><a href="#cb11-168"></a><span class="in">coverage = .1</span></span>
<span id="cb11-169"><a href="#cb11-169"></a><span class="in">using Markdown</span></span>
<span id="cb11-170"><a href="#cb11-170"></a><span class="in">Markdown.parse("""</span></span>
<span id="cb11-171"><a href="#cb11-171"></a><span class="in">Conversely, for low coverage rates, prediction sets can also be empty. For a choice of ``(1-\\alpha)``=$coverage, for example, the prediction set for our test sample is empty. This is a bit difficult to think about intuitively and I have not yet come across a satisfactory, intuitive interpretation.^[Any thoughts/comments welcome!] When the prediction set is empty, the `predict` call currently returns `missing`:</span></span>
<span id="cb11-172"><a href="#cb11-172"></a><span class="in">""")</span></span>
<span id="cb11-173"><a href="#cb11-173"></a><span class="in">```</span></span>
<span id="cb11-174"><a href="#cb11-174"></a></span>
<span id="cb11-177"><a href="#cb11-177"></a><span class="in">```{julia}</span></span>
<span id="cb11-178"><a href="#cb11-178"></a><span class="in">#| output: true</span></span>
<span id="cb11-179"><a href="#cb11-179"></a></span>
<span id="cb11-180"><a href="#cb11-180"></a><span class="in">conf_model = conformal_model(model; coverage=coverage)</span></span>
<span id="cb11-181"><a href="#cb11-181"></a><span class="in">mach = machine(conf_model, X, y)</span></span>
<span id="cb11-182"><a href="#cb11-182"></a><span class="in">fit!(mach, rows=train)</span></span>
<span id="cb11-183"><a href="#cb11-183"></a></span>
<span id="cb11-184"><a href="#cb11-184"></a><span class="in"># Conformal Prediction:</span></span>
<span id="cb11-185"><a href="#cb11-185"></a><span class="in">predict(mach, Xtest)[1]</span></span>
<span id="cb11-186"><a href="#cb11-186"></a><span class="in">```</span></span>
<span id="cb11-187"><a href="#cb11-187"></a></span>
<span id="cb11-190"><a href="#cb11-190"></a><span class="in">```{julia}</span></span>
<span id="cb11-191"><a href="#cb11-191"></a><span class="in">#| echo: false</span></span>
<span id="cb11-192"><a href="#cb11-192"></a><span class="in">using Plots</span></span>
<span id="cb11-193"><a href="#cb11-193"></a></span>
<span id="cb11-194"><a href="#cb11-194"></a><span class="in">function contourf_cp(mach::Machine, x1_range, x2_range; type=:set_size, kwargs...)</span></span>
<span id="cb11-195"><a href="#cb11-195"></a><span class="in">    set_size = []</span></span>
<span id="cb11-196"><a href="#cb11-196"></a><span class="in">    proba = []</span></span>
<span id="cb11-197"><a href="#cb11-197"></a><span class="in">    for x2 in x2_range, x1 in x1_range</span></span>
<span id="cb11-198"><a href="#cb11-198"></a><span class="in">        Xnew = (x1 = [x1], x2 = [x2])</span></span>
<span id="cb11-199"><a href="#cb11-199"></a><span class="in">        p̂ = predict(mach, Xnew)[1]</span></span>
<span id="cb11-200"><a href="#cb11-200"></a><span class="in">        # Set size:</span></span>
<span id="cb11-201"><a href="#cb11-201"></a><span class="in">        z = ismissing(p̂) ? 0 : sum(pdf.(p̂, p̂.decoder.classes) .&gt; 0)</span></span>
<span id="cb11-202"><a href="#cb11-202"></a><span class="in">        push!(set_size, z)</span></span>
<span id="cb11-203"><a href="#cb11-203"></a><span class="in">        # Probability:</span></span>
<span id="cb11-204"><a href="#cb11-204"></a><span class="in">        p = ismissing(p̂) ? p̂ : pdf.(p̂, 1)</span></span>
<span id="cb11-205"><a href="#cb11-205"></a><span class="in">        push!(proba, p)</span></span>
<span id="cb11-206"><a href="#cb11-206"></a><span class="in">    end</span></span>
<span id="cb11-207"><a href="#cb11-207"></a><span class="in">    if type == :set_size</span></span>
<span id="cb11-208"><a href="#cb11-208"></a><span class="in">        plt = contourf(x1_range, x2_range, set_size; clim=(0,2), c=cgrad(:blues, 3, categorical = true),  kwargs...)</span></span>
<span id="cb11-209"><a href="#cb11-209"></a><span class="in">    elseif type == :proba</span></span>
<span id="cb11-210"><a href="#cb11-210"></a><span class="in">        plt = contourf(x1_range, x2_range, proba; c=:thermal, kwargs...)</span></span>
<span id="cb11-211"><a href="#cb11-211"></a><span class="in">    end</span></span>
<span id="cb11-212"><a href="#cb11-212"></a><span class="in">    return plt</span></span>
<span id="cb11-213"><a href="#cb11-213"></a><span class="in">end</span></span>
<span id="cb11-214"><a href="#cb11-214"></a><span class="in">```</span></span>
<span id="cb11-215"><a href="#cb11-215"></a></span>
<span id="cb11-216"><a href="#cb11-216"></a>@fig-anim should provide some more intuition as to what exactly is happening here. It illustrates the effect of the chosen coverage rate on the predicted softmax output and the set size in the two-dimensional feature space. Contours are overlayed with the moon data points (including test data). The two samples highlighted in red, $X_1$ and $X_2$, have been manually added for illustration purposes. Let's look at these one by one.</span>
<span id="cb11-217"><a href="#cb11-217"></a></span>
<span id="cb11-218"><a href="#cb11-218"></a>Firstly, note that $X_1$ (red cross) falls into a region of the domain that is characterized by high predictive uncertainty. It sits right at the bottom-right corner of our class-zero moon 🌜 (orange), a region that is almost entirely enveloped by our class-one moon 🌛 (green). For low coverage rates the prediction set for $X_1$ is empty: on the left-hand side this is indicated by the missing contour for the softmax probability; on the right-hand side we can observe that the corresponding set size is indeed zero. For high coverage rates the prediction set includes both $y=0$ and $y=1$, indicative of the fact that the conformal classifier is uncertain about the true label.</span>
<span id="cb11-219"><a href="#cb11-219"></a></span>
<span id="cb11-220"><a href="#cb11-220"></a>With respect to $X_2$, we observe that while also sitting on the fringe of our class-zero moon, this sample populates a region that is not fully enveloped by data points from the opposite class. In this region, the underlying atomic classifier can be expected to be more certain about its predictions, but still not highly confident. How is this reflected by our corresponding conformal prediction sets? </span>
<span id="cb11-221"><a href="#cb11-221"></a></span>
<span id="cb11-224"><a href="#cb11-224"></a><span class="in">```{julia}</span></span>
<span id="cb11-225"><a href="#cb11-225"></a><span class="in">#| code-fold: true</span></span>
<span id="cb11-226"><a href="#cb11-226"></a></span>
<span id="cb11-227"><a href="#cb11-227"></a><span class="in">Xtest_2 = (x1=[-0.5],x2=[0.25])</span></span>
<span id="cb11-228"><a href="#cb11-228"></a><span class="in">cov_ = .9</span></span>
<span id="cb11-229"><a href="#cb11-229"></a><span class="in">conf_model = conformal_model(model; coverage=cov_)</span></span>
<span id="cb11-230"><a href="#cb11-230"></a><span class="in">mach = machine(conf_model, X, y)</span></span>
<span id="cb11-231"><a href="#cb11-231"></a><span class="in">fit!(mach, rows=train)</span></span>
<span id="cb11-232"><a href="#cb11-232"></a><span class="in">p̂_2 = pdf(predict(mach, Xtest_2)[1], 0)</span></span>
<span id="cb11-233"><a href="#cb11-233"></a><span class="in">```</span></span>
<span id="cb11-234"><a href="#cb11-234"></a></span>
<span id="cb11-237"><a href="#cb11-237"></a><span class="in">```{julia}</span></span>
<span id="cb11-238"><a href="#cb11-238"></a><span class="in">#| echo: false</span></span>
<span id="cb11-239"><a href="#cb11-239"></a><span class="in">#| output: true</span></span>
<span id="cb11-240"><a href="#cb11-240"></a></span>
<span id="cb11-241"><a href="#cb11-241"></a><span class="in">Markdown.parse("""</span></span>
<span id="cb11-242"><a href="#cb11-242"></a><span class="in">Well, for low coverage rates (roughly ``&lt;0.9``) the conformal prediction set does not include ``y=0``: the set size is zero (right panel). Only for higher coverage rates do we have ``C(X_2)=\\{0\\}``: the coverage rate is high enough to include ``y=0``, but the corresponding softmax probability is still fairly low. For example, for ``(1-\\alpha)=$(cov_)`` we have ``\\hat{p}(y=0|X_2)=$(p̂_2).``</span></span>
<span id="cb11-243"><a href="#cb11-243"></a><span class="in">""")</span></span>
<span id="cb11-244"><a href="#cb11-244"></a><span class="in">```</span></span>
<span id="cb11-245"><a href="#cb11-245"></a></span>
<span id="cb11-246"><a href="#cb11-246"></a>These two examples illustrate an interesting point: for regions characterised by high predictive uncertainty, conformal prediction sets are typically empty (for low coverage) or large (for high coverage). While set-valued predictions may be something to get used to, this notion is overall intuitive. </span>
<span id="cb11-247"><a href="#cb11-247"></a></span>
<span id="cb11-250"><a href="#cb11-250"></a><span class="in">```{julia}</span></span>
<span id="cb11-251"><a href="#cb11-251"></a><span class="in">#| output: true</span></span>
<span id="cb11-252"><a href="#cb11-252"></a><span class="in">#| label: fig-anim</span></span>
<span id="cb11-253"><a href="#cb11-253"></a><span class="in">#| fig-cap: "The effect of the coverage rate on the conformal prediction set. Softmax probabilities are shown on the left. The size of the prediction set is shown on the right."</span></span>
<span id="cb11-254"><a href="#cb11-254"></a><span class="in">#| code-fold: true</span></span>
<span id="cb11-255"><a href="#cb11-255"></a></span>
<span id="cb11-256"><a href="#cb11-256"></a><span class="in"># Setup</span></span>
<span id="cb11-257"><a href="#cb11-257"></a><span class="in">coverages = range(0.75,1.0,length=5)</span></span>
<span id="cb11-258"><a href="#cb11-258"></a><span class="in">n = 100</span></span>
<span id="cb11-259"><a href="#cb11-259"></a><span class="in">x1_range = range(extrema(X.x1)...,length=n)</span></span>
<span id="cb11-260"><a href="#cb11-260"></a><span class="in">x2_range = range(extrema(X.x2)...,length=n)</span></span>
<span id="cb11-261"><a href="#cb11-261"></a></span>
<span id="cb11-262"><a href="#cb11-262"></a><span class="in">anim = @animate for coverage in coverages</span></span>
<span id="cb11-263"><a href="#cb11-263"></a><span class="in">    conf_model = conformal_model(model; coverage=coverage)</span></span>
<span id="cb11-264"><a href="#cb11-264"></a><span class="in">    mach = machine(conf_model, X, y)</span></span>
<span id="cb11-265"><a href="#cb11-265"></a><span class="in">    fit!(mach, rows=train)</span></span>
<span id="cb11-266"><a href="#cb11-266"></a><span class="in">    p1 = contourf_cp(mach, x1_range, x2_range; type=:proba, title="Softmax", axis=nothing)</span></span>
<span id="cb11-267"><a href="#cb11-267"></a><span class="in">    scatter!(p1, X.x1, X.x2, group=y, ms=2, msw=0, alpha=0.75)</span></span>
<span id="cb11-268"><a href="#cb11-268"></a><span class="in">    scatter!(p1, Xtest.x1, Xtest.x2, ms=6, c=:red, label="X₁", shape=:cross, msw=6)</span></span>
<span id="cb11-269"><a href="#cb11-269"></a><span class="in">    scatter!(p1, Xtest_2.x1, Xtest_2.x2, ms=6, c=:red, label="X₂", shape=:diamond, msw=6)</span></span>
<span id="cb11-270"><a href="#cb11-270"></a><span class="in">    p2 = contourf_cp(mach, x1_range, x2_range; type=:set_size, title="Set size", axis=nothing)</span></span>
<span id="cb11-271"><a href="#cb11-271"></a><span class="in">    scatter!(p2, X.x1, X.x2, group=y, ms=2, msw=0, alpha=0.75)</span></span>
<span id="cb11-272"><a href="#cb11-272"></a><span class="in">    scatter!(p2, Xtest.x1, Xtest.x2, ms=6, c=:red, label="X₁", shape=:cross, msw=6)</span></span>
<span id="cb11-273"><a href="#cb11-273"></a><span class="in">    scatter!(p2, Xtest_2.x1, Xtest_2.x2, ms=6, c=:red, label="X₂", shape=:diamond, msw=6)</span></span>
<span id="cb11-274"><a href="#cb11-274"></a><span class="in">    plot(p1, p2, plot_title="(1-α)=$(round(coverage,digits=2))", size=(800,300))</span></span>
<span id="cb11-275"><a href="#cb11-275"></a><span class="in">end</span></span>
<span id="cb11-276"><a href="#cb11-276"></a></span>
<span id="cb11-277"><a href="#cb11-277"></a><span class="in">gif(anim, fps=0.5)</span></span>
<span id="cb11-278"><a href="#cb11-278"></a><span class="in">```</span></span>
<span id="cb11-279"><a href="#cb11-279"></a></span>
<span id="cb11-282"><a href="#cb11-282"></a><span class="in">```{julia}</span></span>
<span id="cb11-283"><a href="#cb11-283"></a><span class="in">#| echo: false</span></span>
<span id="cb11-284"><a href="#cb11-284"></a><span class="in">#| eval: false</span></span>
<span id="cb11-285"><a href="#cb11-285"></a></span>
<span id="cb11-286"><a href="#cb11-286"></a><span class="in">using Plots.PlotMeasures</span></span>
<span id="cb11-287"><a href="#cb11-287"></a></span>
<span id="cb11-288"><a href="#cb11-288"></a><span class="in"># Setup</span></span>
<span id="cb11-289"><a href="#cb11-289"></a><span class="in">coverages = range(0.75,1.0,length=25)</span></span>
<span id="cb11-290"><a href="#cb11-290"></a><span class="in">n = 100</span></span>
<span id="cb11-291"><a href="#cb11-291"></a><span class="in">x1_range = range(extrema(X.x1)...,length=n)</span></span>
<span id="cb11-292"><a href="#cb11-292"></a><span class="in">x2_range = range(extrema(X.x2)...,length=n)</span></span>
<span id="cb11-293"><a href="#cb11-293"></a><span class="in">anim = @animate for coverage in coverages</span></span>
<span id="cb11-294"><a href="#cb11-294"></a><span class="in">    conf_model = conformal_model(model; coverage=coverage)</span></span>
<span id="cb11-295"><a href="#cb11-295"></a><span class="in">    mach = machine(conf_model, X, y)</span></span>
<span id="cb11-296"><a href="#cb11-296"></a><span class="in">    fit!(mach, rows=train)</span></span>
<span id="cb11-297"><a href="#cb11-297"></a><span class="in">    plt = contourf_cp(mach, x1_range, x2_range; type=:proba, axis=nothing, size=(500,500), background_color=:transparent, colorbar=false, margin=-1.5mm)</span></span>
<span id="cb11-298"><a href="#cb11-298"></a></span>
<span id="cb11-299"><a href="#cb11-299"></a><span class="in">    # Annotations</span></span>
<span id="cb11-300"><a href="#cb11-300"></a></span>
<span id="cb11-301"><a href="#cb11-301"></a><span class="in">    # First:</span></span>
<span id="cb11-302"><a href="#cb11-302"></a><span class="in">    p̂ = predict(mach, Xtest)[1]</span></span>
<span id="cb11-303"><a href="#cb11-303"></a><span class="in">    if ismissing(p̂)</span></span>
<span id="cb11-304"><a href="#cb11-304"></a><span class="in">        z = "∅"</span></span>
<span id="cb11-305"><a href="#cb11-305"></a><span class="in">    else</span></span>
<span id="cb11-306"><a href="#cb11-306"></a><span class="in">        L = p̂.decoder.classes</span></span>
<span id="cb11-307"><a href="#cb11-307"></a><span class="in">        set_contents = reduce((x,y) -&gt; x * ", " * y, string.(L[pdf.(p̂, L) .&gt; 0]))</span></span>
<span id="cb11-308"><a href="#cb11-308"></a><span class="in">        z = "{$(set_contents)}"</span></span>
<span id="cb11-309"><a href="#cb11-309"></a><span class="in">    end</span></span>
<span id="cb11-310"><a href="#cb11-310"></a><span class="in">    ann_Xtest = (Xtest.x1, Xtest.x2, ("ŷ₁=$z", 20, :white))</span></span>
<span id="cb11-311"><a href="#cb11-311"></a><span class="in">    annotate!(plt, ann_Xtest)</span></span>
<span id="cb11-312"><a href="#cb11-312"></a></span>
<span id="cb11-313"><a href="#cb11-313"></a><span class="in">    # Second</span></span>
<span id="cb11-314"><a href="#cb11-314"></a><span class="in">    p̂ = predict(mach, Xtest_2)[1]</span></span>
<span id="cb11-315"><a href="#cb11-315"></a><span class="in">    if ismissing(p̂)</span></span>
<span id="cb11-316"><a href="#cb11-316"></a><span class="in">        z = "∅"</span></span>
<span id="cb11-317"><a href="#cb11-317"></a><span class="in">    else</span></span>
<span id="cb11-318"><a href="#cb11-318"></a><span class="in">        L = p̂.decoder.classes</span></span>
<span id="cb11-319"><a href="#cb11-319"></a><span class="in">        set_contents = reduce((x,y) -&gt; x * ", " * y, string.(L[pdf.(p̂, L) .&gt; 0]))</span></span>
<span id="cb11-320"><a href="#cb11-320"></a><span class="in">        z = "{$(set_contents)}"</span></span>
<span id="cb11-321"><a href="#cb11-321"></a><span class="in">    end</span></span>
<span id="cb11-322"><a href="#cb11-322"></a><span class="in">    ann_Xtest = (Xtest_2.x1, Xtest_2.x2, ("ŷ₂=$z", 20, :white))</span></span>
<span id="cb11-323"><a href="#cb11-323"></a><span class="in">    annotate!(plt, ann_Xtest)</span></span>
<span id="cb11-324"><a href="#cb11-324"></a><span class="in">end</span></span>
<span id="cb11-325"><a href="#cb11-325"></a><span class="in">gif(anim, "blog/posts/conformal-prediction/www/intro.gif", fps=5)</span></span>
<span id="cb11-326"><a href="#cb11-326"></a></span>
<span id="cb11-327"><a href="#cb11-327"></a><span class="in">anim = @animate for coverage in coverages</span></span>
<span id="cb11-328"><a href="#cb11-328"></a><span class="in">    conf_model = conformal_model(model; coverage=coverage)</span></span>
<span id="cb11-329"><a href="#cb11-329"></a><span class="in">    mach = machine(conf_model, X, y)</span></span>
<span id="cb11-330"><a href="#cb11-330"></a><span class="in">    fit!(mach, rows=train)</span></span>
<span id="cb11-331"><a href="#cb11-331"></a><span class="in">    plt = contourf_cp(mach, x1_range, x2_range; type=:proba, axis=nothing, size=(1200,400), background_color=:transparent, colorbar=false, margin=-1.5mm)</span></span>
<span id="cb11-332"><a href="#cb11-332"></a><span class="in">    </span></span>
<span id="cb11-333"><a href="#cb11-333"></a><span class="in">    # Annotations</span></span>
<span id="cb11-334"><a href="#cb11-334"></a></span>
<span id="cb11-335"><a href="#cb11-335"></a><span class="in">    # First:</span></span>
<span id="cb11-336"><a href="#cb11-336"></a><span class="in">    p̂ = predict(mach, Xtest)[1]</span></span>
<span id="cb11-337"><a href="#cb11-337"></a><span class="in">    if ismissing(p̂)</span></span>
<span id="cb11-338"><a href="#cb11-338"></a><span class="in">        z = "∅"</span></span>
<span id="cb11-339"><a href="#cb11-339"></a><span class="in">    else</span></span>
<span id="cb11-340"><a href="#cb11-340"></a><span class="in">        L = p̂.decoder.classes</span></span>
<span id="cb11-341"><a href="#cb11-341"></a><span class="in">        set_contents = reduce((x,y) -&gt; x * ", " * y, string.(L[pdf.(p̂, L) .&gt; 0]))</span></span>
<span id="cb11-342"><a href="#cb11-342"></a><span class="in">        z = "{$(set_contents)}"</span></span>
<span id="cb11-343"><a href="#cb11-343"></a><span class="in">    end</span></span>
<span id="cb11-344"><a href="#cb11-344"></a><span class="in">    ann_Xtest = (Xtest.x1, Xtest.x2, ("ŷ₁=$z", 20, :white))</span></span>
<span id="cb11-345"><a href="#cb11-345"></a><span class="in">    annotate!(plt, ann_Xtest)</span></span>
<span id="cb11-346"><a href="#cb11-346"></a></span>
<span id="cb11-347"><a href="#cb11-347"></a><span class="in">    # Second</span></span>
<span id="cb11-348"><a href="#cb11-348"></a><span class="in">    p̂ = predict(mach, Xtest_2)[1]</span></span>
<span id="cb11-349"><a href="#cb11-349"></a><span class="in">    if ismissing(p̂)</span></span>
<span id="cb11-350"><a href="#cb11-350"></a><span class="in">        z = "∅"</span></span>
<span id="cb11-351"><a href="#cb11-351"></a><span class="in">    else</span></span>
<span id="cb11-352"><a href="#cb11-352"></a><span class="in">        L = p̂.decoder.classes</span></span>
<span id="cb11-353"><a href="#cb11-353"></a><span class="in">        set_contents = reduce((x,y) -&gt; x * ", " * y, string.(L[pdf.(p̂, L) .&gt; 0]))</span></span>
<span id="cb11-354"><a href="#cb11-354"></a><span class="in">        z = "{$(set_contents)}"</span></span>
<span id="cb11-355"><a href="#cb11-355"></a><span class="in">    end</span></span>
<span id="cb11-356"><a href="#cb11-356"></a><span class="in">    ann_Xtest = (Xtest_2.x1, Xtest_2.x2, ("ŷ₂=$z", 20, :white))</span></span>
<span id="cb11-357"><a href="#cb11-357"></a><span class="in">    annotate!(plt, ann_Xtest)</span></span>
<span id="cb11-358"><a href="#cb11-358"></a><span class="in">end</span></span>
<span id="cb11-359"><a href="#cb11-359"></a><span class="in">gif(anim, "blog/posts/conformal-prediction/www/medium.gif", fps=5)</span></span>
<span id="cb11-360"><a href="#cb11-360"></a><span class="in">```</span></span>
<span id="cb11-361"><a href="#cb11-361"></a></span>
<span id="cb11-362"><a href="#cb11-362"></a></span>
<span id="cb11-363"><a href="#cb11-363"></a><span class="fu">## 🏁 Conclusion</span></span>
<span id="cb11-364"><a href="#cb11-364"></a></span>
<span id="cb11-365"><a href="#cb11-365"></a>This has really been a whistle-stop tour of Conformal Prediction: an active area of research that probably deserves much more attention. Hopefully, though, this post has helped to provide some color and, if anything, made you more curious about the topic. Let's recap the TL;DR from above:</span>
<span id="cb11-366"><a href="#cb11-366"></a></span>
<span id="cb11-367"><a href="#cb11-367"></a><span class="ss">1. </span>Conformal Prediction is an interesting frequentist approach to uncertainty quantification that can even be combined with Bayes (@sec-background).</span>
<span id="cb11-368"><a href="#cb11-368"></a><span class="ss">2. </span>It is scalable and model-agnostic and therefore well applicable to machine learning (@sec-background).</span>
<span id="cb11-369"><a href="#cb11-369"></a><span class="ss">3. </span><span class="co">[</span><span class="ot">`ConformalPrediction.jl`</span><span class="co">](https://github.com/juliatrustworthyai/ConformalPrediction.jl)</span> implements CP in pure Julia and can be used with any supervised model available from <span class="co">[</span><span class="ot">`MLJ.jl`</span><span class="co">](https://alan-turing-institute.github.io/MLJ.jl/v0.18/)</span> (@sec-julia).</span>
<span id="cb11-370"><a href="#cb11-370"></a><span class="ss">4. </span>Implementing CP directly on top of an existing, powerful machine learning toolkit demonstrates the potential usefulness of this framework to the ML community (@sec-julia). </span>
<span id="cb11-371"><a href="#cb11-371"></a><span class="ss">5. </span>Standard conformal classifiers produce set-valued predictions: for ambiguous samples these sets are typically large (for high coverage) or empty (for low coverage) (@sec-scp).</span>
<span id="cb11-372"><a href="#cb11-372"></a></span>
<span id="cb11-373"><a href="#cb11-373"></a>Below I will leave you with some further resources.</span>
<span id="cb11-374"><a href="#cb11-374"></a></span>
<span id="cb11-375"><a href="#cb11-375"></a><span class="fu">## 📚 Further Resources</span></span>
<span id="cb11-376"><a href="#cb11-376"></a></span>
<span id="cb11-377"><a href="#cb11-377"></a>Chances are that you have already come across the Awesome Conformal Prediction <span class="co">[</span><span class="ot">repo</span><span class="co">](https://github.com/valeman/awesome-conformal-prediction)</span>: @manokhin2022awesome provides a comprehensive, up-to-date overview of resources related to the conformal prediction. Among the listed articles you will also find @angelopoulos2021gentle, which inspired much of this post. The repo also points to open-source implementations in other popular programming languages including Python and R.</span>
<span id="cb11-378"><a href="#cb11-378"></a></span>
<span id="cb11-379"><a href="#cb11-379"></a></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2024, Patrick Altmeyer</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/pat-alt/pat-alt.github.io/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.patalt.org/">
      <i class="bi bi-house" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pat-alt">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://julialang.social/@patalt" rel="me">
      <i class="bi bi-mastodon" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://medium.com/\@patrick.altmeyer">
      <i class="bi bi-medium" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>