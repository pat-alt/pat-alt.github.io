[{"authors":null,"categories":null,"content":"Researching Trustworthy Artificial Intelligence (AI) for Finance and Economics. I am an economist by background with an interest in cross-disciplinary research on the intersection of Trustworthy AI - in particular Interpretability, Probabilistic ML, Algorithmic Recourse, Causal Inference - and Financial Economics. Currently I\u0026rsquo;m studying for a PhD in Trustworthy AI under supervision of Cynthia Liem at Delft University of Technology. I\u0026rsquo;m also a member of the AI for Fintech Research collaboration between Delft University of Technology and ING.\nPreviously, I worked as an economist for Bank of England where I was involved in research, monetary policy briefings and market intelligence. I hold two masters degrees from Barcelona School of Economics, one in Data Science and one in Finance. I also hold an undergraduate degree in Economics from the University of Edinburgh.\n  Download my resumé.\n","date":1631750400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1631750400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://www.paltmeyer.com/author/patrick-altmeyer/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/patrick-altmeyer/","section":"authors","summary":"Researching Trustworthy Artificial Intelligence (AI) for Finance and Economics. I am an economist by background with an interest in cross-disciplinary research on the intersection of Trustworthy AI - in particular Interpretability, Probabilistic ML, Algorithmic Recourse, Causal Inference - and Financial Economics.","tags":null,"title":"Patrick Altmeyer","type":"authors"},{"authors":null,"categories":null,"content":"   Table of Contents  What you will learn Program overview Courses in this program Meet your instructor FAQs    What you will learn  Fundamental Python programming skills Statistical concepts and how to apply them in practice Gain experience with the Scikit, including data visualization with Plotly and data wrangling with Pandas  Program overview The demand for skilled data science practitioners is rapidly growing. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi.\nCourses in this program  Python basics Build a foundation in Python.   Visualization Learn how to visualize data with Plotly.   Statistics Introduction to statistics for data science.   Meet your instructor Patrick Altmeyer FAQs Are there prerequisites? There are no prerequisites for the first course.\n How often do the courses run? Continuously, at your own pace.\n  Begin the course   ","date":1611446400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1611446400,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://www.paltmeyer.com/courses/example/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"An example of using Wowchemy's Book layout for publishing online courses.","tags":null,"title":"📊 Learn Data Science","type":"book"},{"authors":null,"categories":null,"content":"Build a foundation in Python.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz What is the difference between lists and tuples? Lists\n Lists are mutable - they can be changed Slower than tuples Syntax: a_list = [1, 2.0, 'Hello world']  Tuples\n Tuples are immutable - they can\u0026rsquo;t be changed Tuples are faster than lists Syntax: a_tuple = (1, 2.0, 'Hello world')   Is Python case-sensitive? Yes\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"17a31b92253d299002593b7491eedeea","permalink":"https://www.paltmeyer.com/courses/example/python/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/python/","section":"courses","summary":"Build a foundation in Python.\n","tags":null,"title":"Python basics","type":"book"},{"authors":null,"categories":null,"content":"Learn how to visualize data with Plotly.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz When is a heatmap useful? Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n Write Plotly code to render a bar chart import plotly.express as px data_canada = px.data.gapminder().query(\u0026#34;country == \u0026#39;Canada\u0026#39;\u0026#34;) fig = px.bar(data_canada, x=\u0026#39;year\u0026#39;, y=\u0026#39;pop\u0026#39;) fig.show() \n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"1b341b3479c8c6b1f807553b77e21b7c","permalink":"https://www.paltmeyer.com/courses/example/visualization/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/visualization/","section":"courses","summary":"Learn how to visualize data with Plotly.\n","tags":null,"title":"Visualization","type":"book"},{"authors":null,"categories":null,"content":"Introduction to statistics for data science.\n  1-2 hours per week, for 8 weeks\nLearn The general form of the normal probability density function is:\n$$ f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi} } e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2} $$\n The parameter $\\mu$ is the mean or expectation of the distribution. $\\sigma$ is its standard deviation. The variance of the distribution is $\\sigma^{2}$.   Quiz What is the parameter $\\mu$? The parameter $\\mu$ is the mean or expectation of the distribution.\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"6f4078728d71b1b791d39f218bf2bdb1","permalink":"https://www.paltmeyer.com/courses/example/stats/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/stats/","section":"courses","summary":"Introduction to statistics for data science.\n","tags":null,"title":"Statistics","type":"book"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://www.paltmeyer.com/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":[],"categories":["Trustworthy AI"],"content":"  Uncertainty   Simulation of changing parameter distribution.    If you’ve ever searched for evaluation metrics to assess model accuracy, chances are that you found many different options to choose from (too many?). Accuracy is in some sense the holy grail of prediction so it’s not at all surprising that the machine learning community spends a lot time thinking about it. In a world where more and more high-stake decisions are being automated, model accuracy is in fact a very valid concern.\nBut does this recipe for model evaluation seem like a sound and complete approach to automated decision-making? Haven’t we forgot anything? Some would argue that we need to pay more attention to model uncertainty. No matter how many times you have cross-validated your model, the loss metric that it is being optimized against as well as its parameters and predictions remain inherently random variables. Focusing merely on prediction accuracy and ignoring uncertainty altogether can install a false level of confidence in automated decision-making systems. Any trustworthy approach to learning from data should therefore at the very least be transparent about its own uncertainty.\nHow can we estimate uncertainty around model parameters and predictions? Frequentist methods for uncertainty quantification generally involve either closed-form solutions based on asymptotic theory or bootstrapping (see for example here for the case of logistic regression). In Bayesian statistics and machine learning we are instead concerned with modelling the posterior distribution over model parameters. This approach to uncertainty quantification is known as Bayesian Inference because we treat model parameters in a Bayesian way: we make assumptions about their distribution based on prior knowledge or beliefs and update these beliefs in light of new evidence. The frequentist approach avoids the need for being explicit about prior beliefs, which in the past has sometimes been considered as unscientific. However, frequentist methods come with their own assumptions and pitfalls (see for example Murphy (2012)) for a discussion). Without diving further into this argument, let us now see how Bayesian Logistic Regression can be implemented from the bottom up.\n The ground truth In this post we will work with a synthetic toy data set \\(\\mathcal{D}\\) composed of \\(N\\) binary labels \\(y_n\\in\\{0,1\\}\\) and corresponding feature vectors \\(\\mathbf{x}_n\\in \\mathbb{R}^D\\). Working with synthetic data has the benefit that we have control over the ground truth that generates our data. In particular, we will assume that the binary labels \\(y_n\\) are generated by a logistic regression model\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; p(y_n|\\mathbf{x}_n;\\mathbf{w})\u0026amp;\\sim\\text{Ber}(y_n|\\sigma(\\mathbf{w}^T\\mathbf{x}_n)) \\\\ \\end{aligned} \\tag{1} \\end{equation} \\]\nwhere \\(\\sigma(a)=1/(1+e^{-a})\\) is the sigmoid or logit function (Murphy 2022).1 Features are generated from a mixed Gaussian model.\nTo add a little bit of life to our example we will assume that the binary labels classify samples into cats and dogs, based on their height and tail length. Figure 1 shows the synthetic data in the two-dimensional feature domain. Following an introduction to Bayesian Logistic Regression in the next section we will use the synthetic data \\(\\mathcal{D}\\) to estimate our model.\n Figure 1: Ground truth labels.   The maths Estimation usually boils down to finding the vector of parameters \\(\\hat{\\mathbf{w}}\\) that maximizes the likelihood of observing \\(\\mathcal{D}\\) under the assumed model. That estimate can then be used to compute predictions for some new unlabelled data set \\(\\mathcal{D}=\\{x_m:m=1,...,M\\}\\).\nProblem setup The starting point for Bayesian Logistic Regression is Bayes’ Theorem:\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; p(\\mathbf{w}|\\mathcal{D})\u0026amp;\\propto p(\\mathcal{D}|\\mathbf{w})p(\\mathbf{w}) \\\\ \\end{aligned} \\tag{2} \\end{equation} \\] Formally, this says that the posterior distribution of parameters \\(\\mathbf{w}\\) is proportional to the product of the likelihood of observing \\(\\mathcal{D}\\) given \\(\\mathbf{w}\\) and the prior density of \\(\\mathbf{w}\\). Applied to our context this can intuitively be understood as follows: our posterior beliefs around \\(\\mathbf{w}\\) are formed by both our prior beliefs and the evidence we observe. Yet another way to look at this is that maximising (2) with respect to \\(\\mathbf{w}\\) corresponds to maximum likelihood estimation regularized by prior beliefs (we will come back to this).\nUnder the assumption that individual label-feature pairs are independently and identically distributed, their joint likelihood is simply the product over their individual densities. The prior beliefs around \\(\\mathbf{w}\\) are at our discretion. In practice they may be derived from previous experiments. Here we will use a zero-mean spherical Gaussian prior for reasons explained further below. To sum this up we have\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; p(\\mathcal{D}|\\mathbf{w})\u0026amp; \\sim \\prod_{n=1}^N p(y_n|\\mathbf{x}_n;\\mathbf{w})\\\\ \u0026amp;\u0026amp; p(\\mathbf{w})\u0026amp; \\sim \\mathcal{N} \\left( \\mathbf{w} | \\mathbf{w}_0, \\Sigma_0 \\right) \\\\ \\end{aligned} \\tag{3} \\end{equation} \\]\nwith \\(\\mathbf{w}_0=\\mathbf{0}\\) and \\(\\Sigma_0=\\sigma^2\\mathbf{I}\\). Plugging this into Bayes’ rule we finally have\n\\[ \\begin{aligned} \u0026amp;\u0026amp; p(\\mathbf{w}|\\mathcal{D})\u0026amp;\\propto\\prod_{n=1}^N \\text{Ber}(y_n|\\sigma(\\mathbf{w}^T\\mathbf{x}_n))\\mathcal{N} \\left( \\mathbf{w} | \\mathbf{w}_0, \\Sigma_0 \\right) \\\\ \\end{aligned} \\]\nUnlike with linear regression there are no closed-form analytical solutions to estimating or maximising this posterior, but fortunately accurate approximations do exist (Murphy 2022). One of the simplest approaches called Laplace Approximation is straight-forward to implement and computationally very efficient. It relies on the observation that under the assumption of a Gaussian prior, the posterior of logistic regression is also approximately Gaussian: in particular, this Gaussian distribution is centered around the maximum a posteriori (MAP) estimate \\(\\hat{\\mathbf{w}}=\\arg\\max_{\\mathbf{w}} p(\\mathbf{w}|\\mathcal{D})\\) with a covariance matrix equal to the inverse Hessian evaluated at the mode \\(\\hat{\\Sigma}=(\\mathbf{H}(\\hat{\\mathbf{w}}))^{-1}\\). With that in mind, finding \\(\\hat{\\mathbf{w}}\\) seems like a natural next step.\n Solving the problem In practice we do not maximize the posterior \\(p(\\mathbf{w}|\\mathcal{D})\\) directly. Instead we minimize the negative log likelihood, which is an equivalent optimization problem and easier to implement. In (4) below I have denoted the negative log likelihood as \\(\\ell(\\mathbf{w})\\) indicating that this is the loss function we aim to minimize. The following two lines in (4) show the gradient and Hessian - so the first- and second-order derivatives of \\(\\ell\\) with respect to \\(\\mathbf{w}\\) - where \\(\\mathbf{H}_0=\\Sigma_0^{-1}\\) and \\(\\mu_n=\\sigma(\\mathbf{w}^T\\mathbf{x}_n)\\). To understand how exactly the gradient and Hessian are derived see for example chapter 10 in Murphy (2022).2.\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\ell(\\mathbf{w})\u0026amp;=- \\sum_{n=1}^{N} [y_n \\log \\mu_n + (1-y_n)\\log (1-\\mu_n)] + \\frac{1}{2} (\\mathbf{w}-\\mathbf{w}_0)^T\\mathbf{H}_0(\\mathbf{w}-\\mathbf{w}_0) \\\\ \u0026amp;\u0026amp; \\nabla_{\\mathbf{w}}\\ell(\\mathbf{w})\u0026amp;= \\sum_{n=1}^{N} (\\mu_n-y_n) \\mathbf{x}_n + \\mathbf{H}_0(\\mathbf{w}-\\mathbf{w}_0) \\\\ \u0026amp;\u0026amp; \\nabla^2_{\\mathbf{w}}\\ell(\\mathbf{w})\u0026amp;= \\sum_{n=1}^{N} (\\mu_n-y_n) \\left( \\mu_n(1-\\mu_n) \\mathbf{x}_n \\mathbf{x}_n^T \\right) + \\mathbf{H}_0\\\\ \\end{aligned} \\tag{4} \\end{equation} \\]\nSIDENOTE 💡\nNote how earlier I mentioned that maximising the posterior likelihood can be seen as regularized maximum likelihood estimation. We can now make that connection explicit: in (4) let us assume that \\(\\mathbf{w}_0=\\mathbf{0}\\). Then since \\(\\mathbf{H}_0=\\lambda\\mathbf{I}\\) with \\(1/\\sigma^2\\) the second term in the first line is simply \\(\\lambda \\frac{1}{2} \\mathbf{w}^T\\mathbf{w}=\\lambda \\frac{1}{2} ||\\mathbf{w}||_2^2\\). This is equivalent to running logistic regression with an \\(\\ell_2\\)-penalty (Bishop 2006).\n \nSince minimizing the loss function in (4) is a convex optimization problem we have many efficient algorithms to choose from in order to solve this problem. With the Hessian at hand it seems natural to use a second-order method, because incorporating information about the curvature of the loss function generally leads to faster convergence. Here we will implement Newton’s method in line with the presentation in chapter 8 of Murphy (2022).\n Posterior predictive Suppose now that we have trained the Bayesian Logistic Regression model as our binary classifier \\(g_N(\\mathbf{x})\\) using our training data \\(\\mathcal{D}\\). A new unlabelled sample \\((\\mathbf{x}_{N+1},?)\\) arrives. As with any binary classifier we can predict the missing label by simply plugging the new sample into our classifier \\(\\hat{y}_{N+1}=g_N(\\mathbf{x}_{N+1})=\\sigma(\\hat{\\mathbf{w}}^T\\mathbf{x}_{N+1})\\), where \\(\\hat{\\mathbf{w}}\\) is the MAP estimate as before. If at training phase we have found \\(g_N(\\mathbf{x})\\) to achieve good accuracy, we may expect \\((\\mathbf{x}_{N+1},\\hat{y}_{N+1})\\) to be a reasonably good approximation of the true and unobserved pair \\((\\mathbf{x}_{N+1},y_{N+1})\\). But since we are still dealing with an expected value of a random variable, we would generally like to have an idea of how noisy this prediction is.\nFormally, we are interested in the posterior predictive distribution:\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; p(y=1|\\mathbf{x}, \\mathcal{D})\u0026amp;= \\int \\sigma(\\mathbf{w}^T \\mathbf{x})p(\\mathbf{w}|\\mathcal{D})d\\mathbf{w} \\\\ \\end{aligned} \\tag{5} \\end{equation} \\]\nSIDENOTE 💡\nThe approach that ignores uncertainty altogether corresponds to what is referred to as plugin approximation of the posterior predictive. Formally, it imposes \\(p(y=1|\\mathbf{x}, \\mathcal{D})\\approx p(y=1|\\mathbf{x}, \\hat{\\mathbf{w}})\\).\n \nWith the posterior distribution over model parameters \\(p(\\mathbf{w}|\\mathcal{D})\\) at hand we have the necessary ingredients to estimate the posterior predictive distribution \\(p(y=1|\\mathbf{x}, \\mathcal{D})\\).\nAn obvious, but computationally expensive way to estimate it is through Monte Carlo: draw \\(\\mathbf{w}_s\\) from \\(p(\\mathbf{w}|\\mathcal{D})\\) for \\(s=1:S\\) and compute fitted values \\(\\sigma(\\mathbf{w_s}^T\\mathbf{x})\\) each. Then the posterior predictive distribution corresponds to the average over all fitted values, \\(p(y=1|\\mathbf{x}, \\mathcal{D})=1/S \\sum_{s=1}^{S}\\sigma(\\mathbf{w_s}^T\\mathbf{x})\\). By the law of large numbers the Monte Carlo estimate is an accurate estimate of the true posterior predictive for large enough \\(S\\). Of course, “large enough” is somewhat loosely defined here and depending on the problem can mean “very large.” Consequently, the computational costs involved essentially know no upper bound.\nFortunately, it turns out that we can trade off a little bit of accuracy in return for a convenient analytical solution. In particular, we have that \\(\\sigma(a) \\approx \\Phi(\\lambda a)\\) where \\(\\Phi(.)\\) is the standard Gaussian cdf and \\(\\lambda=\\pi/8\\) ensures that the two functions have the same slope at the origin (Figure 2). Without dwelling further on the details we can use this finding to approximate the integral in (5) as a sigmoid function. This is called probit approximation and implemented below.\n Figure 2: Demonstration of the probit approximation.    The code We now have all the necessary ingredients to code Bayesian Logistic Regression up from scratch. While in practice we would usually want to rely on existing packages that have been properly tested, I often find it very educative and rewarding to program algorithms from the bottom up. You will see that Julia’s syntax so closely resembles the mathematical formulas we have seen above, that going from maths to code is incredibly easy. Seeing those formulas and algorithms then actually doing their magic is quite fun! The code chunk below, for example, shows the implementation of the loss function and its derivatives from (4) above. Take a moment to go through the code line-by-line and try to understand how it relates back to the equations in (4). Isn’t it amazing how closely the code resembles the actual equations?\n Aside from the optimization routine this is essentially all there is to coding up Bayesian Logistic Regression from scratch in Julia Language. If you are curious to see the full source code in detail you can check out this interactive notebook. Now let us finally turn back to our synthetic data and see how Bayesian Logistic Regression can help us understand the uncertainty around our model predictions.\nDISCLAIMER ❗️\nI should mention that this is the first time I program in Julia, so for any Julia pros out there: please bear with me! Happy to hear your suggestions/comments.\n \n The estimates Figure 3 below shows the resulting posterior distribution for \\(w_2\\) and \\(w_3\\) at varying degrees of prior uncertainty \\(\\sigma\\). The constant \\(w_1\\) is held constant at the mode (\\(\\hat{w}_1\\)). The red dot indicates the MLE. Note how for the choice of \\(\\sigma\\rightarrow 0\\) the posterior is equal to the prior. This is intuitive since we have imposed that we have no uncertainty around our prior beliefs and hence no amount of new evidence can move us in any direction. Conversely, for \\(\\sigma \\rightarrow \\infty\\) the posterior distribution is centered around the unconstrained MLE: prior knowledge is very uncertain and hence the posterior is dominated by the likelihood of the data.\n Figure 3: Posterior distribution for \\(w_2\\) and \\(w_3\\) at varying degrees of prior uncertainty \\(\\sigma\\).  What about the posterior predictive? The story is similar: since for \\(\\sigma\\rightarrow 0\\) the posterior is completely dominated by the zero-mean prior we have \\(p(y=1|\\mathbf{x},\\hat{\\mathbf{w}})=0.5\\) everywhere (top left panel in Figure 4). As we gradually increase uncertainty around our prior the predictive posterior depends more and more on the data \\(\\mathcal{D}\\): uncertainty around predicted labels is high only in regions that are not populated by samples \\((y_n, \\mathbf{x}_n)\\). Not surprisingly, this effect is strongest for the MLE (\\(\\sigma\\rightarrow \\infty\\)) where we see some evidence of overfitting.\n Figure 4: Predictive posterior distribution at varying degrees of prior uncertainty \\(\\sigma\\).   Wrapping up In this post we have seen how Bayesian Logistic Regression can be implemented from scratch in Julia language. The estimated posterior distribution over model parameters can be used to quantify uncertainty around coefficients and model predictions. I have argued that it is important to be transparent about model uncertainty to avoid being overly confident in estimates.\nThere are many more benefits associated with Bayesian (probabilistic) machine learning. Understanding where in the input domain our model exerts high uncertainty can for example be instrumental in labelling data: see for example Gal, Islam, and Ghahramani (2017) and follow-up works for an interesting application to active learning for image data. Similarly, there is a recent work that uses estimates of the posterior predictive in the context of algorithmic recourse (Schut et al. 2021). For a brief introduction to algorithmic recourse see one of my previous posts.\nAs a great reference for further reading about probabilistic machine learning I can highly recommend Murphy (2022). An electronic version of the book is currently freely available as a draft. Finally, remember that if you want to try yourself at the code, you can check out this interactive notebook.\n References Bishop, Christopher M. 2006. Pattern Recognition and Machine Learning. springer.  Gal, Yarin, Riashat Islam, and Zoubin Ghahramani. 2017. “Deep Bayesian Active Learning with Image Data.” In International Conference on Machine Learning, 1183–92. PMLR.  Murphy, Kevin P. 2012. Machine Learning: A Probabilistic Perspective. MIT press.  ———. 2022. Probabilistic Machine Learning: An Introduction. MIT Press.  Schut, Lisa, Oscar Key, Rory Mc Grath, Luca Costabello, Bogdan Sacaleanu, Yarin Gal, et al. 2021. “Generating Interpretable Counterfactual Explanations by Implicit Minimisation of Epistemic and Aleatoric Uncertainties.” In International Conference on Artificial Intelligence and Statistics, 1756–64. PMLR.     We let \\(\\mathbf{w}=(10, 0.75, -2.5)^T\\) define the true coefficients.↩︎\n Note that the author works with the negative log likelihood scaled by the sample size↩︎\n   ","date":1636934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636934400,"objectID":"510622e5d595e9931671e92b9d642d1b","permalink":"https://www.paltmeyer.com/post/bayesian-logistic-regression/","publishdate":"2021-11-15T00:00:00Z","relpermalink":"/post/bayesian-logistic-regression/","section":"post","summary":"An introduction to Bayesian Logistic Regression from the bottom up with examples in Julia language.","tags":["bayes","logit","julialang"],"title":"Bayesian Logistic Regression","type":"post"},{"authors":["Patrick Altmeyer","Marc Agustí","Ignacio Vidal-Quadras Costa"],"categories":null,"content":"","date":1631750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1631750400,"objectID":"a3ae06d018900908654b60702447493f","permalink":"https://www.paltmeyer.com/publication/agusti2021deep/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/agusti2021deep/","section":"publication","summary":"We offer a simple way to integrate deep learning into VARs without deviating too much from the trusted and established framework. By fitting each equation of the VAR system with a deep neural network, the Deep VAR outperforms its conventional benchmark in terms of in-sample fit, out-of-sample fit and point forecasting accuracy.","tags":["Deep Learning","Vector Autoregression","Monetary Policy"],"title":"Deep Vector Autoregression","type":"publication"},{"authors":null,"categories":["Trustworthy AI"],"content":"   “You cannot appeal to [algorithms]. They do not listen. Nor do they bend.”\n— Cathy O’Neil\n In her popular book Weapons of Math Destruction Cathy O’Neil presents the example of public school teacher Sarah Wysocki, who lost her job after a teacher evaluation algorithm had rendered her redundant (O’neil 2016). Sarah was highly popular among her peers, supervisors and students.\nThis post looks at a novel algorithmic solution to the problem that individuals like Sarah, who are faced with an undesirable outcome, should be provided with means to revise that outcome. The literature commonly refers to this as individual recourse. One of the first approaches towards individual recourse was proposed by Ustun, Spangher, and Liu (2019). In a recent follow-up paper, Joshi et al. (2019) propose a methodology coined REVISE, which extends the earlier approach in at least three key ways:\nREVISE provides a framework that avoids suggesting an unrealistic set of changes by imposing a threshold likelihood on the revised attributes. It is applicable to a broader class of models including Black Box classifiers and structural causal models. It can be used to detect poorly defined proxies and biases.  For a detailed discussion of these points you may check out this slide deck or consult the paper directly (freely available on DeepAI). Here, we will abstract from some of these complications and instead look at an application of a slightly simplified version of REVISE. This should help us to first build a good intuition. Readers interested in the technicalities and code may find all of this in the annex below.\nFrom 🐱 to 🐶 We will explain REVISE through a short tale of cats and dogs. The protagonist of this tale is Kitty 🐱, a young cat that identifies as a dog. Unfortunately, Kitty is not very tall and her tail, though short for a cat, is longer than that of the average dog (Figure 1).\n Figure 1: Empirical distributions of simulated data set describing cats and dogs. Vertical stalks represent Kitty’s attribute values.  Much to her dismay, Kitty has been recognized as a cat by a linear classifier \\(g_n(X)\\) that we trained through stochastic gradient descent using the data on animals’ height and tail length. Once again interested readers may find technical details and code in the annex below. Figure 2 shows the resulting linear separation in the attribute space with the decision boundary in solid black and Kitty’s location indicated by a red circle. Can we provide individual recourse to Kitty?\n Figure 2: Linear separation of cats and dogs in the 2-dimensional attribute space with the decision boundary of the fitted classifier in solid black. Kitty’s location is indicated by a red circle.  Let’s see if and how we can apply REVISE to Kitty’s problem. The following summary should give you some flavour of how the algorithm works:\nInitialize \\(\\mathbf{x}_i\u0026#39;^{(0)}\\), that is the attributes that will be revised recursively. Kitty’s original attributes seem like a reasonable place to start. Through gradient descent recursively revise \\(\\mathbf{x}_i\u0026#39;^{(t)}\\) until \\(g_n(\\mathbf{x}_i\u0026#39;^{(T)})=\\)🐶. At this point \\(T\\) the descent terminates since for these revised attributes the classifier labels Kitty as a dog. Return \\(\\delta_i=\\mathbf{x}_i\u0026#39;^{(T)}-\\mathbf{x}_i\\), that is the individual recourse for Kitty.  Figure 3 illustrates what happens when this approach is applied to Kitty’s problem. The different panels show the results for different values of a regularization parameter \\(\\lambda\\) that governs the trade-off between achieving the desired label switch and keeping the distance between the original (\\(\\mathbf{x}_i\\)) and revised (\\(\\mathbf{x}_i\u0026#39;\\)) attributes small. In all but one case, REVISE converges: a decrease in tail length along with an increase in height eventually allows Kitty to cross the decision boundary. In other words, we have successfully turned Kitty into a dog - at least in the eyes of the linear classifier!\nWe also observe that as we increase \\(\\lambda\\) for a fixed learning rate, REVISE takes longer to converge. This should come as no surprise, since higher values of \\(\\lambda\\) lead to greater regularization with respect to the penalty we place on the distance that Kitty has to travel. When we penalize too much (\\(\\lambda=10\\)), Kitty never reaches the decision boundary, because she is reluctant to change her characteristics beyond a certain point. While not visible to the naked eye, in this particular example \\(\\lambda=0.001\\) corresponds to the best choice among the candidate values.\n Figure 3: The simplified REVISE algorithm in action: how Kitty crosses the decision boundary by changing her attributes. Regularization with respect to the distance penalty increases from top left to bottom right.   Discussion While hopefully Kitty’s journey has provided you with some useful intuition, the story is of course very silly. Even if your cat ever seems to signal that she wants to be a dog, helping her cross that decision boundary will be tricky. Some attributes are simply immutable or very difficult to change, which Joshi et al. (2019) do not fail to account for in their framework. Their proposed methodology offers a simple and ingenious approach towards providing individual recourse. Instead of concerning ourselves with Black Box interpretability, why not simply provide remedy in case things go wrong?\nTo some extent that idea has its merit. As this post has hopefully shown, REVISE is straight-forward to understand and readily applicable. It could be a very useful tool to provide individual recourse in many real-world applications. As the implementation of our simplified version of REVISE demonstrates, researchers should also find it relatively easy to develop the methodology further and tailor it to specific use cases. The simpler version here, for example, may be useful in settings where the dimensionality is relatively small and one can reasonably model the distribution of attributes without the need for generative models.\nStill, you may be wondering: if the original classifier is based on poorly defined rules and proxies, then what good does REVISE really do? Going back to the example of high-school teacher Sarah Wysocki, one of the key attributes determining teachers’ evaluations was their students’ performance. Realizing this, some teachers took the shortest route to success by artificially inflating their students’ test scores. That same course of action may well have been suggested by REVISE. As Joshi et al. (2019) demonstrate, this very property of REVISE may actually proof useful in detecting weaknesses of decision making systems before setting them loose (key contribution 3).\nNonetheless, the example above also demonstrates that approaches like REVISE, useful as they may be, tend to provide solutions for very particular problems. In reality data-driven decision making systems are often subject to many different problems and hence research on trustworthy AI will need to tackle the issue from various angles. A few places to start include the question of dealing with data that is inherently biased, improving ad-hoc and post-hoc model interpretability and continuing efforts around causality-inspired AI.\n References Joshi, Shalmali, Oluwasanmi Koyejo, Warut Vijitbenjaronk, Been Kim, and Joydeep Ghosh. 2019. “Towards Realistic Individual Recourse and Actionable Explanations in Black-Box Decision Making Systems.” arXiv Preprint arXiv:1907.09615.  O’neil, Cathy. 2016. Weapons of Math Destruction: How Big Data Increases Inequality and Threatens Democracy. Crown.  Ustun, Berk, Alexander Spangher, and Yang Liu. 2019. “Actionable Recourse in Linear Classification.” In Proceedings of the Conference on Fairness, Accountability, and Transparency, 10–19.    Annex In my blog posts I aim to implement interesting ideas from scratch even if that sometimes means that things need to undergo some sort of simplification. The benefit of this approach is that the experience is educationally rewarding - both for myself and hopefully also for readers. The first two sections of this annex show how REVISE and linear classification can be implemented in R. The final section just shows how the synthetic data was generated. To also inspect the code that generates the visualizations and everything else, you can find the source code of this file on GitHub.\nLinear classifier Linear classification is implemented through stochastic gradient descent (SGD) with Hinge loss\n\\[ \\begin{aligned} \u0026amp;\u0026amp; \\ell(-\\mathbf{w}^T\\mathbf{x}_i y_i)\u0026amp;=(1-\\mathbf{w}^T\\mathbf{x}_i y_i)_+ \\\\ \\end{aligned} \\]\nwhere \\(\\mathbf{w}\\) is a coefficient vector, \\(\\mathbf{x}_i\\) is the attribute vector of individual \\(i\\) and \\(y_i\\) is the individual’s outcome. Since we apply SGD in order to minimize the loss function \\(\\ell\\) by varying \\(\\mathbf{w}\\), we need an expression for its gradient with respect to \\(\\mathbf{w}\\), which is given by:\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\nabla_{\\mathbf{W}} \\left( \\ell(-\\mathbf{w}^T\\mathbf{x}_i y_i) \\right) \u0026amp;= \\begin{cases} -\\mathbf{x}_i y_i \u0026amp; \\text{if} \\ \\ \\ \\mathbf{w}^T\\mathbf{x}_i y_i \\le 1\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} \\\\ \\end{aligned} \\tag{1} \\end{equation}\\]\nThe code below uses this analytical solution to perform SGD over \\(T\\) iterations or as long as updates yield feasible parameter values. As the final vector of coefficients the function returns \\(\\mathbf{\\bar{w}}= \\frac{1}{T} \\sum_{t=1}^{T} \\mathbf{w}_t\\). Denoting the optimal coefficient vector as \\(\\mathbf{w}^*\\), it can be shown that under certain conditions \\(\\ell(\\mathbf{\\bar{w}})\\rightarrow\\ell(\\mathbf{w}^*)\\) as \\(T\\rightarrow\\infty\\).\n#\u0026#39; Stochastic gradient descent #\u0026#39; #\u0026#39; @param X Feature matrix. #\u0026#39; @param y Vector containing training labels. #\u0026#39; @param eta Learning rate. #\u0026#39; @param n_iter Maximum number of iterations. #\u0026#39; @param w_init Initial parameter values. #\u0026#39; @param save_steps Boolean checking if coefficients should be saved at each step. #\u0026#39; #\u0026#39; @return #\u0026#39; @export #\u0026#39; #\u0026#39; @author Patrick Altmeyer linear_classifier \u0026lt;- function(X,y,eta=0.001,n_iter=1000,w_init=NULL,save_steps=FALSE) { # Initialization: ---- n \u0026lt;- nrow(X) # number of observations d \u0026lt;- ncol(X) # number of dimensions if (is.null(w_init)) { w \u0026lt;- matrix(rep(0,d)) # initialize coefficients as zero... } else { w \u0026lt;- matrix(w_init) # ...unless initial values have been provided. } w_avg \u0026lt;- 1/n_iter * w # initialize average coefficients iter \u0026lt;- 1 # iteration count if (save_steps) { steps \u0026lt;- data.table(iter=0, w=c(w), d=1:d) # if desired, save coefficient at each step } else { steps \u0026lt;- NA } feasible_w \u0026lt;- TRUE # to check if coefficients are finite, non-nan, ... # Surrogate loss: l \u0026lt;- function(X,y,w) { x \u0026lt;- (-1) * crossprod(X,w) * y pmax(0,1 + x) # Hinge loss } grad \u0026lt;- function(X,y,w) { X %*% ifelse(crossprod(X,w) * y\u0026lt;=1,-y,0) # Gradient of Hinge loss } # Stochastic gradient descent: ---- while (feasible_w \u0026amp; iter\u0026lt;n_iter) { t \u0026lt;- sample(1:n,1) # random draw X_t \u0026lt;- matrix(X[t,]) y_t \u0026lt;- matrix(y[t]) v_t \u0026lt;- grad(X_t,y_t,w) # compute estimate of gradient # Update: w \u0026lt;- w - eta * v_t # update coefficient vector feasible_w \u0026lt;- all(sapply(w, function(i) !is.na(i) \u0026amp; is.finite(i))) # check if feasible if (feasible_w) { w_avg \u0026lt;- w_avg + 1/n_iter * w # update average } if (save_steps) { steps \u0026lt;- rbind(steps, data.table(iter=iter, w=c(w), d=1:d)) } iter \u0026lt;- iter + 1 # increase counter } # Output: ---- output \u0026lt;- list( X = X, y = matrix(y), coefficients = w_avg, eta = eta, n_iter = n_iter, steps = steps ) class(output) \u0026lt;- \u0026quot;classifier\u0026quot; # assign S3 class return(output) } # Methods: ---- print.classifier \u0026lt;- function(classifier) { print(\u0026quot;Coefficients:\u0026quot;) print(classifier$coefficients) } print \u0026lt;- function(classifier) { UseMethod(\u0026quot;print\u0026quot;) } predict.classifier \u0026lt;- function(classifier, newdata=NULL, discrete=TRUE) { if (!is.null(newdata)) { fitted \u0026lt;- newdata %*% classifier$coefficients # out-of-sampple prediction } else { fitted \u0026lt;- classifier$X %*% classifier$coefficients # in-sample fit } if (discrete) { fitted \u0026lt;- sign(fitted) # map to {-1,1} } return(fitted) } predict \u0026lt;- function(classifier, newdata=NULL, discrete=TRUE) { UseMethod(\u0026quot;predict\u0026quot;) }  REVISE (simplified) As flagged above, we are looking at a slightly simplified version of the algorithm presented in Joshi et al. (2019). In particular, the approach here does not incorporate the threshold on the likelihood nor does it account for immutable attributes.\nLet \\(y\\in\\{-1,1\\}\\) be a binary outcome variable, \\(X\\in\\mathbb{R}^d\\) a feature matrix containing individuals’ attributes and \\(g_n(X)\\) a corresponding data-dependent classifier. Suppose \\(y_i=-1\\) (the negative outcome) for some individual characterized by attributes \\(\\mathbf{x}_i\\). Then we want to find \\(\\mathbf{x}_i\u0026#39;\\) closest to \\(\\mathbf{x}_i\\) such that the classifier assigns the positive outcome \\(g(\\mathbf{x}_i^{\u0026#39;})=1\\). In order to do so, we use gradient descent with Hinge loss \\(\\ell\\) to minimize the following function\n\\[ \\begin{aligned} \u0026amp;\u0026amp; \\min_{\\mathbf{x}_i^{\u0026#39;}}\u0026amp; \\ \\ell(g_n(\\mathbf{x}_i^{\u0026#39;}),1) + \\lambda d(\\mathbf{x}_i^{\u0026#39;},\\mathbf{x}_i) \\\\ \\end{aligned} \\]\nwhere \\(d=||\\mathbf{x}_i^{\u0026#39;}-\\mathbf{x}_i||\\) denotes the Euclidean distance. Note that this time we take the coefficient vector defining \\(g_n\\) as given and instead vary the attributes. In particular, we will perform gradient descent steps as follows\n\\[ \\begin{aligned} \u0026amp;\u0026amp; {\\mathbf{x}_i^{\u0026#39;}}^t\u0026amp;\\leftarrow {\\mathbf{x}_i^{\u0026#39;}}^{t-1} + \\eta \\nabla_{{\\mathbf{x}_i^{\u0026#39;}}} \\left( \\ell(g_n(\\mathbf{x}_i^{\u0026#39;}),1) + \\lambda d(\\mathbf{x}_i^{\u0026#39;},\\mathbf{x}_i) \\right) \\\\ \\end{aligned} \\]\nwhere \\(\\eta\\) is the learning rate. The descent step is almost equivalent to the one described in Joshi et al. (2019), but here we greatly simplify things by optimizing directly in the attribute space instead of a latent space. The gradient of the loss function looks very similar to (1). With respect to the Euclidean distance partial derivatives are of the following form:\n\\[ \\begin{aligned} \u0026amp;\u0026amp; \\frac{\\partial ||\\mathbf{x}_i^{\u0026#39;}-\\mathbf{x}_i||}{\\partial {x_i\u0026#39;}^{(d)}} \u0026amp;= \\frac{{x_i\u0026#39;}^{(d)}-{x_i}^{(d)}}{||\\mathbf{x}_i^{\u0026#39;}-\\mathbf{x}_i||} \\\\ \\end{aligned} \\]\nThe code that implements this optimization follows below.\n#\u0026#39; REVISE algoritm - a simplified version #\u0026#39; #\u0026#39; @param classifier The fitted classifier. #\u0026#39; @param x_star Attributes of individual seeking individual recourse. #\u0026#39; @param eta Learning rate. #\u0026#39; @param lambda Regularization parameter. #\u0026#39; @param n_iter Maximum number of operations. #\u0026#39; @param save_steps Boolean indicating if intermediate steps should be saved. #\u0026#39; #\u0026#39; @return #\u0026#39; @export #\u0026#39; #\u0026#39; @author Patrick Altmeyer revise.classifier \u0026lt;- function(classifier,x_star,eta=1,lambda=0.01,n_iter=1000,save_steps=FALSE) { # Initialization: ---- d \u0026lt;- length(x_star) # number of dimensions if (!is.null(names(x_star))) { d_names \u0026lt;- names(x_star) # names of attributes, if provided } else { d_names \u0026lt;- sprintf(\u0026quot;X%i\u0026quot;, 1:d) } w \u0026lt;- classifier$coefficients # coefficient vector x \u0026lt;- x_star # initialization of revised attributes distance \u0026lt;- 0 # initial distance from starting point converged \u0026lt;- predict(classifier, newdata = x)[1,1]==1 # positive outcome? iter \u0026lt;- 1 # counter if (save_steps) { steps \u0026lt;- data.table(iter=1, x=x, d=d_names) # save intermediate steps, if desired } else { steps \u0026lt;- NA } # Gradients: grad \u0026lt;- function(x,y,w) { w %*% ifelse(crossprod(x,w) * y\u0026lt;=1,-y,0) # gradient of Hinge loss with respect to X } grad_dist \u0026lt;- function(x,x_star) { d \u0026lt;- length(x_star) distance \u0026lt;- dist(matrix(cbind(x_star,x),nrow=d,byrow = T)) matrix((x-x_star) / distance) # gradient of Euclidean distance with respect to X } # Gradient descent: ---- while(!converged \u0026amp; iter\u0026lt;n_iter) { if (distance!=0) { x \u0026lt;- c(x - eta * (grad(x=matrix(x),y=1,w) + lambda * grad_dist(x,x_star))) # gradient descent step } else { x \u0026lt;- c(x - eta * grad(x=matrix(x),y=1,w)) # gradient with respect to distance not defined at zero } converged \u0026lt;- predict(classifier, newdata = x)[1,1]==1 # positive outcome? iter \u0026lt;- iter + 1 # update counter if (save_steps) { steps \u0026lt;- rbind(steps, data.table(iter=iter, x=x, d=d_names)) } distance \u0026lt;- dist(matrix(cbind(x_star,x),nrow=d,byrow = T)) # update distance } # Output: ---- if (converged) { revise \u0026lt;- x - x_star } else { revise \u0026lt;- NA } output \u0026lt;- list( x_star = x_star, revise = revise, classifier = classifier, steps = steps, lambda = lambda, distance = distance, mean_distance = mean(abs(revise)) ) return(output) } revise \u0026lt;- function(classifier,x_star,eta=1,lambda=0.01,n_iter=1000,save_steps=FALSE) { UseMethod(\u0026quot;revise\u0026quot;) }  Simulated data The synthetic data describing cats and dogs was generated as follows:\nsim_data \u0026lt;- function(n=100,averages,noise=0.1) { d \u0026lt;- ncol(averages) y \u0026lt;- 2*(rbinom(n,1,0.5)-0.5) # generate binary outcome: 1=dog, -1=cat X \u0026lt;- as.matrix(averages[(y+1)/2+1,]) # generate attributes conditional on y dogs \u0026lt;- y==1 # boolean index for dogs cats \u0026lt;- y==-1 # boolean index for cats X[cats,] \u0026lt;- X[cats,] + matrix(rnorm(sum(cats)*d),nrow=sum(cats)) %*% diag(noise*averages[2,]) # add noise for y=1 (cats) X[dogs,] \u0026lt;- X[dogs,] + matrix(rnorm(sum(dogs)*d),nrow=sum(dogs)) %*% diag(noise*averages[2,]) # add noise for y=1 (dogs) return(list(X=X,y=y)) }   ","date":1619481600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619481600,"objectID":"93c3f1b6dd06635006b46ed1d8f0c4fd","permalink":"https://www.paltmeyer.com/post/2021-04-26-individual-recourse-for-black-box-models/","publishdate":"2021-04-27T00:00:00Z","relpermalink":"/post/2021-04-26-individual-recourse-for-black-box-models/","section":"post","summary":"An introduction to algorithmic recourse and an implementation of a simplified version of REVISE (Joshi et al., 2019). This post was prepared as part of my PhD application.","tags":["gradient descent","classification","individual recourse"],"title":"Individual recourse for Black Box Models","type":"post"},{"authors":null,"categories":["Statistics"],"content":"   Optimal subsampling  Bias-variance tradeoff Subsampling methods  OLS and WLS Uniform subsampling (UNIF) Basic leveraging (BLEV) Predictor-length sampling (PL) Comparison of methods  Linear regression model  A review of Zhu et al. (2015) Computational performance  Further work References Appendix  Weighted least-squares From SVD to leverage scores From optimal to prediction-length subsampling Synthetic data Subsampling applied to sinusoidal function     Optimal subsampling When working with very large sample data, even the estimation of ordinary least-squares can be computationally prohibitive. Since we increasingly find ourselves in situations where the sample size \\(n\\) is extremely high, a body of literature concerned with optimal subsampling has recently emerged. This post summarises some of the main ideas and methodologies that have emerged from that literature. The post is structured as follows: to set the stage for the remainder of the analysis the first section briefly introduces the bias-variance trade-off. The following section then introduces various subsampling methods. Finally, we will looks at a small empirical exercise that illustrates the improvements associated with non-uniform subsampling.\nBias-variance tradeoff All computations are done in R. Code is reported only where it is deemed useful, but as always full details can be found in the GitHub repository. In some places I use fromScratchR, a package I am working on. The package is very much a work-in-progress and at this point primarily serves the purpose of collecting any programs I code up from scratch. It can be installed from GitHub through devtools::install_github(\"pat-alt/fromScratchR\").\nTo set the stage for the remainder of this note we will briefly revisit the bias-variance trade-off in this section. In particular we will illustrate the effect of varying the sample size \\(n\\). Readers familiar with this topic may choose to skip this section.\nAs as in Bishop (2006) we consider synthetic data generated by the sinusoidal function \\(f(x)=\\sin(2\\pi x)\\). To simulate random samples of \\(\\mathbf{y}\\) we sample \\(n\\) input values from \\(\\mathbf{X} \\sim \\text{unif}(0,1)\\) and introduce a random noise component \\(\\varepsilon \\sim \\mathcal{N}(0,0.3)\\). Figure 1 shows \\(\\mathbf{y}\\) along with random draws \\(\\mathbf{y}^*_n\\).\n Figure 1: Sinusoidal function and random draws.  Following Bishop (2006) we will use a Gaussian linear model with Gaussian kernels \\(\\exp(-\\frac{(x_k-\\mu_p)^{2}}{2s^2})\\) as\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\mathbf{y}|\\mathbf{X}\u0026amp; =f(x) \\sim \\mathcal{N} \\left( \\sum_{j=0}^{p-1} \\phi_j(x)\\beta_j, v \\mathbb{I}_p \\right) \\\\ \\end{aligned} \\tag{1} \\end{equation} \\]\nwith \\(v=0.3\\) to estimate \\(\\hat{\\mathbf{y}}_k\\) from random draws \\(\\mathbf{X}_k\\). We fix the number of kernels \\(p=24\\) (and hence the number of features \\(M=p+1=25\\)) as well as the spatial scale \\(s=0.1\\). To vary the complexity of the model we use a form of regularized least-squares (Ridge regression) and let the regularization parameter \\(\\lambda\\) vary\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\hat\\beta\u0026amp;=(\\lambda I + \\Phi^T \\Phi)^{-1}\\Phi^Ty \\\\ \\end{aligned} \\tag{2} \\end{equation} \\]\nwhere high values of \\(\\lambda\\) in (2) shrink parameter values towards zero. (Note that a choice \\(\\lambda=0\\) corresponds to the OLS estimator which is defined as long as \\(p \\le n\\).)\nAs in Bishop (2006) we proceed as follows for each choice of \\(\\lambda\\) and each sample draw to illustrate the bias-variance trade-off:\nDraw \\(N=25\\) time from \\(\\mathbf{u}_k \\sim \\text{unif}(0,1)\\). Let \\(\\mathbf{X}_k^*=\\mathbf{u}_k+\\varepsilon_k\\) with \\(\\varepsilon \\sim \\mathcal{N}(0, 0.3)\\). Compute \\(\\mathbf{y}_k^*=\\sin(2\\pi \\mathbf{X}^*_k)\\). Extract features \\(\\Phi_k\\) from \\(\\mathbf{X}_k^*\\) and estimate the parameter vector \\(\\beta_k^*(\\Phi_k,\\mathbf{y}^*_k,\\lambda)\\) through regularized least-squares. Predict \\(\\hat{\\mathbf{y}}_k^*=\\Phi \\beta_k^*\\).  Applying the above procedure we can construct the familiar picture that demonstrates how increased model complexity increases variance while reducing bias (Figure 2). Recall that for the mean-squared error (MSE) we have\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\mathbb{E} \\left( (\\hat{f}_n(x)-f(x))^2 \\right) \u0026amp;= \\text{var} (\\hat{f}_n(x)) + \\left( \\mathbb{E} \\left( \\hat{f}_n(x) \\right) - f(x) \\right)^2 \\\\ \\end{aligned} \\tag{3} \\end{equation} \\]\nwhere the first term on the right-hand side corresponds to the variance of our prediction and the second term to its (squared) bias. In Figure 2 as model complexity increases the variance component of the MSE increases, while the bias term diminishes. A similar pattern would have been observed if instead of using regularization we had used OLS and let the number of Gaussian kernels (and hence the number of features \\(p\\)) vary where higher values of \\(p\\) correspond to increased model complexity.\n Figure 2: Bias-variance trade-off.  The focus of this note is instead on varying the sample size \\(n\\). It should not be surprising that both the variance and bias component of the MSE decrease as the sample size \\(n\\) increases (Figure 3). But in today’s world \\(n\\) can potentially be very large, so much so that even computing simple linear models can be hard. Suppose for example you wanted to use patient data that is generated in real-time as a global pandemic unfolds to predict the trajectory of said pandemic. Or consider the vast quantities of potentially useful user-generated data that online service providers have access to. In the remainder of this note we will investigate how systematic subsampling can help improve model accuracy in these situations.\n Figure 3: Bias-variance trade-off. The effect of sample size.   Subsampling methods The case for subsampling generally involves \\(n \u0026gt;\u0026gt; p\\), so very large values of \\(n\\). In such cases we may be interested in estimating \\(\\hat\\beta_m\\) instead of \\(\\hat\\beta_n\\) where \\(p\\le m\u0026lt;\u0026lt;n\\) with \\(m\\) freely chosen by us. In practice we may want to do this to avoid high computational costs associated with large \\(n\\) as discussed above. The basic algorithm for estimating \\(\\hat\\beta_m\\) is simple:\nSubsample with replacement from the data with some sampling probability \\(\\{\\pi_i\\}^n_{i=1}\\). Estimate least-squares estimator \\(\\hat\\beta_m\\) using the subsample.  But there are at least two questions about this algorithm: firstly, how do we choose \\(\\mathbf{X}_m=({\\mathbf{X}^{(1)}}^T,...,{\\mathbf{X}^{(m)}}^T)^T\\)? Secondly, how should we construct \\(\\hat\\beta_m\\)? With respect to the former, a better idea than just randomly selecting \\(\\mathbf{X}_m\\) might be to choose observations with high influence. We will look at a few of the different subsampling methods investigated and proposed in Zhu et al. (2015), which differ primarily in their choice of subsampling probabilities \\(\\{\\pi_i\\}^n_{i=1}\\):\nUniform subsampling (UNIF): \\(\\{\\pi_i\\}^n_{i=1}=1/n\\). Basic leveraging (BLEV): \\(\\{\\pi_i\\}^n_{i=1}=h_{ii}/ \\text{tr}(\\mathbf{H})=h_{ii}/p\\) where \\(\\mathbf{H}\\) is the hat matrix. Optimal (OPT) and predictor-length sampling (PL): involving \\(||\\mathbf{X}_i||/ \\sum_{j=1}^{n}||\\mathbf{X}_j||\\) where \\(||\\mathbf{X}||\\) denotes the \\(L_2\\) norm of \\(\\mathbf{X}\\).  Methods involving predictor-lengths are proposed by the authors with the former shown to be optimal (more on this below). PL subsampling is shown to scale very well and a good approximation of optimal subsampling conditional on leverage scores \\(h_{ii}\\) being fairly homogeneous.\nWith respect to the second question Zhu et al. (2015) investigate both ordinary least-squares (OLS) and weighted least-squares (WLS), where weights simply correspond to subsampling probabilities \\(\\{\\pi_i\\}^n_{i=1}\\). The authors present empirical evidence that OLS is more efficient than WLS in that the mean-squared error (MSE) for predicting \\(\\mathbf{X} \\beta\\) is lower for OLS. The authors also note though that subsampling using OLS is not consistent for non-uniform subsampling methods meaning that the bias cannot be controlled. Given Equation (3) the fact that OLS is nonetheless more efficient than WLS implies that the higher variance terms associated with WLS dominates the effect of relatively higher bias with OLS. In fact this is consistent with the theoretical results presented in Zhu et al. (2015) (more on this below).\nNext we will briefly run through different estimation and subsampling methods in some more detail and see how they can be implemented in R. In the following section we will then look at how the different approaches perform empirically.\nOLS and WLS Both OLS and WLS are implemented here using QR decomposition. As for OLS this is very easily done in R. Given some feature matrix X and a corresponding outcome variable y we can use qr.solve(X, y) to compute \\(\\hat\\beta\\). For WLS we need to first weigh observations by their corresponding subsampling probabilities. Following Zhu et al. (2015) we can construct a weighting matrix \\(\\Phi= \\text{diag}\\{\\pi_i\\}^m_{i=1}\\) and compute the weighted least-squares estimator as: (see appendix for derivation)\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\hat\\beta_m^{WLS}\u0026amp;= \\left( \\mathbf{X}^T \\Phi^{-1} \\mathbf{X} \\right)^{-1} \\mathbf{X}^T\\Phi^{-1}\\mathbf{y}\\\\ \\end{aligned} \\tag{4} \\end{equation} \\]\nIn R weighted least-squares can be implemented (from scratch) as follows\nfunction (X, y, weights) { Phi \u0026lt;- diag(weights) beta \u0026lt;- qr.solve(t(X) %*% Phi %*% X, t(X) %*% Phi %*% y) return(beta) } where in order to implement the algorithm propose in Zhu et al. (2015) the weights we need to supply as the function arguments are \\(w=\\{1/\\pi_i\\}^m_{i=1}\\). This follows from the following property of diagonal matrices:\n\\[ \\begin{aligned} \u0026amp;\u0026amp; \\Phi^{-1}\u0026amp;= \\begin{pmatrix} 1\\over\\phi_{11} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; ... \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1\\over \\phi_{nn} \\end{pmatrix} \\\\ \\end{aligned} \\]\n Uniform subsampling (UNIF) A simple function for uniform subsampling in R is shown in the code chunk below. Note that to streamline the comparison of the different methods in the following section the function takes an unused argument weighted=F which for the other subsampling methods can be used to determine whether OLS or WLS should be used. Of course, with uniform subsampling the weights are all identical and hence \\(\\hat\\beta^{OLS}=\\hat\\beta^{WLS}\\) so the argument is passed to but not evaluated in sub_UNIF.\nfunction (vars, weighted = F, rand_state = NULL, fit_model = T) { if (!is.null(rand_state)) { set.seed(rand_state) } invisible(list2env(vars, envir = environment())) indices \u0026lt;- sample(indices_maj, size = n_min) indices \u0026lt;- c(indices_min, indices) X_m \u0026lt;- X[indices, ] y_m \u0026lt;- y[indices] weights \u0026lt;- NULL if (fit_model) { beta_hat \u0026lt;- glm(y_m ~ X_m, family = \u0026quot;binomial\u0026quot;)$coefficients if (!all(X[, 1] == 1)) { X \u0026lt;- cbind(1, X) } y_hat \u0026lt;- c(X %*% beta_hat) p_y \u0026lt;- exp(y_hat)/(1 + exp(y_hat)) return(list(X_m = X_m, y_m = y_m, linear_predictors = y_hat, fitted = p_y, coeff = beta_hat)) } else { return(list(X = X_m, y = y_m, weights = weights)) } }  Basic leveraging (BLEV) The sub_UNIF function can be extended easily to the case with basic leveraging (see code below). Note that in this case the weighted argument is actually evaluated.\nfunction (X, y, m, weighted = F, rand_state = NULL, plot_wgts = F, prob_only = F) { svd_X \u0026lt;- svd(X) U \u0026lt;- svd_X$u H \u0026lt;- tcrossprod(U) h \u0026lt;- diag(H) prob \u0026lt;- h/ncol(X) if (plot_wgts) { plot(prob, t = \u0026quot;l\u0026quot;, ylab = \u0026quot;Sampling probability\u0026quot;) } if (prob_only) { return(prob) } else { indices \u0026lt;- sample(x = 1:n, size = m, replace = T, prob = prob) X_m \u0026lt;- X[indices, ] y_m \u0026lt;- y[indices] weights \u0026lt;- 1/prob[indices] if (weighted) { beta_hat \u0026lt;- wls_qr(X_m, y_m, weights) } else { beta_hat \u0026lt;- qr.solve(X_m, y_m) } y_hat \u0026lt;- c(X %*% beta_hat) return(list(fitted = y_hat, coeff = beta_hat, prob = prob)) } } A note on computing leverage scores Recall that for the hat matrix we have\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\mathbf{H}\u0026amp;=\\mathbf{X} (\\mathbf{X}^T \\mathbf{X})^{-1}\\mathbf{X}^T \\\\ \\end{aligned} \\tag{5} \\end{equation} \\]\nwhere the diagonal elements \\(h_{ii}\\) correspond to the leverage scores we’re after. Following Zhu et al. (2015) we will use (compact) singular value decomposition to obtain \\(\\mathbf{H}\\) rather than computing (5) directly. This has the benefit that there exist exceptionally stable numerical algorithms to compute SVD. To see how and why we can use SVD to obtain \\(\\mathbf{H}\\) see appendix.\nClearly to get \\(h_{ii}\\) we first need to compute \\(\\mathbf{H}\\) which in terms of computational costs is of order \\(\\mathcal{O}(np^2)=\\max(\\mathcal{O}(np^2),\\mathcal{O}(p^3))\\). The fact that we use all \\(n\\) rows of \\(\\Phi\\) to compute leverage scores even though we explicitly stated our goal was to only use \\(m\\) observations may rightly seem like a bit of a paradox. This is why fast algorithms that approximate leverage scores have been proposed. We will not look at them specifically here mainly because the PL method proposed by Zhu et al. (2015) does not depend on leverage scores and promises to be computationally even more efficient.\n  Predictor-length sampling (PL) The basic characteristic of PL subsampling - choosing \\(\\{\\pi_i\\}^n_{i=1}= ||\\mathbf{X}_i||/ \\sum_{j=1}^{n}||\\mathbf{X}_j||\\) - was already introduced above. Again it is very easy to modify the subsampling functions from above to this case:\nfunction (X, y, m, weighted = F, rand_state = NULL, plot_wgts = F, prob_only = F) { predictor_len \u0026lt;- sqrt(X^2 %*% rep(1, ncol(X))) prob \u0026lt;- predictor_len/sum(predictor_len) if (plot_wgts) { plot(prob, t = \u0026quot;l\u0026quot;, ylab = \u0026quot;Sampling probability\u0026quot;) } if (prob_only) { return(prob) } else { indices \u0026lt;- sample(x = 1:n, size = m, replace = T, prob = prob) X_m \u0026lt;- X[indices, ] y_m \u0026lt;- y[indices] weights \u0026lt;- 1/prob[indices] if (weighted) { beta_hat \u0026lt;- wls_qr(X_m, y_m, weights) } else { beta_hat \u0026lt;- qr.solve(X_m, y_m) } y_hat \u0026lt;- c(X %*% beta_hat) return(list(fitted = y_hat, coeff = beta_hat, prob = prob)) } } A note on optimal subsampling (OPT) In fact, PL subsampling is an approximate version of optimal subsampling (OPT). Zhu et al. (2015) show that asymptotically we have:\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp;\\text{plim} \\left( \\text{var} (\\hat{f}_n(x)) \\right) \u0026gt; \\text{plim} \\left(\\left( \\mathbb{E} \\left( \\hat{f}_n(x) \\right) - f(x) \\right)^2 \\right) \\\\ \\end{aligned} \\tag{6} \\end{equation} \\]\nGiven this result minimizing the MSE (Equation (3)) with respect to subsampling probabilities \\(\\{\\pi_i\\}^n_{i=1}\\) corresponds to minimizing \\(\\text{var} (\\hat{f}_n(x))\\). They further show that this minimization problem has the following closed-form solution:\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\pi_i\u0026amp;= \\frac{\\sqrt{(1-h_{ii})}||\\mathbf{X}_i||}{\\sum_{j=1}^n\\sqrt{(1-h_{jj})}||\\mathbf{X}_j||}\\\\ \\end{aligned} \\tag{7} \\end{equation} \\]\nThis still has computational costs of order \\(\\mathcal{O}(np^2)\\). But it should now be clear why PL subsampling is optimal conditional on leverage scores being homogeneous (see appendix). PL subsampling is associated with computational costs of order \\(\\mathcal{O}(np)\\), so a potentially massive improvement. The code for optimal subsampling is shown below:\nfunction (X, y, m, weighted = F, rand_state = NULL, plot_wgts = F, prob_only = F) { n \u0026lt;- nrow(X) svd_X \u0026lt;- svd(X) U \u0026lt;- svd_X$u H \u0026lt;- tcrossprod(U) h \u0026lt;- diag(H) predictor_len \u0026lt;- sqrt(X^2 %*% rep(1, ncol(X))) prob \u0026lt;- (sqrt(1 - h) * predictor_len)/crossprod(sqrt(1 - h), predictor_len)[1] if (plot_wgts) { plot(prob, t = \u0026quot;l\u0026quot;, ylab = \u0026quot;Sampling probability\u0026quot;) } if (prob_only) { return(prob) } else { indices \u0026lt;- sample(x = 1:n, size = m, replace = T, prob = prob) X_m \u0026lt;- X[indices, ] y_m \u0026lt;- y[indices] weights \u0026lt;- 1/prob[indices] if (weighted) { beta_hat \u0026lt;- wls_qr(X_m, y_m, weights) } else { beta_hat \u0026lt;- qr.solve(X_m, y_m) } y_hat \u0026lt;- c(X %*% beta_hat) return(list(fitted = y_hat, coeff = beta_hat, prob = prob)) } }  A note on computing predictor lengths Computing the Euclidean norms \\(||\\mathbf{X}_i||\\) in R can be done explicitly by looping over the rows of \\(\\mathbf{X}\\) and computing the norm in each iteration. It turns out that this computationally very expensive. A much more efficient way of computing the vector of predictor lengths is as follows\n\\[ \\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\mathbf{pl}\u0026amp;=\\sqrt{\\mathbf{X}^2 \\mathbf{1}} \\\\ \\end{aligned} \\tag{8} \\end{equation} \\]\nwhere \\(\\mathbf{X}^2\\) indicates elements squared, the square root is also taken element-wise and \\(\\mathbf{1}\\) is a \\((p \\times 1)\\) vectors of ones. A performance benchmark of the two approaches is shown in Figure 4 below.\n Figure 4: Benchmark of Euclidean norm computations.    Comparison of methods As discussed in Zhu et al. (2015) both OPT and PL subsampling tend to inflate subsampling probabilities of observations with low leverage scores and shrink those of high-leverage observations relative to BLEV. They show explicitly that this always holds for orthogonal design matrices. As a quick sense-check of the functions introduced above we can generate a random orthogonal design matrix \\(\\mathbf{X}\\) and plot subsampling probabilities with OPT and PL against those obtained with BLEV. Figure 5 illustrates this relationship nicely.\n Figure 5: Comparison of subsampling probabilities.  The design matrix \\(\\mathbf{X}\\) \\((n \\times p)\\) with \\(n=1000\\) and \\(p=100\\) was generated using SVD:\nfunction (n, p) { M \u0026lt;- matrix(rnorm(n * p), n, p) X \u0026lt;- svd(M)$u return(X) }   Linear regression model A review of Zhu et al. (2015) To illustrate the improvements associated with the methods proposed in Zhu et al. (2015), we will briefly replicate their main empirical findings here. The evaluate the performance of the different methods we will proceed as follows:\nEmpirical exercise\nGenerate synthetic data \\(\\mathbf{X}\\) of dimension \\((n \\times m)\\) with \\(n\u0026gt;\u0026gt;m\\). Set some true model parameter \\(\\beta=(\\mathbf{1}^T_{\\overline{m*0.6}},\\mathbf{1}^T_{\\underline{m*0.4}})^T\\). Model the outcome variable as \\(\\mathbf{y}=\\mathbf{X}\\beta+\\epsilon\\) where \\(\\epsilon \\sim \\mathcal{N}(\\mathbf{0},\\sigma^2 \\mathbf{I}_n)\\) and \\(\\sigma=10\\). Estimate the full-sample OLS estimator \\(\\hat\\beta_n\\) (a benchmark estimator of sorts in this setting). Use one of the subsampling methods to estimate iteratively \\(\\{\\hat\\beta^{(b)}_m\\}^B_{b=1}\\). Note that all subsampling methods are stochastic so \\(\\hat\\beta_m\\) varies across iterations. Evaluate average model performance of \\(\\hat\\beta_m\\) under the mean-squared error criterium: \\(MSE= \\frac{1}{B} \\sum_{b=1}^{B} MSE^{(b)}\\) where \\(MSE^{(b)}\\) corresponds to the in-sample estimator of the mean-squared error of the \\(b\\)-th iteration.  As in Zhu et al. (2015) we will generate the design matrix \\(\\mathbf{X}\\) from 5 different distributions: 1) Gaussian (GA) with \\(\\mathcal{N}(\\mathbf{0},\\Sigma)\\); 2) Mixed-Gaussian (MG) with \\(0.5\\mathcal{N}(\\mathbf{0},\\Sigma)+0.5\\mathcal{N}(\\mathbf{0},25\\Sigma)\\); 3) Log-Gaussian (LN) with \\(\\log\\mathcal{N}(\\mathbf{0},\\Sigma)\\); 4) T-distribution with 1 degree of freedom (T1) and \\(\\Sigma\\); 5) T-distribution as in 4) but truncated at \\([-p,p]\\). All parameters are chosen in the same way as in Zhu et al. (2015) with exception of \\(n=1000\\) and \\(p=3\\), which are significantly smaller choices in order to decrease the computational costs. The corresponding densities of the 5 data sets are shown in Figure 8 in the appendix.\nset.seed(1) library(expm) matrix_grid \u0026lt;- expand.grid(i=1:p,j=1:p) Sigma \u0026lt;- matrix(rep(0,p^2),p,p) for (x in 1:nrow(matrix_grid)) { i \u0026lt;- matrix_grid$i[x] j \u0026lt;- matrix_grid$j[x] Sigma[i,j] \u0026lt;- 2 * (0.8)^(abs(i-j)) } # 1.) Design matrix (as in Zhu et al): ---- GA \u0026lt;- matrix(rnorm(n*p), nrow = n, ncol = p) %*% sqrtm(t(Sigma)) # Gaussian mixture: gaus_mix \u0026lt;- list( gaus_1 = matrix(rnorm(n*p), nrow = n, ncol = p) %*% sqrtm(t(Sigma)), gaus_2 = matrix(rnorm(n*p), nrow = n, ncol = p) %*% sqrtm((25 * t(Sigma))) ) MG \u0026lt;- matrix(rep(0,n*p),n,p) for (i in 1:nrow(MG)) { x \u0026lt;- sample(1:2,1) MG[i,] \u0026lt;- gaus_mix[[x]][i,] } # Log-Gaussian: LN \u0026lt;- exp(GA) # T-distribution: T1 \u0026lt;- matrix(rt(n*p,1), nrow = n, ncol = p) %*% sqrtm(t(Sigma)) # Truncated T: TT \u0026lt;- T1 TT[TT\u0026gt;p] \u0026lt;- p TT[TT\u0026lt;(-p)] \u0026lt;- -p data_sets \u0026lt;- list( GA = list(X = GA), MG = list(X = MG), LN = list(X = LN), TT = list(X = TT), T1 = list(X = T1) ) # 2.) Outcome: data_sets \u0026lt;- lapply( data_sets, function(i) { X \u0026lt;- i[[\u0026quot;X\u0026quot;]] beta \u0026lt;- c(rep(1,ceiling(0.6*p)),rep(0.1,floor(0.4*p))) eps \u0026lt;- rnorm(n=n,mean=0,sd=10) y \u0026lt;- X %*% beta + eps list(X=X, y=y) } ) We will run the empirical exercise for each data set and each subsampling method introduced above. Figure 6 shows logarithms of the sampling probabilities corresponding to the different subsampling methods (UNIF not shown for obvious reasons). The plots look very similar to the one in Zhu et al. (2015) and is shown here primarily to reassure ourselves that we have implemented their ideas correctly. One interesting observation is worth pointing out however: note how the distributions for OPT and PL have lower standard deviations compared to BLEV. This should not be altogether surprising since we already saw above that for orthogonal design matrices the former methods inflate small leverage scores while shrinking high scores. But it is interesting to see that the same appears to hold for design matrices that are explicitly not orthogonal given our choice of \\(\\Sigma\\).\n Figure 6: Sampling probabilities for different subsampling methods.  Figures ?? and ?? show the resulting MSE, squared bias and variance for the different subsampling methods and data sets using weighed least-squares and ordinary least-squares, respectively. The subsampling size increases along the horizontal axis. The figures are interactive to allow readers to zoom in etc.\nFor the data sets that are also shown in Zhu et al. (2015) we find the same overall pattern: PL and OPT outperform other methods when using weighted least-squares, while BLEV outperforms other methods when using unweighted/ordinary least-squares.\nFor Gaussian data (GA) the differences between the methods are minimal since data points are homogeneous. A similar picture emerges when running the method comparison for the sinusoidal data introduced above (see appendix). In fact, Zhu et al. (2015) recommend to just rely on uniform subsampling when data is Gaussian. Another interesting observation is that for t-distributed data (T1) the non-uniform subsampling methods significantly outperform uniform subsampling methods. This is despite the fact that in the case of T1 data the conditions used to establish asymptotic consistency of the non-uniform subsampling methods in Zhu et al. (2015) are not fulfilled: in particular the fourth moment is not finite (in fact it is not defined).\n Computational performance We have already seen above that theoretically speaking both BLEV and OPT subsampling are computationally more expensive than PL subsampling (with UNIF subsampling the least expensive). It should be obvious that in light of their computational costs \\(\\mathcal{O}(np^2)\\) the former two methods do not scale well in higher-dimensional problems (higher \\(p\\)). Zhu et al. (2015) demonstrate this through empirical exercises to an extent that is beyond the scope of this note. Instead we will just quickly benchmark the different functions for non-uniform subsampling introduced above: sub_BLEV, sub_OPT, sub_PL for \\(n=200\\), \\(p=100\\). We are only interested in how long it takes to compute subsampling probabilities, and since for sub_UNIF all subsampling probabilities are simply \\(\\pi_i=1/n\\) we neglect this here. Figure 7 benchmarks the three non-uniform subsampling methods. Evidently PL subsampling is computationally much less costly.\n Figure 7: Benchmark of computational performance of different methods.    Further work We have looked at subsampling of linear regression problems, but of course the story does not end here. For binary classification problems, for example, we cannot directly apply the methods used here, but the same general ideas still apply. Wang, Zhu, and Ma (2018) explore optimal subsampling for large sample logistic regression - a paper that is very much related to Zhu et al. (2015). For a brief summary and a (cautious) application to imbalanced learning see here.\nVery recently an article has been published that investigates optimal subsampling in the context of quantile regression. More interesting work in this certain to emerge from this field, which researches some of the most pressing questions in large sample statistics.\n References Bishop, Christopher M. 2006. Pattern Recognition and Machine Learning. springer.  Wang, HaiYing, Rong Zhu, and Ping Ma. 2018. “Optimal Subsampling for Large Sample Logistic Regression.” Journal of the American Statistical Association 113 (522): 829–44.  Zhu, Rong, Ping Ma, Michael W Mahoney, and Bin Yu. 2015. “Optimal Subsampling Approaches for Large Sample Linear Regression.” arXiv, arXiv–1509.    Appendix Weighted least-squares Weighted least-squares\n  From SVD to leverage scores From SVD to leverage\n  From optimal to prediction-length subsampling From OPT to PL\n  Synthetic data  Figure 8: Densities of synthetic design matrices.   Subsampling applied to sinusoidal function    ","date":1615334400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615334400,"objectID":"af23bea23c30a5bf74afd396df683079","permalink":"https://www.paltmeyer.com/post/2021-03-10-optimal-subsampling/","publishdate":"2021-03-10T00:00:00Z","relpermalink":"/post/2021-03-10-optimal-subsampling/","section":"post","summary":"This post explores recent advances in optimal subsampling.","tags":["statistics","subsampling","bias-variance"],"title":"Optimal subsampling","type":"post"},{"authors":null,"categories":["Trustworthy AI"],"content":"   Motivation Interpretable DL - a whistle-stop tour An entropy-based approach to variable importance Application to Bayesian neural networks Conclusion References   Motivation Propelled by advancements in modern computer technology, deep learning has re-emerged as perhaps the most promising artificial intelligence (AI) technology of the last two decades. By treating problems as a nested, hierarchy of hidden layers deep artificial neural networks achieve the power and flexibility necessary for AI systems to navigate complex real-world environments. Unfortunately, their very nature has earned them a reputation as Black Box algorithms and their lack of interpretability remains a major impediment to their more wide-spread application.\nIn science, research questions usually demand not just answers but also explanations and variable selection is often as important as prediction (Ish-Horowicz et al. 2019). Economists, for example, recognise the undeniable potential of deep learning, but are rightly hesitant to employ novel tools that are not fully transparent and ultimately cannot be trusted. Similarly, real-world applications of AI have come under increasing scrutiny with regulators imposing that individuals influenced by algorithms should have the right to obtain explanations (Fan, Xiong, and Wang 2020). In high-risk decision-making fields such as AI systems that drive autonomous vehicles the need for explanations is self-evident (Ish-Horowicz et al. 2019).\nIn light of these challenges it is not surprising that research on explainable AI has recently gained considerable momentum (Arrieta et al. 2020). While in this short essay we will focus on deep learning in particular, it should be noted that this growing body of literature is concerned with a broader realm of machine learning models. The rest of this note is structured as follows: the first section provides a brief overview of recent advancements towards interpreting deep neural networks largely drawing on Fan, Xiong, and Wang (2020); the second section considers a novel entropy-based approach towards interpretability proposed by Crawford et al. (2019); finally, in the last section we will see how this approach can be applied to deep neural networks as proposed in Ish-Horowicz et al. (2019).\n Interpretable DL - a whistle-stop tour Before delving further into how the intrinsics of deep neural networks can be disentangled we should first clarify what interpretability in the context of algorithms actually means. Fan, Xiong, and Wang (2020) describes model interpretability simply as the extent to which humans can “understand and reason” the model. This may concern an understanding of both the ad-hoc workings of the algorithm as well as the post-hoc interpretability of its output. In the context of linear regression, for example, ad-hoc workings of the model are often described through the intuitive idea of linearly projecting the outcome variable \\(\\mathbf{y}\\) onto the column space of \\(\\mathbf{X}\\). Post-hoc interpretations usually center around variable importance – the main focus of the following sections. Various recent advancements tackle interpretability of DNNs from different angles depending on whether the focus is on ad-hoc or post-hoc interpretability. Fan, Xiong, and Wang (2020) further asses that model interpretability hinges on three main aspects of simulatability, decomposability and algorithmic transparency, but for the purpose of this short note the ad-hoc vs. post-hoc taxonomy provides a simpler more natural framework.1\nUnderstanding the ad-hoc intrinsic mechanisms of a DNN is inherently difficult. While generally transparency may be preserved in the presence of nonlinearity (e.g. decision trees), multiple hidden layers of networks (each of them) involving nonlinear operations are usually out of the realm of human comprehension (Fan, Xiong, and Wang 2020). Training also generally involves optimization of non-convex functions that involve an increasing number of saddle points as the dimensionality increases (Fan, Xiong, and Wang 2020). Methods to circumvent this problematic usually boil down to decreasing the overall complexity, either by regularizing the model or through proxy methods. Regularization – while traditionally done to avoid overfitting – has been found to be useful to create more interpretable representations. Monotonicity constraints, for example, impose that as the value of a specified covariate increases model predictions either monotonically decrease or increase. Proxy methods construct simpler representations of a learned DNN, such as a rule-based decision tree. This essentially involves repeatedly querying the trained network while varying the inputs and then deriving decision rules based on the model output.\nPost-hoc interpretability usually revolves around the understanding of feature importance. A greedy approach to this issue involves simply removing features one by one and checking how model predictions change. A more sophisticated approach along these lines is Shapley value, which draws on cooperative game theory. The Shapley value assigns varying payouts to players depending on their contribution to overall payout. In the context of neural networks input covariate \\(\\mathbf{X}_p\\) represents a player while overall payout is represented by the difference between average and individual outcome predictions.2 Exact computations of Shapley values are prohibitive as the dimensionality increases, though approximate methods have recently been developed (Fan, Xiong, and Wang 2020).\nThe remainder of this note focuses on a novel approach to feature extraction that measures entropy shifts in a learned probabilistic neural network in response to model inputs \\(\\mathbf{X_1},...,\\mathbf{X}_P\\). We will first introduce this methodology in the context of Gaussian Process regression in the following section before finally turning to its application to Bayesian neural networks.\n An entropy-based approach to variable importance Ish-Horowicz et al. (2019) motivate their methodology for interpreting neural networks through Gaussian Process regression. Consider the following Bayesian regression model with Gaussian priors:\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; f(\\mathbf{X}|\\mathbf{w})\u0026amp;=\\phi(\\mathbf{X})^T\\mathbf{w} + \\varepsilon, \u0026amp;\u0026amp;\\varepsilon \\sim \\mathcal{N}(0,\\mathbf{I}) \\\\ \u0026amp;\u0026amp; \\mathbf{w}\u0026amp; \\sim \\mathcal{N}(0,{1\\over{\\lambda}} \\mathbf{I})\\\\ \\end{aligned} \\tag{1} \\end{equation}\\] This naturally gives rise to a particular example of a Gaussian Process (GP). In particular, since \\(\\mathbf{u}(\\mathbf{X})=\\Phi(\\mathbf{X})^T\\mathbf{w}\\) is just a linear combination fo Gaussian random variables it follows a Gaussian Process itself\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\mathbf{u}(\\mathbf{X})=\\Phi(\\mathbf{X})^T\\mathbf{w}\u0026amp; \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{K}) \\\\ \\end{aligned} \\tag{2} \\end{equation}\\] where \\(\\mathbf{K}\\) is the Kernel (or Gram) matrix and \\(K_{i,j}=k(\\mathbf{X_i,\\mathbf{X}_j})={1\\over{\\lambda}}\\phi(\\mathbf{X_i})^T\\phi(\\mathbf{X_m})\\) is the kernel function (Bishop 2006). In other words, the prior distribution over \\(\\mathbf{w}\\) induces a probability distribution over random functions \\(\\mathbf{u}(\\mathbf{X})\\). Similarly, the GP can be understood as a prior distribution over a an infinite-dimensional reproducible kernel Hilbert space (RKHS) (Crawford et al. 2019), which in a finite-dimensional setting becomes multivariate Gaussian.\nIn a standard linear regression model coefficients characterize the projection of the outcome variable \\(\\mathbf{y}\\) onto the column space of the regressors \\(\\mathbf{X}\\). In particular, with ordinary least square we define:\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\beta\u0026amp;=(\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y} \\\\ \\end{aligned} \\tag{3} \\end{equation}\\] The primary focus here is to learn the mapping from input to output. The key differentiating feature between this approach and the non-parametric model in (1) is the fact that in case of the latter we are interested in learning not only the mapping from inputs to outputs, but also the representation (\\(\\mathbf{u}(\\mathbf{X})\\)) of the inputs (see for example (Goodfellow, Bengio, and Courville 2016)). To be even more specific, treating the feature representation itself as random as in (1) allows us to learn non-linear relationships between the covariates \\(\\mathbf{X}\\), since they are implicitly captured by the RKHS (Crawford et al. 2019). Neural networks share this architecture and hence it is worth dwelling on it a bit further: the fact that the learned model inherently incorporates variable interactions leads to the observation that an individual feature is rarely important on its own with respect to the mapping from \\(\\mathbf{X}\\) to \\(\\mathbf{y}\\) (Ish-Horowicz et al. 2019). Hence, in order to gain an understanding of individual variable importance, one should aim to understand what role feature \\(\\mathbf{X}_j\\) plays within the learned model, thereby taking into account its interactions with other covariates. Formally, Crawford et al. (2019) and define the effect size analogue as the equivalent of the familiar regression coefficient in the non-parametric setting\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\tilde\\beta\u0026amp;=\\mathbf{X}^+\\Phi^T\\mathbf{w}=\\mathbf{X}^+\\mathbf{u} \\\\ \\end{aligned} \\tag{4} \\end{equation}\\] where \\(\\mathbf{X}^+=\\lim_{\\alpha} (\\mathbf{X}^T\\mathbf{X}+\\alpha \\mathbf{I})^{-1}\\mathbf{X}^T\\) denotes the Moore-Penrose pseudo-inverse (see for example Goodfellow, Bengio, and Courville (2016)). Intuitively the effect size analogue can be thought of as the resulting coefficients from regressing the fitted values \\(\\hat{\\mathbf{u}}\\) from the learned probabilistic model on the covariates \\(\\mathbf{X}\\). It can be interpreted in the same way as linear regression coefficients, in the sense that \\(\\tilde\\beta_j\\) describes the marginal change in \\(\\mathbf{u}\\) given a unit increase in \\(\\mathbf{X}_j\\) holding all else constant. Note here the subtle, but crucial difference between (3) – a projection from the outcome variable onto the column space of \\(\\mathbf{X}\\) – and (4) – a projection from the learned model to \\(\\mathbf{X}\\). In other words, looking at \\(\\tilde\\beta\\) can be thought of peeking directly into the Block Box. Unfortunately, as Crawford et al. (2019) point out, working with (4) is usually not straight-forward. From a practitioner’s point of view, it may also not be obvious how to interpret a coefficient that describes marginal effects of input variables on a learned model. A more useful indicator in this context would provide a measure of how much individual variables contribute to the overall variation in the learned model. For this purpose Crawford et al. (2019) propose to work with a distributional centrality measure based on \\(\\tilde\\beta\\), which we shall turn to next.\nThe proposed methodology in Crawford et al. (2019) and Ish-Horowicz et al. (2019) depends on the availability of a posterior distribution over \\(\\tilde\\beta\\) in that it measures its entropic shifts in response to the introduction of covariates. The intuition is straight-forward: within the context of the learned probabilistic model is covariate \\(\\mathbf{X}_j\\) informative or not? More formally this boils down to determining if the posterior distribution of \\(p(\\tilde\\beta_{-j})\\) is dependent on the effect of \\(\\tilde\\beta_j\\). This can be quantified through the Kullback-Leibler divergence (KLD) between \\(p(\\tilde\\beta_{-j})\\) and the conditional posterior \\(p(\\tilde\\beta_{-j}|\\tilde\\beta_j)\\):\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\text{KLD}_j\u0026amp;=\\text{KL}\\left(p(\\tilde\\beta_{-j}) || p(\\tilde\\beta_{-j}|\\tilde\\beta_j)\\right) \\\\ \\end{aligned} \\tag{5} \\end{equation}\\] Covariates that contribute significant information to the model will have \\(\\text{KLD}\u0026gt;0\\), while for insignificant covariates \\(\\text{KLD}\\approx0\\). The measure of induced entropy change gives rise to a ranking of the covariates in terms of their relative importance in the model. The RATE criterion of variable \\(\\mathbf{X}_j\\) is then simply defined as\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\gamma_j\u0026amp;=\\frac{\\text{KLD}_j}{\\sum_{p=1}^{P}\\text{KLD}_p}\\in[0,1] \\\\ \\end{aligned} \\tag{6} \\end{equation}\\] which in light of its bounds can naturally be interpreted as \\(\\mathbf{X}_j\\)`s percentage contribution to the learned model. It is worth noting that \\(p(\\tilde\\beta_{-j}|\\tilde\\beta_j)\\) of course depends on the value of the conditioning variable. A natural choice is \\(\\tilde\\beta_j=0\\) which usually corresponds to the null hypothesis.\n Application to Bayesian neural networks In order to use the RATE criterion in the context of deep learning we need to work in the Bayesian setting. Contrary to standard artificial neural networks which work under the assumption that weights have some true latent value, Bayesian neural networks place a prior distribution over network parameters and hence treat weights as random variables (Goan and Fookes 2020). Not only does it perhaps seem more natural to treat unobserved weights as random, but the Bayesian setting also naturally gives rise to reason about uncertainty in predictions, which can ultimately help us develop more trustworthy models (Goan and Fookes 2020). A drawback of BNNs is that exact computation of posteriors is computationally challenging and often intractable (a non-trivial issue that we will turn back to in a moment).\nWhen the prior placed over parameters is Gaussian, the output of the BNN approaches a Gaussian Process as the width of the network grows, in line with the discussion in the previous section. This is exactly the assumption that Ish-Horowicz et al. (2019) work with. They propose an architecture for a multi-layer perceptron (MLP) composed of (1) an input layer collecting covariates \\(\\mathbf{X}_1,...,\\mathbf{X}_p\\), (2) a single deterministic, hidden layer and (3) an outer layer producing predictions from a probabilistic model \\(\\mathbf{u}(\\mathbf{X})\\). Let \\(\\mathbf{X}\\) be a \\((N \\times P)\\) matrix of covariates. Then formally, we have\n\\[\\begin{equation} \\begin{aligned} \u0026amp;\u0026amp; \\hat{\\mathbf{y}}\u0026amp;=\\sigma(\\mathbf{u}) \\\\ \u0026amp;\u0026amp; \\mathbf{u}(\\mathbf{Z})\u0026amp;=\\mathbf{Z}(\\mathbf{X})\\mathbf{w}^{(L+1)}, \u0026amp;\u0026amp; \\mathbf{w}^{(L+1)} \\sim \\mathcal{N}(\\mathbf{m}, \\mathbf{V}) \\\\ \u0026amp;\u0026amp; \\mathbf{Z}(\\mathbf{X})\u0026amp;=f(\\mathbf{X}\\mathbf{w}^{(L)}) \\\\ \\end{aligned} \\tag{7} \\end{equation}\\] where \\(\\sigma(.)\\) is a link function and \\(\\mathbf{u}(\\mathbf{X})\\) represents the probabilistic model learned in the outer layer with weights \\(\\mathbf{w}^{(L+1)}\\) assumed to be Gaussian random variables.3 Finally, \\(\\mathbf{Z}(\\mathbf{X})\\) denotes the inner (or more generally penultimate) layer, an \\((N \\times P)\\) matrix of neural activations through \\(f:(\\mathbf{X}\\mathbf{w}^{(L)})\\mapsto \\mathbf{Z}\\). Ish-Horowicz et al. (2019) work with a simple single-layer MLP, but it should be evident that this be extended to arbitrary depth and complexity, while still maintaining the high-level structure imposed by (7). This flexibility allows RATE to be applied to a wide range of Bayesian network architectures, since all that is really required is the posterior distribution over weights \\(\\mathbf{w}^{(L+1)}\\), which arises from the probabilistic outer layer. The fact that only the outer layer needs to be probabilistic has the additional benefit of mitigating the computational burden that comes with Bayesian inference, which was mentioned earlier.\nHaving established this basic, flexible set-up the Ish-Horowicz et al. (2019) go on to derive closed-form expressions for RATE in this setting. The details are omitted here since the logic is largely analogous to what we learned above, but can be found in Ish-Horowicz et al. (2019).\n Conclusion The RATE criterion originally proposed by Crawford et al. (2019) and shown to be applicable to Bayesian neural networks in Ish-Horowicz et al. (2019) offers an intuitive way to measure variable importance in the context of deep learning. By defining variable importance as the contribution inputs make to a probabilistic model, it implicitly incorporates the interactions between covariates and nonlinearities that the model has learned. In other words, it allows researchers to peek directly into the Black Box. This opens up interesting avenues for future research, as the approach can be readily applied in academic disciplines and real-world applications that rely heavily on explainability of outcomes.\n  References Arrieta, Alejandro Barredo, Natalia Diaz-Rodriguez, Javier Del Ser, Adrien Bennetot, Siham Tabik, Alberto Barbado, Salvador Garcia, et al. 2020. “Explainable Artificial Intelligence (XAI): Concepts, Taxonomies, Opportunities and Challenges Toward Responsible AI.” Information Fusion 58: 82–115.  Bishop, Christopher M. 2006. Pattern Recognition and Machine Learning. springer.  Crawford, Lorin, Seth R Flaxman, Daniel E Runcie, and Mike West. 2019. “Variable Prioritization in Nonlinear Black Box Methods: A Genetic Association Case Study.” The Annals of Applied Statistics 13 (2): 958.  Fan, Fenglei, Jinjun Xiong, and Ge Wang. 2020. “On Interpretability of Artificial Neural Networks.” Preprint at Https://Arxiv. Org/Abs/2001.02522.  Goan, Ethan, and Clinton Fookes. 2020. “Bayesian Neural Networks: An Introduction and Survey.” In Case Studies in Applied Bayesian Data Science, 45–87. Springer.  Goodfellow, Ian, Yoshua Bengio, and Aaron Courville. 2016. Deep Learning. MIT Press.  Ish-Horowicz, Jonathan, Dana Udwin, Seth Flaxman, Sarah Filippi, and Lorin Crawford. 2019. “Interpreting Deep Neural Networks Through Variable Importance.” arXiv Preprint arXiv:1901.09839.      Simulatability describes the overall, high-level understandability of the mechanisms underlying the model – put simply, the less complex the model, the higher its simulatability. Decomposability concerns the extent to which the model can be taken apart into smaller pieces – neural networks by there very nature are compositions of multiple layers. Finally, algorithmic transparency refers to the extent to which the training of the algorithm is well-understood and to some extent observable – since DNNs generally deal with optimization of non-convex functions and often lack unique solution they are inherently intransparent.↩︎\n For more detail see for example here.↩︎\n For simplicity I have omitted the deterministic bias term.↩︎\n   ","date":1612656000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612656000,"objectID":"cc5ba12a4d6b1583862c168183715ef1","permalink":"https://www.paltmeyer.com/post/2021-02-01-a-peek-inside-the-black-box-interpreting-neural-networks/","publishdate":"2021-02-07T00:00:00Z","relpermalink":"/post/2021-02-01-a-peek-inside-the-black-box-interpreting-neural-networks/","section":"post","summary":"Research on explainable AI has recently gained considerable momentum. In this post I explore a Bayesian approach to ex-post explainability of Deep Neural Networks.","tags":["deeplearning","interpretableai","neuralnets","bayes"],"title":"A peek inside the 'Black Box' - interpreting neural networks","type":"post"},{"authors":null,"categories":["Coding"],"content":"   Getting started Deploying your website Why all the trouble? A simple coding example Embedding existing work Resources   Getting started It turns out building a static website in R is remarkably easy, as long as you know your way around R Markdown. Knowledge of HTML and CSS helps, but is not strictly necessary and can be acquired along the way. My package of choice for this website is blogdown by Yihui Xie who has had a major impact on the R community through his many package contributions (knitr, bookdown, pagedown, …) and certainly made my life a lot easier on many occasions.\nTo get started just follow the instructions on blogdown’s GitHub repository or keep reading here for a high-level overview. Setting up a basic website in R requires exactly two steps:\nSet up a local directory for the website. Let’s suppose you create it here ~/Documents/myAwesomeWebsite.\n In R, navigate to the directory and simply run blogdown::newsite().\n  This will set up a basic template which you can develop. Changing the theme and playing with the basic structure of the website is relatively straight-forward. Personally I have so far managed to work things out based on a working knowledge of HTML and CSS that I’ve developed in the past through my work with R Shiny.\n Deploying your website There are various ways to deploy your website, i.e. make it accessible to the public. This website is deployed through GitHub pages. Detailed instructions on how to do this can be found here. Since I already had an existing local clone of my pat-alt.github.io repo, I just dropped it in the source directory of the website:\nsource/ │ ├── config.yaml ├── content/ ├── themes/ └── ... patalt.github.io/ │ ├── .git/ ├── .nojekyll ├── index.html ├── about/ └── ... After adding publishDir: pat-alt.github.io to my config.yaml and then running blogdown::hugo_build() the website was built inside the clone. All that was left to do was to commit changes from the local clone to the pat-alt.github.io remote repo. A few moments later the website was already up and running.\n Why all the trouble? There are certainly easier ways to build a website. But if like me you do pretty much all your work in R Markdown and want to share some of it, then you will love blogdown. The beauty of it is that once the basic infrastructure is set up, adding content is as simple as running the following wrapper function\nblogdown::new_post(\u0026quot;Your new post\u0026quot;, ext = \u0026quot;.Rmd\u0026quot;) where the first argument is just the title of your post and the ext argument can be used to specify that you want to create an R Markdown document that can include code chucks. The wrapper function will automatically set up a directory for your post under /post/. R Studio will redirect you to the relevant .Rmd file that you can then fill with content. By default that folder will look roughly like this:\n├── index.Rmd ├── index.html └── index_files └── header-attrs └── header-attrs.js  A simple coding example As you can probably tell from the code chunks above this post was created just in the way I described. So I thought I might as well go ahead with a simple coding example to add some flavour. Suppose you have built some function that you think is worth sharing with the world or simply learned something new and interesting. As a case in point, I recently had a look at the Rcpp package and wrote a small program in C++ to be used in R. Since R Markdown supports Rcpp code chunks (along with Python, bash, SQL, …) it is straight-forward to show-case that code on this website.\nThe program can be used to simulate data from a categorical distribution. This distribution describes the possible results of a random variable that can take on one of \\(K\\) possible categories with different probabilities. In base R we could use rmultinom(n=1000,1,p=c(0.5,0.1,0.4)) to simulate draws from one such distribution with three different categories. Alternatively, we could write the program in C++ as follows:\n#include \u0026lt;Rcpp.h\u0026gt; using namespace Rcpp; // [[Rcpp::export]] NumericMatrix simCategorical(int n, NumericVector p) { int k = p.size(); NumericMatrix mat(k, n); // Normalise prob if necessary: if (sum(p)!=1) { p = p/sum(p); } NumericVector emp_cdf = cumsum(p); NumericVector u = Rcpp::runif(n, 0, 1); // Matrix for 1-hot-encoding: for (int j = 0; j \u0026lt; n; j++) { // Perform binary search: int l = 0; int r = k; double target = u[j]; while (l \u0026lt; r) { int m = floor((l+r)/2); if (emp_cdf[m] \u0026gt; target) { r = m; } else { l = m+1; } } mat(r,j) = 1; } return mat; } In terms of performance it turns out that the simple C++ program actually does somewhat better than the base R alternative:\nlibrary(microbenchmark) library(ggplot2) n \u0026lt;- 1000 p \u0026lt;- c(0.5,0.1,0.4) mb \u0026lt;- microbenchmark( \u0026quot;rmultinom\u0026quot; = {rmultinom(n, 1, p)}, \u0026quot;Rcpp\u0026quot; = {simCategorical(n, p)} ) autoplot(mb)  Embedding existing work If you have some existing work that you would like to share you can just use it to overwrite the index.Rmd file. blogdown supports any kind of R Markdown documents so you can use all of your favourite markdown packages (bookdown, pagedown, …). Just make sure to specify HTML output in the YAML header.\n Resources For more information about blogdown see here. To inspect the code that builds this website check out my GitHub repository.\n ","date":1612224000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612224000,"objectID":"661b258c151bbac47d2f2920ef41a0cf","permalink":"https://www.paltmeyer.com/post/how-i-m-building-this-website-in-r/","publishdate":"2021-02-02T00:00:00Z","relpermalink":"/post/how-i-m-building-this-website-in-r/","section":"post","summary":"Getting started Deploying your website Why all the trouble? A simple coding example Embedding existing work Resources   Getting started It turns out building a static website in R is remarkably easy, as long as you know your way around R Markdown.","tags":["blogdown","rmarkdown","C++"],"title":"How I'm building this website in R","type":"post"},{"authors":null,"categories":[],"content":"  Welcome to my website!\nHaving worked with R Markdown and some of Yihui Xie’s amazing packages for years, I have only now come across his blogdown package. For a while I have been thinking about a good way to share some of my work and actually started collecting snippets in a Gitbook through bookdown quite some time ago. While the book is a work-in-progress that I aim to finish eventually, I will use this website to regularly share content related to my work, research and other things.\n","date":1612137600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612137600,"objectID":"4f445dc46d10dacfc1a23cbea07e0ca5","permalink":"https://www.paltmeyer.com/post/welcome/","publishdate":"2021-02-01T00:00:00Z","relpermalink":"/post/welcome/","section":"post","summary":"Welcome to my website!\nHaving worked with R Markdown and some of Yihui Xie’s amazing packages for years, I have only now come across his blogdown package. For a while I have been thinking about a good way to share some of my work and actually started collecting snippets in a Gitbook through bookdown quite some time ago.","tags":[],"title":"Welcome","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://www.paltmeyer.com/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://www.paltmeyer.com/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://www.paltmeyer.com/project/internal-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://www.paltmeyer.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://www.paltmeyer.com/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About me","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e992907bc94a2c6bd63a1fab46926dad","permalink":"https://www.paltmeyer.com/work/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/work/","section":"","summary":"","tags":null,"title":"Work and Outreach","type":"widget_page"}]